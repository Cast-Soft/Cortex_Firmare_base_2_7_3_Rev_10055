###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     19/Mar/2019  14:40:59 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\RevJ #
#                     Beacon\firmware\common\CoOS\kernel\task.c               #
#    Command line =  "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\common\CoOS\kernel\task.c" -D          #
#                    BEACON_APP -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -D    #
#                    COOS -D USE_MY_ASSERT -D BC_HW_REVJ -D _DEBUG -D         #
#                    BOOTLOADER -D EE_M24C02 -D TASKS_PROFILE -D              #
#                    BATTERY_CHECK -D CCA_EN_NO -D NEW_BEACON -D USE_TIM4 -D  #
#                    WDT_ENABLE -D OLD_CONFIG -D CIRCULAR_LOG -lcN            #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\beacon\IAR\Debug-Bootloader-RevJ\List\ #
#                    " -o "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Rev #
#                    J\RevJ Beacon\firmware\beacon\IAR\Debug-Bootloader-RevJ\ #
#                    Obj\" --no_cse --no_unroll --no_inline --no_code_motion  #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.gi #
#                    t\RevJ\RevJ Beacon\firmware\beacon\IAR\..\App\" -I       #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\beacon\IAR\..\..\common\CMSIS\CM3\Devi #
#                    ceSupport\ST\STM32F10x\" -I                              #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\beacon\IAR\..\..\common\STM32F10x_StdP #
#                    eriph_Driver\inc\" -I "C:\Users\User\Documents\Cortex_gi #
#                    t\BLKT-01.git\RevJ\RevJ Beacon\firmware\beacon\IAR\..\.. #
#                    \common\CoOS\kernel\" -I "C:\Users\User\Documents\Cortex #
#                    _git\BLKT-01.git\RevJ\RevJ Beacon\firmware\beacon\IAR\.. #
#                    \..\common\CoOS\portable\" -I                            #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\beacon\IAR\..\..\..\common\" -I        #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\beacon\IAR\..\..\common\USB-Device-CDC #
#                    \" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Re #
#                    vJ\RevJ Beacon\firmware\beacon\IAR\..\..\common\" -I     #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\Rev #
#                    J Beacon\firmware\beacon\IAR\" -On --use_c++_inline -I   #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.4\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\RevJ #
#                     Beacon\firmware\beacon\IAR\Debug-Bootloader-RevJ\List\t #
#                    ask.lst                                                  #
#    Object file  =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\RevJ #
#                     Beacon\firmware\beacon\IAR\Debug-Bootloader-RevJ\Obj\ta #
#                    sk.o                                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\User\Documents\Cortex_git\BLKT-01.git\RevJ\RevJ Beacon\firmware\common\CoOS\kernel\task.c
      1          /**
      2           *******************************************************************************
      3           * @file       task.c
      4           * @version   V1.1.4
      5           * @date      2011.04.20
      6           * @brief      task management implementation code of CooCox CoOS kernel.
      7           *******************************************************************************
      8           * @copy
      9           *
     10           * INTERNAL FILE,DON'T PUBLIC.
     11           *
     12           * <h2><center>&copy; COPYRIGHT 2009 CooCox </center></h2>
     13           *******************************************************************************
     14           */
     15          
     16          
     17          /*---------------------------- Include ---------------------------------------*/
     18          #include <coocox.h>
     19          #include <stdint.h>
     20          
     21          /*---------------------------- Variable Define -------------------------------*/
     22          
     23          /*!< Table use to save TCB pointer.              */
     24          OSTCB    TCBTbl[CFG_MAX_USER_TASKS+SYS_TASK_NUM] = {{0}};
     25          
     26          /*!< The stack of IDLE task.                     */
     27          OS_STK   idle_stk[CFG_IDLE_STACK_SIZE] = {0};
     28          
     29          P_OSTCB  FreeTCB     = Co_NULL;  /*!< pointer to free TCB                        */
     30          P_OSTCB  TCBRdy      = Co_NULL;  /*!< Pointer to the READY list.                 */
     31          P_OSTCB  TCBNext     = Co_NULL;  /*!< Poniter to task that next scheduled by OS  */
     32          P_OSTCB  TCBRunning  = Co_NULL;  /*!< Pointer to TCB that current running task.  */
     33          U64      OSCheckTime = 0;     /*!< The counter of system tick.                */
     34          
     35          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
     36          OS_TID   PriNum;
     37          U8       ActivePri[CFG_MAX_USER_TASKS+SYS_TASK_NUM];
     38          U8       TaskNumPerPri[CFG_MAX_USER_TASKS+SYS_TASK_NUM];
     39          OS_TID   RdyTaskPri[CFG_MAX_USER_TASKS+SYS_TASK_NUM] = {0};
     40          U32      RdyTaskPriInfo[(CFG_MAX_USER_TASKS+SYS_TASK_NUM+31)/32];
     41          #endif
     42          
     43          #ifdef DEBUG_OS_TASK
     44          void PushSeq(P_OSTCB task, U16 line)
     45          {
     46              ++task->seqHead;
     47              if (task->seqHead >= SeqSize)
     48              {
     49                task->seqHead = 0;
     50              }
     51              
     52              task->seq[task->seqHead] = line;
     53          }
     54          #endif
     55          
     56          /**
     57           *******************************************************************************
     58           * @brief      Create a TCB list.
     59           * @param[in]  None
     60           * @param[out] None
     61           * @retval     None
     62           *
     63           * @par Description
     64           * @details    This function is called by CoOSInit() to initial the empty list
     65           *             of OS_TCBS,supply a pointer to free TCB.
     66           *******************************************************************************
     67           */
     68          void CreateTCBList(void)
     69          {
     70              U8  i;
     71              P_OSTCB ptcb1,ptcb2;
     72          
     73          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
     74          	PriNum = 0;
     75          #endif
     76          
     77          	ptcb1 = &TCBTbl[0];	                /* Build the free TCB list            */
     78              ptcb2 = &TCBTbl[1];
     79              for(i=0;i< (CFG_MAX_USER_TASKS+SYS_TASK_NUM-1);i++ )
     80              {
     81          		ptcb1->taskID    = i;
     82          		ptcb1->state     = TASK_DORMANT; TASK_SEQ(ptcb1);
     83                          assert(ptcb1 != ptcb2);
     84                  ptcb1->TCBnext   = ptcb2;
     85          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
     86          		RdyTaskPri[i]    = INVALID_ID;
     87          		ActivePri[i]	 = INVALID_ID;
     88          #endif
     89                  ptcb1++;
     90                  ptcb2++;
     91              }
     92          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
     93          		ActivePri[i]	 = INVALID_ID;
     94          #endif
     95          
     96          	ptcb1->taskID    = i;
     97              ptcb1->TCBnext   = Co_NULL;
     98              FreeTCB = &TCBTbl[0];         /* Initialize FreeTCB as head item of list  */
     99          }
    100          
    101          
    102          
    103          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    104          
    105          /**
    106           *******************************************************************************
    107           * @brief      Get sequence number for Assign priority
    108           * @param[in]  pri            Assign priority
    109           * @param[out] SequenceNum    priority number
    110           * @retval     Co_TRUE           Assign priority in priority queue.
    111           *             Co_FALSE          Assign priority not in priority queue.
    112           *
    113           * @par Description
    114           * @details    This function is called in Binary-Scheduling Algorithm
    115           *             to get sequence number for Assign priority.
    116           *******************************************************************************
    117           */
    118          static BOOL  GetPriSeqNum(U8 pri,OS_TID* SequenceNum)
    119          {
    120          	OS_TID  seqNum;
    121          	OS_TID  num,tmpNum;
    122          	num = 0;
    123          	seqNum = PriNum;
    124          	while(num != seqNum)
    125          	{
    126          		tmpNum = num;
    127          		num = (num+seqNum)/2;
    128          		if(pri == ActivePri[num])
    129          		{
    130          			*SequenceNum = num;
    131          			return Co_TRUE;
    132          		}
    133          		else if (pri < ActivePri[num])
    134          		{
    135          			seqNum = num;
    136          			num = tmpNum;
    137          		}
    138          		else
    139          		{
    140          			num++;
    141          		}
    142          	}
    143          	*SequenceNum = num;
    144          	return Co_FALSE;
    145          }
    146          
    147          
    148          /**
    149           *******************************************************************************
    150           * @brief      Get the nearest ready priority sequence number for Assign number
    151           * @param[in]  seqNum         Assign sequence number
    152           * @param[out] None
    153           * @retval     INVALID_ID     Cannot find higher ready priority.
    154           *             Others         Nearest ready priority sequence number
    155           *
    156           * @par Description
    157           * @details    This function is called in Binary-Scheduling Algorithm
    158           *             to get the nearest ready priority sequence number.
    159           *******************************************************************************
    160           */
    161          static U8 GetRdyPriSeqNum(U8 seqNum)
    162          {
    163          	U32 tmp;
    164          	U8  i,j,num;
    165          	S8  cnt;
    166          	i = seqNum/32;
    167          	j = seqNum%32;
    168          
    169          	do
    170          	{
    171          	  	tmp = RdyTaskPriInfo[i];
    172          		if(tmp != 0)
    173          		{
    174          			num = j/8;
    175          			do
    176          			{
    177          				if((tmp&(0xff<<(num*8))) !=0 )
    178          				{
    179          					if((tmp&(0xf0<<(num*8))) !=0)
    180          					{
    181          						for(cnt=j; cnt >=(num*8+4); cnt--)
    182          						{
    183          							if( (tmp&(1<<cnt)) !=0)
    184          							{
    185          								return (32*i+cnt);
    186          							}
    187          						}
    188          					}
    189          
    190          					if((j&0x4)==4)
    191          						j = (j|0x3) -4;
    192          
    193          					for(cnt=j; cnt >=num*8; cnt--)
    194          					{
    195          						if( (tmp&(1<<cnt)) !=0)
    196          						{
    197          							return (32*i+cnt);
    198          						}
    199          					}
    200          				}
    201          				j = num*8 -1;
    202          			}while((num--)!=0);
    203          		}
    204          		j=31;
    205          	}while((i--)!=0);
    206          	return INVALID_ID;
    207          }
    208          
    209          
    210          /**
    211           *******************************************************************************
    212           * @brief      Remap the ready status of priority queue from Assign sequence number
    213           * @param[in]  seqNum         Assign sequence number
    214           * @param[out] None
    215           * @retval     None
    216           *
    217           * @par Description
    218           * @details    This function is called in Binary-Scheduling Algorithm
    219           *             to Remap the ready status for priority queue.
    220           *******************************************************************************
    221           */
    222          static void PrioRemap(OS_TID  seqNum)
    223          {
    224          	U8 i,j;
    225          	U32 tmp;
    226          	tmp = j = 0;
    227          	j = seqNum/32;
    228          	for(i=0;i<seqNum%32;i++)
    229          	{
    230          		tmp |= 1<<i;
    231          	}
    232          	tmp &= RdyTaskPriInfo[j];
    233          
    234          	for(i=seqNum; i<PriNum; i++)
    235          	{
    236          		if((i%32==0)&&(i!=seqNum))
    237          		{
    238          			RdyTaskPriInfo[j++] = tmp;
    239          			tmp = 0;
    240          		}
    241          		if(RdyTaskPri[i] != INVALID_ID)
    242          		{
    243          			tmp = tmp | (1<<(i%32));
    244          		}
    245          	}
    246          	RdyTaskPriInfo[j++] = tmp;
    247          }
    248          
    249          
    250          /**
    251           *******************************************************************************
    252           * @brief      Get the ready status for assign sequence number
    253           * @param[in]  seqNum      Assign sequence number
    254           * @param[out] None
    255           * @retval     Co_TRUE        This priority has ready task
    256           *             Co_FALSE       This priority doesn't have ready task
    257           *
    258           * @par Description
    259           * @details    This function is called in Binary-Scheduling Algorithm
    260           *             to get the ready status for assign sequence number.
    261           *******************************************************************************
    262           */
    263          static BOOL GetPrioSeqNumStatus(U8 seqNum)
    264          {
    265          	if( (RdyTaskPriInfo[seqNum/32] & (1<<(seqNum%32))) == 0)
    266          	{
    267          		return Co_FALSE;
    268          	}
    269          	return Co_TRUE;
    270          }
    271          
    272          
    273          /**
    274           *******************************************************************************
    275           * @brief      Set the ready status for assign sequence number
    276           * @param[in]  seqNum      Assign sequence number
    277           * @param[in]  isRdy       Ready statues for assign sequence number
    278           * @param[out] None
    279           * @retval     None
    280           *
    281           * @par Description
    282           * @details    This function is called in Binary-Scheduling Algorithm
    283           *             to set the ready status for assign sequence number.
    284           *******************************************************************************
    285           */
    286          static void SetPrioSeqNumStatus(U8 seqNum, BOOL isRdy)
    287          {
    288          	U32 tmp;
    289          	tmp = RdyTaskPriInfo[seqNum/32];
    290          	tmp	&= ~(1<<(seqNum%32));
    291          	tmp |= isRdy<<(seqNum%32);
    292          	RdyTaskPriInfo[seqNum/32] = tmp;
    293          }
    294          
    295          
    296          /**
    297           *******************************************************************************
    298           * @brief      Active priority in queue
    299           * @param[in]  pri       Task priority
    300           * @param[in]  None
    301           * @param[out] None
    302           * @retval     None
    303           *
    304           * @par Description
    305           * @details    This function is called in Binary-Scheduling Algorithm
    306           *             to active priority in queue, if this priority had been in activation,
    307           *             increate the task num for this priority.
    308           *******************************************************************************
    309           */
    310          void ActiveTaskPri(U8 pri)
    311          {
    312          	OS_TID  seqNum,num;
    313          	if(GetPriSeqNum(pri,&seqNum) == Co_FALSE)
    314          	{
    315          		for(num=PriNum;num>seqNum;num--)
    316          		{
    317          			ActivePri[num]     = ActivePri[num-1];
    318          			TaskNumPerPri[num] = TaskNumPerPri[num-1];
    319          			RdyTaskPri[num]    = RdyTaskPri[num-1];
    320          		}
    321          		ActivePri[seqNum]     = pri;
    322          		TaskNumPerPri[seqNum] = 1;
    323          		RdyTaskPri[seqNum]    = INVALID_ID;
    324          		PriNum++;
    325          		PrioRemap(seqNum);
    326          	}
    327          	else
    328          	{
    329          		 TaskNumPerPri[seqNum]++;
    330          	}
    331          }
    332          
    333          
    334          
    335          /**
    336           *******************************************************************************
    337           * @brief      Delete priority in queue
    338           * @param[in]  pri       Task priority
    339           * @param[in]  None
    340           * @param[out] None
    341           * @retval     None
    342           *
    343           * @par Description
    344           * @details    This function is called in Binary-Scheduling Algorithm
    345           *             to decrease the task num for this priority, if the num goto 0,
    346           *             remove the priority for queue.
    347           *******************************************************************************
    348           */
    349          void DeleteTaskPri(U8 pri)
    350          {
    351          	OS_TID  seqNum,num;
    352          
    353          	GetPriSeqNum(pri,&seqNum);
    354          	TaskNumPerPri[seqNum]--;
    355          	if(TaskNumPerPri[seqNum]==0)
    356          	{
    357          		for(num=seqNum; num<(PriNum-1); num++)
    358          		{
    359          			ActivePri[num]     = ActivePri[num+1];
    360          			TaskNumPerPri[num] = TaskNumPerPri[num+1];
    361          			RdyTaskPri[num]    = RdyTaskPri[num+1];
    362          		}
    363          		PriNum--;
    364          		PrioRemap(seqNum);
    365          	}
    366          }
    367          
    368          #endif
    369          
    370          
    371          /**
    372           *******************************************************************************
    373           * @brief      Insert a task to the ready list
    374           * @param[in]  tcbInsert    A pointer to task will be inserted.
    375           * @param[out] None
    376           * @retval     None
    377           *
    378           * @par Description
    379           * @details   This function is called to insert a task to the READY list.
    380           *******************************************************************************
    381           */
    382          void InsertToTCBRdyList(P_OSTCB tcbInsert)
    383          {
    384              P_OSTCB ptcbNext,ptcb;
    385              U8  prio;
    386          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    387          	U8  seqNum;
    388          	U8  RdyTaskSeqNum;
    389          #endif
    390          
    391              prio = tcbInsert->prio;             /* Get PRI of inserted task           */
    392              tcbInsert->state     = TASK_READY;  TASK_SEQ(tcbInsert);   /* Set task as TASK_READY             */
    393          
    394          #if CFG_ROBIN_EN >0
    395          	ptcb = TCBRunning;
    396              /* Set schedule time for the same PRI task as TCBRunning.                 */
    397              if(prio == ptcb->prio)  /* Is PRI of inserted task equal to running task? */
    398              {
    399                  if(ptcb != tcbInsert) /* Yes,is inserted task equal to running task?  */
    400                  {
    401                      if(ptcb != Co_NULL)            /* No,TCBRunning == Co_NULL?             */
    402                      {                           /* N0,OSCheckTime < OSTickCnt?        */
    403                          if(OSCheckTime < OSTickCnt)
    404                          {                       /* Yes,set OSCheckTime for task robin */
    405                              OSCheckTime = OSTickCnt + ptcb->timeSlice;
    406                          }
    407                      }
    408                  }
    409              }
    410          #endif
    411          
    412          
    413          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    414          	GetPriSeqNum(prio,&seqNum);
    415          	if(GetPrioSeqNumStatus(seqNum) == Co_TRUE)
    416          	{
    417          		ptcb = &TCBTbl[RdyTaskPri[seqNum]];
    418          		RdyTaskPri[seqNum] = tcbInsert->taskID;
    419          	}
    420          	else
    421          	{
    422          		RdyTaskPri[seqNum] = tcbInsert->taskID;
    423          		RdyTaskSeqNum = GetRdyPriSeqNum(seqNum);
    424          		SetPrioSeqNumStatus(seqNum, 1);
    425          		if(RdyTaskSeqNum == INVALID_ID)
    426          		{
    427          		    ptcb = TCBRdy;
    428          		    TaskSchedReq = Co_TRUE;
    429          			if(ptcb == Co_NULL)
    430          			{
    431          				TCBRdy   = tcbInsert;
    432          			}
    433          			else
    434          			{
    435                                    assert(tcbInsert != ptcb);
    436          				tcbInsert->TCBnext = ptcb;  /* Yes,set tcbInsert as head item of list */
    437          				ptcb->TCBprev = tcbInsert;
    438          				TCBRdy         = tcbInsert;
    439          			}
    440          			return;
    441          		}
    442          		else
    443          		{
    444          			ptcb = &TCBTbl[RdyTaskPri[RdyTaskSeqNum]];
    445          		}
    446          	}
    447          
    448          	ptcbNext = ptcb->TCBnext;
    449                  assert(tcbInsert != ptcbNext);
    450          	tcbInsert->TCBnext = ptcbNext;    /* Set link for list                  */
    451          	ptcb->TCBnext      = tcbInsert;
    452          	tcbInsert->TCBprev = ptcb;
    453          	if(ptcbNext != Co_NULL)
    454          	{
    455          	    ptcbNext->TCBprev  = tcbInsert;
    456          	}
    457          
    458          
    459          #else
    460              ptcb = TCBRdy;
    461              if (ptcb == Co_NULL)                   /* Is ready list Co_NULL?                */
    462              {
    463                  TaskSchedReq = Co_TRUE;
    464                  TCBRdy = tcbInsert;         /* Yse,set tcbInsert as head item of list */
    465              }
    466              else if (prio < ptcb->prio)/* Is PRI of inserted task higher than TCBRdy? */
    467              {
    468                  TaskSchedReq = Co_TRUE;
    469                  assert(ptcb != tcbInsert);
    470                  tcbInsert->TCBnext = ptcb;  /* Yes,set tcbInsert as head item of list */
    471                  ptcb->TCBprev  = tcbInsert;
    472                  TCBRdy         = tcbInsert;
    473              }
    474              else                                /* No,find correct place              */
    475              {
    476                  ptcbNext = ptcb->TCBnext;       /* Get next item                      */
    477                  while(ptcbNext != Co_NULL)         /* Is last item in ready list?        */
    478                  {                               /* No,find correct place              */
    479                      if(prio < ptcbNext->prio)   /* Is correct place?                  */
    480                          break;                  /* Yes,break circulation              */
    481                      ptcb     = ptcbNext;        /* Save current item                  */
    482                      ptcbNext = ptcbNext->TCBnext; /* Get next item                    */
    483                  }
    484                  assert(tcbInsert != ptcbNext);
    485                  tcbInsert->TCBnext = ptcbNext;  /* Set link for list                  */
    486                  ptcb->TCBnext      = tcbInsert;
    487                  tcbInsert->TCBprev = ptcb;
    488                  if(ptcbNext != Co_NULL)
    489                  {
    490                      ptcbNext->TCBprev  = tcbInsert;
    491                  }
    492              }
    493          #endif
    494          }
    495          
    496          
    497          
    498          /**
    499           *******************************************************************************
    500           * @brief      Remove a task from the READY list
    501           * @param[in]  ptcb     A pointer to task which be removed.
    502           * @param[out] None
    503           * @retval     None
    504           *
    505           * @par Description
    506           * @details    This function is called to remove a task from the READY list.
    507           *******************************************************************************
    508           */
    509          void RemoveFromTCBRdyList(P_OSTCB ptcb)
    510          {
    511          TASK_SEQ(ptcb);
    512          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    513          	U8 prio;
    514          	U8 seqNum;
    515          	BOOL isChange;
    516          	isChange = Co_FALSE;
    517          	prio = ptcb->prio;
    518          	GetPriSeqNum(prio,&seqNum);
    519          #endif
    520          
    521              /* Is there only one item in READY list?                                  */
    522              if((ptcb->TCBnext == Co_NULL) && (ptcb->TCBprev == Co_NULL) )
    523              {   TASK_SEQ(ptcb);
    524                  TCBRdy = Co_NULL;                  /* Yes,set READY list as Co_NULL         */
    525          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    526          		isChange = Co_TRUE;
    527          #endif
    528              }
    529              else if(ptcb->TCBprev == Co_NULL)      /* Is the first item in READY list?   */
    530              {   TASK_SEQ(ptcb);
    531          	    /* Yes,remove task from the list,and reset the head of READY list     */
    532                  TCBRdy = ptcb->TCBnext;
    533                  ptcb->TCBnext   = Co_NULL;
    534                  TCBRdy->TCBprev = Co_NULL;
    535          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    536          		if(TCBRdy->prio != prio)
    537          			isChange = Co_TRUE;
    538          
    539          #endif
    540              }
    541              else if( ptcb->TCBnext == Co_NULL)     /* Is the last item in READY list?    */
    542              {   TASK_SEQ(ptcb);                    /* Yes,remove task from list          */
    543          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    544          		if(ptcb->TCBprev->prio != prio)
    545          			isChange = Co_TRUE;
    546          		else
    547          			RdyTaskPri[seqNum] = ptcb->TCBprev->taskID;
    548          #endif
    549                  ptcb->TCBprev->TCBnext = Co_NULL;
    550                  ptcb->TCBprev          = Co_NULL;
    551              }
    552              else                                /* No, remove task from list          */
    553              {  TASK_SEQ(ptcb);
    554          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    555          		if((ptcb->TCBprev->prio != prio) && (ptcb->TCBnext->prio != prio))
    556          			isChange = Co_TRUE;
    557          		else if((ptcb->TCBprev->prio == prio) && (ptcb->TCBnext->prio != prio))
    558          			RdyTaskPri[seqNum] = ptcb->TCBprev->taskID;
    559          #endif
    560                     assert(ptcb->TCBprev->TCBnext != ptcb->TCBprev);
    561                  ptcb->TCBprev->TCBnext = ptcb->TCBnext;
    562                  ptcb->TCBnext->TCBprev = ptcb->TCBprev;
    563                  ptcb->TCBnext = Co_NULL;
    564                  ptcb->TCBprev = Co_NULL;
    565              } TASK_SEQ(ptcb);
    566          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    567          		if(isChange == Co_TRUE)
    568          		{
    569          			RdyTaskPri[seqNum] = INVALID_ID;
    570          			SetPrioSeqNumStatus(seqNum, 0);
    571          		}
    572          #endif  
    573          }
    574          
    575          
    576          #if CFG_MUTEX_EN > 0
    577          #define CFG_PRIORITY_SET_EN       (1)
    578          #endif
    579          #if CFG_PRIORITY_SET_EN >0
    580          /**
    581           *******************************************************************************
    582           * @brief      Change task priority
    583           * @param[in]  taskID     Specify task id.
    584           * @param[in]  priority   New priority.
    585           * @param[out] None
    586           * @retval     E_OK              Change priority successful.
    587           * @retval     E_INVALID_ID      Invalid id,change priority fail.
    588           * @retval     E_PROTECTED_TASK  Can't change idle task priority.
    589           *
    590           * @par Description
    591           * @details    This function is called to change priority for a specify task.
    592           *******************************************************************************
    593           */
    594          StatusType CoSetPriority(OS_TID taskID,U8 priority)
    595          {
    596              P_OSTCB ptcb;
    597          #if CFG_MUTEX_EN >0
    598              U8 prio;
    599              P_MUTEX	pMutex;
    600          #endif
    601          #if CFG_EVENT_EN >0
    602              P_ECB pecb;
    603          #endif
    604          
    605              if(taskID == 0)                     /* Is idle task?                      */
    606              {
    607                  return E_PROTECTED_TASK;        /* Yes,error return                   */
    608              }
    609          
    610          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
    611              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
    612              {
    613                  return E_INVALID_ID;
    614              }
    615          #endif
    616          	ptcb = &TCBTbl[taskID];             /* Get TCB of task ID                 */
    617          #if CFG_PAR_CHECKOUT_EN >0
    618              if(ptcb->state == TASK_DORMANT)
    619              {
    620                  return E_INVALID_ID;
    621              }
    622              if(priority > CFG_LOWEST_PRIO)
    623              {
    624                  return E_INVALID_ID;
    625              }
    626          #endif
    627          
    628              if(ptcb->prio != priority)          /* Is PRI equal to original PRI?      */
    629              {                                   /* No                                 */
    630          #if CFG_MUTEX_EN >0
    631                  if(ptcb->mutexID != INVALID_ID)
    632                  {
    633                      pMutex = &MutexTbl[ptcb->mutexID];
    634                      if(pMutex->taskID == ptcb->taskID)  /* Task hold mutex?               */
    635                      {
    636                           pMutex->originalPrio= priority;/* Yes,change original PRI in mutex*/
    637                           if(ptcb->prio < priority)     /* Is task priority higher than set?*/
    638                           {
    639                               return E_OK;                /* Yes,do nothing,return OK       */
    640                           }
    641                      }
    642                   }
    643          
    644          #endif
    645          
    646          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
    647          		DeleteTaskPri(ptcb->prio);
    648          		ActiveTaskPri(priority);
    649          #endif
    650          
    651                  ptcb->prio = priority;              /* Change task PRI                */
    652                  if(ptcb->state == TASK_READY)       /* Is task in READY list?         */
    653                  {
    654                      OsSchedLock();                  /* Yes,reorder task in READY list */
    655                      TASK_SEQ(ptcb); RemoveFromTCBRdyList(ptcb);
    656                      TASK_SEQ(ptcb); InsertToTCBRdyList(ptcb);
    657                      OsSchedUnlock();
    658                  }
    659                  else if(ptcb->state == TASK_RUNNING)/* Is task running?               */
    660                  {
    661                      if(ptcb->prio > TCBRdy->prio)   /* Yes,Is PRI higher than TCBRdy? */
    662                      {
    663          				OsSchedLock();              /* Yes,reorder task in READY list */
    664          				TaskSchedReq = Co_TRUE;
    665                          OsSchedUnlock();
    666                      }
    667                  }
    668                  else
    669                  {                                   /* No,task in WAITING list        */
    670          #if CFG_MUTEX_EN >0
    671                      if(ptcb->mutexID != INVALID_ID) /* Is task in mutex WAITING list? */
    672                      {
    673                          /* Yes,reset the highest PRI in the list */
    674          				OsSchedLock();
    675          				pMutex = &MutexTbl[ptcb->mutexID];
    676                          ptcb = pMutex->waittingList;
    677                          prio = pMutex->originalPrio;
    678                          pMutex->hipriTaskID = pMutex->taskID;
    679                          while(ptcb != Co_NULL)
    680                          {
    681                              if(ptcb->prio < prio)
    682                              {
    683                                  prio = ptcb->prio;
    684                                  pMutex->hipriTaskID = ptcb->taskID;
    685                              }
    686                              ptcb = ptcb->TCBnext;
    687                          }
    688          				OsSchedUnlock();
    689                          if(pMutex->originalPrio != prio)
    690                          {
    691                              CoSetPriority(pMutex->taskID,prio);
    692                          }
    693                      }
    694          #endif
    695          
    696          #if CFG_EVENT_EN >0
    697          			ptcb = &TCBTbl[taskID];
    698                      if(ptcb->eventID != INVALID_ID) /* Is task in event WAITING list? */
    699                      {
    700                          pecb = &EventTbl[ptcb->eventID];
    701          
    702                          /* Yes,is event sort type as preemptive PRI?                  */
    703                          if(pecb->eventSortType == EVENT_SORT_TYPE_PRIO)
    704                          {
    705                              /* Yes,reorder task in the list                           */
    706                              RemoveEventWaittingList(ptcb);
    707                              EventTaskToWait(pecb,ptcb);
    708                          }
    709                      }
    710          #endif
    711                  }
    712              }
    713              return E_OK;
    714          }
    715          #endif
    716          
    717          // line and func not inside TASKS_PROFILE
    718          // just to simplify linking
    719          U16             line;
    720          const char *    func;
    721          #ifdef TASKS_PROFILE
    722          static OS_TID          currentTaskId;
    723          U32             globl;
    724          #endif
    725          
    726          
    727          
    728          /**
    729           *******************************************************************************
    730           * @brief      Schedule function
    731           * @param[in]  None
    732           * @param[out] None
    733           * @retval     None
    734           *
    735           * @par Description
    736           * @details    This function is called by every where need to switch context,
    737           *             It is schedule function of OS kernel.
    738           *******************************************************************************
    739           */
    740          void Schedule(void)
    741          {
    742              U8  RunPrio,RdyPrio; 
    743              P_OSTCB pRdyTcb,pCurTcb;
    744              pCurTcb = TCBRunning;
    745              pRdyTcb = TCBRdy;
    746          
    747          	if((pRdyTcb==Co_NULL) || (pCurTcb != TCBNext) || (OSSchedLock >1) || (OSIntNesting >0))
    748          	{
    749          		return;
    750          	}
    751          
    752              TaskSchedReq = Co_FALSE; TASK_SEQ(TCBNext);
    753              RunPrio = pCurTcb->prio;
    754              RdyPrio = pRdyTcb->prio;
    755          
    756          	/* Is Running task status was changed? */
    757              if(pCurTcb->state != TASK_RUNNING)
    758              {
    759          #ifdef DEBUG_OS_TASK
    760                  TCBNext->lastTCBNextState = pCurTcb->state;
    761          #endif
    762          		TASK_SEQ(TCBNext); TCBNext        = pRdyTcb;   /* Yes,set TCBNext and reorder READY list */
    763                  pRdyTcb->state = TASK_RUNNING; TASK_SEQ(pRdyTcb);
    764                  TASK_SEQ(pRdyTcb); RemoveFromTCBRdyList(pRdyTcb); TASK_SEQ(pRdyTcb);
    765              }
    766          
    767              else if(RdyPrio < RunPrio )     /* Is higher PRI task coming in?          */
    768              {
    769                  TASK_SEQ(TCBNext); TCBNext        = pRdyTcb;   /* Yes,set TCBNext and reorder READY list */
    770                  TASK_SEQ(pCurTcb); InsertToTCBRdyList(pCurTcb);
    771          	TASK_SEQ(pRdyTcb); RemoveFromTCBRdyList(pRdyTcb); TASK_SEQ(pRdyTcb);  
    772                  TASK_SEQ(pRdyTcb); pRdyTcb->state = TASK_RUNNING;
    773              }
    774          
    775          #if CFG_ROBIN_EN >0                 /* Is time for robinning                  */
    776              else if((RunPrio == RdyPrio) && (OSCheckTime == OSTickCnt))
    777              {
    778                  TASK_SEQ(TCBNext); TCBNext        = pRdyTcb;   /* Yes,set TCBNext and reorder READY list */
    779                  TASK_SEQ(pCurTcb); InsertToTCBRdyList(pCurTcb);
    780          	TASK_SEQ(pRdyTcb); RemoveFromTCBRdyList(pRdyTcb); TASK_SEQ(pRdyTcb);
    781                  TASK_SEQ(pRdyTcb); pRdyTcb->state = TASK_RUNNING;
    782              }
    783          #endif
    784              else
    785              {
    786                  TASK_SEQ(TCBNext); return;
    787              }
    788          
    789              TASK_SEQ(TCBNext);
    790          #if CFG_ROBIN_EN >0
    791              if(TCBNext->prio == TCBRdy->prio)  /* Reset OSCheckTime for task robinnig */
    792                  OSCheckTime = OSTickCnt + TCBNext->timeSlice;
    793          #endif
    794          
    795          
    796          #if CFG_STK_CHECKOUT_EN > 0                       /* Is stack overflow?       */
    797              if((pCurTcb->stkPtr < pCurTcb->stack)||(*(U32*)(pCurTcb->stack) != MAGIC_WORD))
    798              {
    799                  CoStkOverflowHook(pCurTcb->taskID);       /* Yes,call handler         */
    800              }
    801          #endif
    802              TASK_SEQ(TCBNext);
    803          #ifdef TASKS_PROFILE
    804              TCBRunning->func = func;
    805              TCBRunning->line = line;
    806              TCBRunning->glbFirst = TCBRunning->glbLast;
    807              TCBRunning->glbLast = globl;
    808              TCBRunning->scheduled++;
    809              func = TCBNext->func;
    810              line = TCBNext->line;
    811              currentTaskId = TCBNext->taskID;
    812              globl++;
    813          #endif
    814                  TASK_SEQ(TCBNext); SwitchContext(); TASK_SEQ(TCBNext);                             /* Call task context switch */
    815          }
    816          
    817          #ifdef TASKS_PROFILE
    818          
    819          OS_TID CoGetCurrentTaskId()
    820          {
    821            return currentTaskId;
    822          }
    823          
    824          U32 CoGetStackDepth(OS_TID taskID)
    825          {
    826                P_OSTCB ptcb;
    827          
    828          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
    829              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
    830              {
    831                  return 0;
    832              }
    833          #endif
    834          
    835            ptcb = &TCBTbl[taskID];             /* Get TCB of task ID                 */
    836          
    837            return ptcb->sktSz - (ptcb->stack - ptcb->stkPtr);
    838          
    839          }
    840          
    841          U32 CoGetTaskScheduledCount(OS_TID taskID)
    842          {
    843                P_OSTCB ptcb;
    844          
    845          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
    846              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
    847              {
    848                  return 0;
    849              }
    850          #endif
    851              ptcb = &TCBTbl[taskID];             /* Get TCB of task ID                 */
    852          
    853            return ptcb->scheduled;
    854          }
    855          
    856          U16 CoGetTaskLine(OS_TID taskID) {
    857                P_OSTCB ptcb;
    858          
    859          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
    860              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
    861              {
    862                  return 0;
    863              }
    864          #endif
    865              ptcb = &TCBTbl[taskID];             /* Get TCB of task ID                 */
    866          
    867            return ptcb->line;
    868          }
    869          
    870          const char* CoGetTaskFunc(OS_TID taskID) {
    871                P_OSTCB ptcb;
    872          
    873          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
    874              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
    875              {
    876                  return 0;
    877              }
    878          #endif
    879              ptcb = &TCBTbl[taskID];             /* Get TCB of task ID                 */
    880          
    881            return ptcb->func;
    882          }
    883          
    884          #endif
    885          
    886          
    887          /**
    888           *******************************************************************************
    889           * @brief      Assign a TCB to task being created
    890           * @param[in]  None
    891           * @param[out] None
    892           *
    893           * @retval     XXXX
    894           *
    895           * @par Description
    896           * @details    This function is called to assign a task control block for task
    897           *              being created.
    898           *******************************************************************************
    899           */
    900          static P_OSTCB AssignTCB(void)
    901          {
    902              P_OSTCB	ptcb;
    903          
    904              OsSchedLock();                      /* Lock schedule                      */
    905              if(FreeTCB == Co_NULL)                 /* Is there no free TCB               */
    906              {
    907                  OsSchedUnlock();                /* Yes,unlock schedule                */
    908                  return Co_NULL;                    /* Error return                       */
    909              }
    910          	ptcb    = FreeTCB;          /* Yes,assgin free TCB for this task  */
    911          	/* Set next item as the head of free TCB list                     */
    912              FreeTCB = FreeTCB->TCBnext;
    913          	OsSchedUnlock();
    914          	return ptcb;
    915          }
    916          
    917          
    918          /**
    919           *******************************************************************************
    920           * @brief      Create a task
    921           * @param[in]  task       Task code entry.
    922           * @param[in]  argv       The parameter passed to task.
    923           * @param[in]  parameter  Task priority + stack size + time slice + isWaitting.
    924           * @param[in]  stk        Pointer to stack top of task.
    925           * @param[out] None
    926           * @retval     E_CREATE_FAIL    Fail to create a task .
    927           * @retval     others           Valid task id.
    928           *
    929           * @par Description
    930           * @details    This function is called by application to create a task,return a id
    931           *             to mark this task.
    932           *******************************************************************************
    933           */
    934          OS_TID CreateTask(FUNCPtr task,void *argv,U32 parameter,OS_STK *stk)
    935          {
    936              OS_STK* stkTopPtr;
    937              P_OSTCB ptcb;
    938              U8      prio;
    939          #if CFG_ROBIN_EN >0
    940              U16     timeSlice;
    941          #endif
    942          
    943          #if CFG_STK_CHECKOUT_EN >0              /* Check validity of parameter        */
    944              U16 sktSz;
    945              sktSz = (parameter&0xfff00)>>8;
    946          #endif
    947              prio = parameter&0xff;
    948          
    949          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
    950              if(task == Co_NULL)
    951              {
    952                  return E_CREATE_FAIL;
    953              }
    954              if(stk == Co_NULL)
    955              {
    956                  return E_CREATE_FAIL;
    957              }
    958              if(prio > CFG_LOWEST_PRIO)
    959              {
    960                  return E_CREATE_FAIL;
    961              }
    962          #if CFG_STK_CHECKOUT_EN >0
    963              if(sktSz < 20)
    964              {
    965                  return E_CREATE_FAIL;
    966              }
    967          #endif	  // CFG_STK_CHECKOUT_EN
    968          #endif	  // CFG_PAR_CHECKOUT_EN
    969          
    970          #if CFG_TASK_SCHEDULE_EN == 0
    971          	if(TCBRunning != Co_NULL)
    972          		 return E_CREATE_FAIL;
    973          #endif
    974          
    975              stkTopPtr = InitTaskContext(task,argv,stk);   /* Initialize task context. */
    976          
    977              ptcb = AssignTCB();                 /* Get free TCB to use                */
    978          
    979              if(ptcb == Co_NULL)                    /* Is free TCB equal to Co_NULL?         */
    980              {
    981                  return E_CREATE_FAIL;           /* Yes,error return                   */
    982              }
    983          #ifdef TASKS_PROFILE
    984              U16 stackSz = (parameter&0xfff00)>>8;
    985              ptcb->sktSz = stackSz;
    986              ptcb->scheduled = 0;
    987              ptcb->func = "None";
    988              ptcb->glbFirst = 0;
    989              ptcb->glbLast = 0;
    990              ptcb->line = 0;
    991          #endif
    992              ptcb->stkPtr = stkTopPtr;           /* Initialize TCB as user set         */
    993              ptcb->prio   = prio;
    994          #if CFG_STK_CHECKOUT_EN >0
    995              ptcb->stack = stk+1 - sktSz; /* Set bottom stack for stack overflow check */
    996              *(U32*)(ptcb->stack) = MAGIC_WORD;
    997          #endif
    998          
    999          #if CFG_TASK_WAITTING_EN >0
   1000              ptcb->delayTick	= INVALID_VALUE;
   1001          #endif
   1002          
   1003          #if CFG_TASK_SCHEDULE_EN == 0
   1004          	ptcb->taskFuc = task;
   1005          	ptcb->taskStk = stk;
   1006          #endif
   1007              ptcb->TCBnext = Co_NULL;               /* Initialize TCB link in READY list  */
   1008              ptcb->TCBprev = Co_NULL;
   1009          
   1010          #if CFG_ROBIN_EN >0						/* Set task time slice for task robin */
   1011              timeSlice = (parameter&0x7fff0000)>>20;
   1012              if(timeSlice == 0)
   1013              {
   1014                  timeSlice = CFG_TIME_SLICE;
   1015              }
   1016              ptcb->timeSlice = timeSlice;
   1017          #endif
   1018          
   1019          #if CFG_FLAG_EN > 0
   1020              ptcb->pnode = Co_NULL;                 /* Initialize task as no flag waiting */
   1021          #endif
   1022          
   1023          #if CFG_EVENT_EN > 0
   1024              ptcb->eventID  = INVALID_ID;      	/* Initialize task as no event waiting*/
   1025              ptcb->pmail    = Co_NULL;
   1026              ptcb->waitNext = Co_NULL;
   1027              ptcb->waitPrev = Co_NULL;
   1028          #endif
   1029          
   1030          #if CFG_MUTEX_EN > 0
   1031              /* Initialize task as no mutex holding or waiting                         */
   1032              ptcb->mutexID = INVALID_ID;
   1033          #endif
   1034          
   1035          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
   1036          	ActiveTaskPri(prio);
   1037          #endif
   1038          
   1039          	if((parameter>>31) == 0)			/* Is task in waitting state?         */
   1040          	{									/* No,set it into ready list          */
   1041          		OsSchedLock();                  /* Lock schedule                      */
   1042          		TASK_SEQ(ptcb); InsertToTCBRdyList(ptcb);       /* Insert into the READY list         */
   1043          	    OsSchedUnlock();                /* Unlock schedule                    */
   1044          	}
   1045          	else
   1046          	{									/* Yes,Set task status as TASK_WAITING*/
   1047          		ptcb->state   = TASK_WAITING; TASK_SEQ(ptcb);
   1048          	}
   1049              return ptcb->taskID;                /* Return task ID                     */
   1050          }
   1051          
   1052          
   1053          /**
   1054           *******************************************************************************
   1055           * @brief      Delete Task
   1056           * @param[in]  taskID      Task ID
   1057           * @param[out] None
   1058           * @retval     E_INVALID_ID      Invalid task ID.
   1059           * @retval     E_PROTECTED_TASK  Protected task in OS.
   1060           * @retval     E_OK              Delete successful.
   1061           *
   1062           * @par Description
   1063           * @details    This function is called to delete assign task.
   1064           *******************************************************************************
   1065           */
   1066          StatusType CoDelTask(OS_TID taskID)
   1067          {
   1068              P_OSTCB ptcb;
   1069          
   1070          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
   1071              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
   1072              {
   1073                  return E_INVALID_ID;
   1074              }
   1075          #endif
   1076          	ptcb = &TCBTbl[taskID];
   1077          #if CFG_PAR_CHECKOUT_EN >0
   1078              if(ptcb->state == TASK_DORMANT)
   1079              {
   1080                  return E_INVALID_ID;
   1081              }
   1082          #endif
   1083              if(taskID == 0)                     /* Is idle task?                      */
   1084              {
   1085                  return E_PROTECTED_TASK;        /* Yes,error return                   */
   1086              }
   1087          
   1088              if(ptcb->state == TASK_RUNNING)     /* Is task running?                   */
   1089              {
   1090                  if(OSSchedLock != 0)            /* Yes,is OS lock?                    */
   1091                  {
   1092                      return E_OS_IN_LOCK;        /* Yes,error return                   */
   1093                  }
   1094              }
   1095          
   1096          #if CFG_MUTEX_EN >0                     /* Do task hold mutex?                */
   1097              if(ptcb->mutexID != INVALID_ID)
   1098          	{
   1099                  if(MutexTbl[ptcb->mutexID].taskID == ptcb->taskID)
   1100                  {                               /* Yes,leave the mutex                */
   1101                      CoLeaveMutexSection(ptcb->mutexID);
   1102                  }
   1103              }
   1104          
   1105          #endif
   1106          
   1107              OsSchedLock();                      /* Lock schedule                      */
   1108          
   1109              if(ptcb->state == TASK_READY)       /* Is task in READY list?             */
   1110              {
   1111                  TASK_SEQ(ptcb); RemoveFromTCBRdyList(ptcb);     /* Yes,remove task from the READY list*/
   1112          
   1113              }
   1114          
   1115          
   1116          #if CFG_TASK_WAITTING_EN > 0
   1117              else if(ptcb->state == TASK_WAITING)/* Is task in the WAITING list?       */
   1118              {
   1119                  /* Yes,Is task in delay list? */
   1120                  if(ptcb->delayTick != INVALID_VALUE)
   1121                  {
   1122                      RemoveDelayList(ptcb);      /* Yes,remove task from READY list    */
   1123                  }
   1124          
   1125          #if CFG_EVENT_EN > 0
   1126                  if(ptcb->eventID != INVALID_ID) /* Is task in event waiting list?     */
   1127                  {
   1128                      /* Yes,remove task from event waiting list                        */
   1129                      RemoveEventWaittingList(ptcb);
   1130                  }
   1131          #endif
   1132          
   1133          #if CFG_FLAG_EN > 0
   1134                  if(ptcb->pnode != Co_NULL)         /* Is task in flag waiting list?      */
   1135                  {
   1136                      /* Yes,remove task from flag waiting list                         */
   1137                      RemoveLinkNode(ptcb->pnode);
   1138                  }
   1139          #endif
   1140          
   1141          #if CFG_MUTEX_EN >0
   1142                  if(ptcb->mutexID != INVALID_ID) /* Is task in mutex waiting list?     */
   1143                  {
   1144                      RemoveMutexList(ptcb);  /* Yes,remove task from mutex waiting list*/
   1145                  }
   1146          #endif
   1147          	  }
   1148          #endif
   1149              ptcb->state   = TASK_DORMANT; TASK_SEQ(ptcb);   /* Release TCB                        */
   1150          	TaskSchedReq  = Co_TRUE;
   1151          
   1152          #if CFG_ORDER_LIST_SCHEDULE_EN ==0
   1153          	DeleteTaskPri(ptcb->prio);
   1154          #endif
   1155          
   1156          #if CFG_TASK_SCHEDULE_EN >0
   1157                  assert(ptcb != FreeTCB);
   1158              ptcb->TCBnext = FreeTCB;
   1159              FreeTCB       = ptcb;
   1160          #endif
   1161              OsSchedUnlock();                    /* Unlock schedule                    */
   1162              return E_OK;                        /* return OK                          */
   1163          }
   1164          
   1165          
   1166          /**
   1167           *******************************************************************************
   1168           * @brief      Exit Task
   1169           * @param[in]  None
   1170           * @param[out] None
   1171           * @retval     None
   1172           *
   1173           * @par Description
   1174           * @details    This function is called to exit current task.
   1175           *******************************************************************************
   1176           */
   1177          void CoExitTask(void)
   1178          {
   1179              CoDelTask(TCBRunning->taskID);      /* Call task delete function          */
   1180          }
   1181          
   1182          
   1183          #if CFG_TASK_SCHEDULE_EN ==0
   1184          /**
   1185           *******************************************************************************
   1186           * @brief      Activate Task
   1187           * @param[in]  taskID      Task ID
   1188           * @param[in]  argv        Task argv
   1189           * @param[out] None
   1190           * @retval     E_INVALID_ID      Invalid task ID.
   1191           * @retval     E_OK              Activate task successful.
   1192           *
   1193           * @par Description
   1194           * @details    This function is called to activate current task.
   1195           *******************************************************************************
   1196           */
   1197          StatusType CoActivateTask(OS_TID taskID,void *argv)
   1198          {
   1199          	P_OSTCB ptcb;
   1200          	OS_STK* stkTopPtr;
   1201          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
   1202              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
   1203              {
   1204                  return E_INVALID_ID;
   1205              }
   1206          #endif
   1207          	ptcb = &TCBTbl[taskID];
   1208          #if CFG_PAR_CHECKOUT_EN >0
   1209          	if(ptcb->stkPtr == Co_NULL)
   1210          		return E_INVALID_ID;
   1211          #endif
   1212          	if(ptcb->state != TASK_DORMANT)
   1213          		return E_OK;
   1214          
   1215          
   1216          									    /* Initialize task context. */
   1217          	stkTopPtr = InitTaskContext(ptcb->taskFuc,argv,ptcb->taskStk);
   1218          
   1219              ptcb->stkPtr = stkTopPtr;           /* Initialize TCB as user set         */
   1220          	OsSchedLock();                      /* Lock schedule                      */
   1221          	TASK_SEQ(ptcb); InsertToTCBRdyList(ptcb);           /* Insert into the READY list         */
   1222              OsSchedUnlock();                    /* Unlock schedule                    */
   1223          	return E_OK;
   1224          }
   1225          #endif
   1226          
   1227          
   1228          /**
   1229           *******************************************************************************
   1230           * @brief      Get current task id
   1231           * @param[in]  None
   1232           * @param[out] None
   1233           * @retval     ID of the current task.
   1234           *
   1235           * @par Description
   1236           * @details    This function is called to get current task id.
   1237           *******************************************************************************
   1238           */
   1239          OS_TID CoGetCurTaskID(void)
   1240          {
   1241              return (TCBRunning->taskID);        /* Return running task ID             */
   1242          }
   1243          
   1244          #if CFG_TASK_SUSPEND_EN >0
   1245          /**
   1246           *******************************************************************************
   1247           * @brief      Suspend Task
   1248           * @param[in]  taskID    ID of task that want to suspend.
   1249           * @param[out] None
   1250           * @retval     E_OK                  Task suspend successful.
   1251           * @retval     E_INVALID_ID          Invalid event ID.
   1252           * @retval     E_PROTECTED_TASK      Can't suspend idle task.
   1253           * @retval     E_ALREADY_IN_WAITING  Task now in waiting state.
   1254          
   1255           *
   1256           * @par Description
   1257           * @details    This function is called to exit current task.
   1258           *******************************************************************************
   1259           */
   1260          StatusType CoSuspendTask(OS_TID taskID)
   1261          {
   1262              P_OSTCB ptcb;
   1263          
   1264          	if(taskID == 0)                     /* Is idle task?                      */
   1265              {
   1266                  return E_PROTECTED_TASK;        /* Yes,error return                   */
   1267              }
   1268          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
   1269              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
   1270              {
   1271                  return E_INVALID_ID;
   1272              }
   1273          #endif
   1274          	ptcb = &TCBTbl[taskID];
   1275          #if CFG_PAR_CHECKOUT_EN >0
   1276              if(ptcb->state == TASK_DORMANT)
   1277              {
   1278                  return E_INVALID_ID;
   1279              }
   1280          #endif
   1281              if(OSSchedLock != 0)
   1282              {
   1283                  return E_OS_IN_LOCK;
   1284              }
   1285              if(ptcb->state == TASK_WAITING)     /* Is task in WAITING list?           */
   1286              {
   1287                  return E_ALREADY_IN_WAITING;    /* Yes,error return                   */
   1288              }
   1289          
   1290              OsSchedLock();
   1291              if(ptcb != TCBRunning)              /* Is runing task?                    */
   1292              {
   1293                  TASK_SEQ(ptcb); RemoveFromTCBRdyList(ptcb);     /* No,Remove task from READY list     */
   1294              }
   1295          	else
   1296          	{
   1297          		TaskSchedReq = Co_TRUE;
   1298          	}
   1299          
   1300              ptcb->state = TASK_WAITING;	TASK_SEQ(ptcb);        /* Set task status as TASK_WAITING    */
   1301              OsSchedUnlock();                    /* Call task schedule                 */
   1302              return E_OK;                        /* Return OK                          */
   1303          }
   1304          
   1305          
   1306          /**
   1307           *******************************************************************************
   1308           * @brief      Awake Task
   1309           * @param[in]  taskID      ID of task that will been awaked.
   1310           * @param[out] None
   1311           * @retval     E_OK                 Task awake successful.
   1312           * @retval     E_INVALID_ID         Invalid task ID.
   1313           * @retval     E_TASK_NOT_WAITING   Task now not in waiting state.
   1314           * @retval     E_TASK_WAIT_OTHER    Task now waiting other awake event.
   1315           * @retval     E_PROTECTED_TASK     Idle task mustn't be awaked.
   1316           *
   1317           * @par Description
   1318           * @details    This function is called to awake current task.
   1319           *******************************************************************************
   1320           */
   1321          StatusType CoAwakeTask(OS_TID taskID)
   1322          {
   1323              P_OSTCB ptcb;
   1324          
   1325           	if(taskID == 0)                     /* Is idle task?                      */
   1326              {
   1327                  return E_PROTECTED_TASK;        /* Yes,error return                   */
   1328              }
   1329          #if CFG_PAR_CHECKOUT_EN >0              /* Check validity of parameter        */
   1330              if(taskID >= CFG_MAX_USER_TASKS + SYS_TASK_NUM)
   1331              {
   1332                  return E_INVALID_ID;
   1333              }
   1334          #endif
   1335          	ptcb = &TCBTbl[taskID];
   1336          #if CFG_PAR_CHECKOUT_EN >0
   1337              if(ptcb->state == TASK_DORMANT)
   1338              {
   1339                  return E_INVALID_ID;
   1340              }
   1341          #endif
   1342          
   1343              if(ptcb->state != TASK_WAITING)     /* Is task in WAITING list            */
   1344              {
   1345                  return E_TASK_NOT_WAITING;      /* No,error return                    */
   1346              }
   1347          
   1348          #if CFG_TASK_WAITTING_EN > 0
   1349              if(ptcb->delayTick != INVALID_VALUE)/* Is task in READY list              */
   1350              {
   1351                  return E_TASK_WAIT_OTHER;       /* Yes,error return                   */
   1352              }
   1353          
   1354          #if CFG_FLAG_EN > 0
   1355              if(ptcb->pnode != Co_NULL)             /* Is task in flag waiting list       */
   1356              {
   1357                  return E_TASK_WAIT_OTHER;       /* Yes,error return                   */
   1358              }
   1359          #endif
   1360          
   1361          #if CFG_EVENT_EN>0
   1362              if(ptcb->eventID != INVALID_ID)     /* Is task in event waiting list      */
   1363              {
   1364                  return E_TASK_WAIT_OTHER;       /* Yes,error return                   */
   1365              }
   1366          #endif
   1367          
   1368          #if CFG_MUTEX_EN > 0
   1369              if(ptcb->mutexID != INVALID_ID)     /* Is task in mutex waiting list      */
   1370              {
   1371                  return E_TASK_WAIT_OTHER;       /* Yes,error return                   */
   1372              }
   1373          #endif
   1374          
   1375          #endif	  //CFG_TASK_WAITTING_EN
   1376          
   1377              /* All no,so WAITING state was set by CoSuspendTask()                     */
   1378              OsSchedLock();                      /* Lock schedule                      */
   1379          	TASK_SEQ(ptcb); InsertToTCBRdyList(ptcb);           /* Insert the task into the READY list*/
   1380              OsSchedUnlock();                    /* Unlock schedule                    */
   1381              return E_OK;                        /* return OK                          */
   1382          }
   1383          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  AssignTCB
              8 -> OsSchedUnlock
       16  CoAwakeTask
             16 -> InsertToTCBRdyList
             16 -> OsSchedUnlock
       16  CoDelTask
             16 -> CoLeaveMutexSection
             16 -> OsSchedUnlock
             16 -> RemoveDelayList
             16 -> RemoveEventWaittingList
             16 -> RemoveFromTCBRdyList
             16 -> RemoveLinkNode
             16 -> RemoveMutexList
             16 -> assert_failed
        8  CoExitTask
              8 -> CoDelTask
        0  CoGetCurTaskID
        0  CoGetCurrentTaskId
        0  CoGetStackDepth
        0  CoGetTaskFunc
        0  CoGetTaskLine
        0  CoGetTaskScheduledCount
       32  CoSetPriority
             32 -> CoSetPriority
             32 -> EventTaskToWait
             32 -> InsertToTCBRdyList
             32 -> OsSchedUnlock
             32 -> RemoveEventWaittingList
             32 -> RemoveFromTCBRdyList
       16  CoSuspendTask
             16 -> OsSchedUnlock
             16 -> RemoveFromTCBRdyList
       16  CreateTCBList
             16 -> assert_failed
       48  CreateTask
             48 -> AssignTCB
             48 -> InitTaskContext
             48 -> InsertToTCBRdyList
             48 -> OsSchedUnlock
       24  InsertToTCBRdyList
             24 -> assert_failed
        8  RemoveFromTCBRdyList
              8 -> assert_failed
       24  Schedule
             24 -> CoStkOverflowHook
             24 -> InsertToTCBRdyList
             24 -> RemoveFromTCBRdyList
             24 -> SwitchContext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     100  ?<Constant "C:\\Users\\User\\Documen...">
       8  ?<Constant "None">
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      52  AssignTCB
     104  CoAwakeTask
     200  CoDelTask
      14  CoExitTask
       8  CoGetCurTaskID
       8  CoGetCurrentTaskId
      28  CoGetStackDepth
      18  CoGetTaskFunc
      18  CoGetTaskLine
      18  CoGetTaskScheduledCount
     342  CoSetPriority
      92  CoSuspendTask
      72  CreateTCBList
     264  CreateTask
       4  FreeTCB
     210  InsertToTCBRdyList
       8  OSCheckTime
     118  RemoveFromTCBRdyList
     398  Schedule
       4  TCBNext
       4  TCBRdy
       4  TCBRunning
     748  TCBTbl
       1  currentTaskId
       4  func
       4  globl
     100  idle_stk
       2  line

 
   883 bytes in section .bss
   108 bytes in section .rodata
 2 044 bytes in section .text
 
 2 044 bytes of CODE  memory
   108 bytes of CONST memory
   883 bytes of DATA  memory

Errors: none
Warnings: none
