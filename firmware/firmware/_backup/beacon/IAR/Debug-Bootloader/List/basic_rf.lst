###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     20/Mar/2019  16:27:04 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon\App\basic_rf. #
#                    c                                                        #
#    Command line =  "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon\App\basic_rf. #
#                    c" -D BEACON_APP -D USE_STDPERIPH_DRIVER -D              #
#                    STM32F10X_CL -D COOS -D USE_MY_ASSERT -D BC_HW_REVJ -D   #
#                    _DEBUG -D BOOTLOADER -D EE_M24C02 -D TASKS_PROFILE -D    #
#                    BATTERY_CHECK -D CCA_EN_NO -D NEW_BEACON -D USE_TIM4 -D  #
#                    WDT_ENABLE -D OLD_CONFIG -D CIRCULAR_LOG -lcN            #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\Debug-Boo #
#                    tloader\List\" -o "C:\Users\User\Documents\Cortex_git\BL #
#                    KT-01.git\Source Code\BLKT-01                            #
#                    Beacon\Source\firmware\beacon\IAR\Debug-Bootloader\Obj\" #
#                     --no_cse --no_unroll --no_inline --no_code_motion       #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.gi #
#                    t\Source Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\ #
#                    ..\App\" -I "C:\Users\User\Documents\Cortex_git\BLKT-01. #
#                    git\Source Code\BLKT-01 Beacon\Source\firmware\beacon\IA #
#                    R\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"    #
#                    -I "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Sourc #
#                    e Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\..\..\c #
#                    ommon\STM32F10x_StdPeriph_Driver\inc\" -I                #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\..\..\com #
#                    mon\CoOS\kernel\" -I "C:\Users\User\Documents\Cortex_git #
#                    \BLKT-01.git\Source Code\BLKT-01                         #
#                    Beacon\Source\firmware\beacon\IAR\..\..\common\CoOS\port #
#                    able\" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.gi #
#                    t\Source Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\ #
#                    ..\..\..\common\" -I "C:\Users\User\Documents\Cortex_git #
#                    \BLKT-01.git\Source Code\BLKT-01                         #
#                    Beacon\Source\firmware\beacon\IAR\..\..\common\USB-Devic #
#                    e-CDC\" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.g #
#                    it\Source Code\BLKT-01 Beacon\Source\firmware\beacon\IAR #
#                    \..\..\common\" -I "C:\Users\User\Documents\Cortex_git\B #
#                    LKT-01.git\Source Code\BLKT-01                           #
#                    Beacon\Source\firmware\beacon\IAR\" -On                  #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\Debug-Boo #
#                    tloader\List\basic_rf.lst                                #
#    Object file  =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon\IAR\Debug-Boo #
#                    tloader\Obj\basic_rf.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source Code\BLKT-01 Beacon\Source\firmware\beacon\App\basic_rf.c
      1          /********************  All title and rights are owned by  *********************
      2          *******  the CAST Group of Companies Inc. or licensors thereto. ***************
      3          *******************************************************************************
      4          * File Name          : basic_rf.c
      5          * Author             : ?
      6          * Version            : V1.0
      7          * Date               : 6/2/2011
      8          * Description        : Basic RF library
      9          *******************************************************************************/
     10          
     11          /*
     12              FRAME FORMATS:
     13              Data packets (without security):
     14              [Preambles (4)][SFD (1)][Length (1)][Frame control field (2)]
     15              [Sequence number (1)][PAN ID (2)][Dest. address (2)][Source address (2)]
     16              [Payload (Length - 2+1+2+2+2)][Frame check sequence (2)]
     17          */
     18          
     19          /* INCLUDES ------------------------------------------------------------------*/
     20          
     21          #include "hardware.h"
     22          #include "basic_rf.h"
     23          #include "radio.h"
     24          #include "radio_defs.h"
     25          #include "imu_defs.h"
     26          
     27          #include "stm32f10x_gpio.h"
     28          #include "stm32f10x_dma.h"
     29          #include "stm32f10x_exti.h"
     30          #include "tasks.h"
     31          #include <stdio.h>
     32          #include <string.h>
     33          #include <stdint.h>
     34          #include "config.h"
     35          
     36          #include "CoOS.h"
     37          
     38          /* PRIVATE TYPEDEF -----------------------------------------------------------*/
     39          
     40          // Basic RF packet header (IEEE 802.15.4)
     41          typedef struct {
     42              uint8_t     frameLength;    // PHR
     43              uint8_t     fcf0;           // MHR: Frame Control Field LSB
     44              uint8_t     fcf1;           // MHR: Frame Control Field MSB
     45              uint8_t     seqNumber;      // MHR
     46              uint16_t    panId;          // MHR
     47              uint16_t    destAddr;       // MHR
     48              uint16_t    srcAddr;        // MHR
     49          } txPktHdr_t;
     50          
     51          typedef struct {
     52              uint16_t    myAddr;
     53              uint16_t    myPanId;
     54              uint8_t     channel;
     55          } radioConfig_t;
     56          
     57          typedef struct {
     58              uint8_t reg;
     59              uint8_t val;
     60          } regVal_t;
     61          
     62          const uint8_t TxAmpValues[9]={0x03,0x2C,0x88,0x81,0x32,0x13,0xAB,0xF2,0xF7};
     63          
     64          const uint8_t RF_SPI_INIT_STATE = 0xFF;                 // Can start an new RF_SPI operation from this state only
     65          const uint8_t RF_SPI_UPLOAD_ONLY_STATE = 0x00;          // Upload only. Does not care download content. For upload frame to CC2520
     66          const uint8_t RF_SPI_RX1_UPLOADCMD_STATE = 0x40;        // RX frame step 1:  upload command RXBUF
     67          const uint8_t RF_SPI_RX2_DOWNLOAD_HEADER_STATE = 0x20;  // RX frame step 2:  download frame header
     68          const uint8_t RF_SPI_RX3_DOWNLOAD_BODY_STATE = 0x10;    // RX frame step 3:  download frame body
     69          
     70          // these are not verified yet
     71          const uint8_t RF_SPI_CCA_CMD_STATE = 0x08;       // CCA upload read register FSMSTAT1 command
     72          const uint8_t RF_SPI_STXONCCA_CMD_STATE = 0x04;
     73          extern uint32_t sec;
     74          
     75          /* PRIVATE DEFINES -----------------------------------------------------------*/
     76          
     77          // Frame Control Field
     78          #define BASIC_RF_FCF_DATA               0x8841
     79          #define BASIC_RF_FCF_BEACON             0x8040
     80          
     81          // FrameLength(1)
     82          #define PHR_SIZE                        1
     83          
     84          /* IEEE 802.15.4 (2.4 GHz logical channels) */
     85          #define MIN_CHANNEL                     11 // 2405 MHz
     86          #define CHANNEL_SPACING                 5  // 5 MHz
     87          
     88          /* CC2590 LNA Gain */
     89          #define CC2590_HGM                      CC2520_GPIO_LOW
     90          //#define CC2590_HGM                      CC2520_GPIO_HIGH
     91          
     92          /* PRIVATE MACROS ------------------------------------------------------------*/
     93          
     94          /* EXTERN VARIABLES ----------------------------------------------------------*/
     95          extern volatile uint16_t tasksWDT;
     96          extern OS_EventID semRFRxFrames;
     97          extern uint32_t random;
     98          extern uint8_t IMUPresent;
     99          extern OS_FlagID flagIMUNewData;
    100          /* PRIVATE VARIABLES ---------------------------------------------------------*/
    101          static radioConfig_t    radioConfig;
    102          static rxPkt_t          rxPktCopy;
    103          // INS_SFLUSHTX(1 Byte) + INS_STXON(1 Byte) + 2*INS_SFLUSHRX(1 Byte) + INS_TXBUF(1 Byte) + PHR(1 Byte)
    104          static uint8_t          txBuf[FRAME_LENGTH_MAX - MFR_SIZE + 6];
    105          
    106          static regVal_t         regVal[] = {
    107              CC2520_CCACTRL0,    0xF8,               // Table21 (Required Updates)
    108              CC2520_MDMCTRL0,    0x85,               // Table21 (Required Updates)
    109              CC2520_MDMCTRL1,    0x14,               // Table21 (Required Updates)
    110              CC2520_RXCTRL,      0x3F,               // Table21 (Required Updates)
    111              CC2520_FSCTRL,      0x5A,               // Table21 (Required Updates)
    112              CC2520_FSCAL1,      0x2B,               // Table21 (Required Updates)
    113              CC2520_ADCTEST0,    0x10,               // Table21 (Required Updates)
    114              CC2520_ADCTEST1,    0x0E,               // Table21 (Required Updates)
    115              CC2520_ADCTEST2,    0x03,               // Table21 (Required Updates)
    116          
    117          #ifdef INCLUDE_PA
    118              CC2520_TXPOWER,     0x32,               // Max TX output power
    119          
    120              CC2520_AGCCTRL1,    0x16,
    121              CC2520_TXCTRL,      0xC1,
    122          #else
    123              CC2520_TXPOWER,     0xF7,               // Max TX output power
    124              CC2520_AGCCTRL1,    0x11,               // Table21 (Required Updates)
    125          #endif
    126          
    127          #ifdef INCLUDE_PA
    128            #ifdef OLIMEX
    129              CC2520_GPIOCTRL3,   CC2590_HGM,         // CC2590 HGM
    130              CC2520_GPIOCTRL4,   0x46,               // EN set to lna_pd[1] inverted
    131              CC2520_GPIOCTRL5,   0x47,               // PAEN set to pa_pd inverted
    132              CC2520_GPIOPOLARITY,0x0F,               // Invert GPIO4 and GPIO5
    133            #else                                     // if Timekeeper and Beacon
    134              CC2520_GPIOCTRL3,   0x47,               // CC2590 HGM low gain mode for startup
    135              CC2520_GPIOCTRL4,   0x46,               // EN set to on for rx
    136              CC2520_GPIOCTRL5,   CC2590_HGM,         // GPIO5 to HGM pin
    137              CC2520_GPIOPOLARITY,0x27,               // Invert GPIO4 and GPIO5
    138            #endif /* OLIMEX */
    139          #endif /* INCLUDE_PA */
    140          
    141              CC2520_FRMCTRL0,    0x40,               // APPEND_DATA_MODE=0, AUTOCRC=1
    142              CC2520_EXTCLOCK,    0x00,
    143          
    144              CC2520_EXCFLAG0,    0x00,               // Clear any Exceptions
    145              CC2520_EXCFLAG1,    0x00,               // Clear any Exceptions
    146              CC2520_EXCFLAG2,    0x00,               // Clear any Exceptions
    147          
    148              // outputs TX exception in channel A to 2520 GPIO 2 (TP37)
    149              CC2520_GPIOCTRL2, 0x21,
    150              CC2520_EXCMASKA0, CC2520_EXC0_TX_UNDERFLOW_BM | CC2520_EXC0_TX_OVERFLOW_BM,
    151              CC2520_EXCMASKA1, 0x00,
    152              CC2520_EXCMASKA2, 0x00,     // for debugging: CC2520_EXC2_MEMADDR_ERROR_BM | CC2520_EXC2_USAGE_ERROR_BM | CC2520_EXC2_OPERAND_ERROR_BM | CC2520_EXC2_SPI_ERROR_BM
    153          
    154              // outputs RX exception in channel B to GPIO5 (TP11)
    155              CC2520_GPIOCTRL5, 0x22,
    156              CC2520_EXCMASKB0, /*CC2520_EXC0_RX_UNDERFLOW_BM |*/ CC2520_EXC0_RX_OVERFLOW_BM,
    157              CC2520_EXCMASKB1, 0x00,
    158              CC2520_EXCMASKB2, 0x00,     // for debugging: CC2520_EXC2_MEMADDR_ERROR_BM | CC2520_EXC2_USAGE_ERROR_BM | CC2520_EXC2_OPERAND_ERROR_BM | CC2520_EXC2_SPI_ERROR_BM
    159          
    160              CC2520_FRMFILT1, 0x08,      //accepts only beacons
    161              // Terminate array
    162              0, 0x00
    163          };
    164          
    165          static regVal_t         regVal_IMU[] = {
    166              IMU_USER_CTRL,	    	0x78,				//disable I2C for SPI communication              
    167              IMU_PWR_MGMT_1, 		0x01,               //set auto select best clock source  
    168              IMU_PWR_MGMT_2,   		(0x38|0x07),		//disable both accelerometer and gyrometer        
    169              IMU_PWR_MGMT_2,     	(0x00|0x00),		//enable accelerometer, enable gyrometer
    170          
    171          	IMU_REG_BANK_SEL,		BANK2,
    172          	IMU_GYRO_CONFIG_1,		(0x00|0x29),		//gyro rate 250, gyro lpf 17hz
    173          	IMU_GYRO_SMPLRT_DIV,	0x13,				//set gyroscope ODR to 190Hz (same val as REVH)
    174          	
    175          	IMU_ACCEL_CONFIG,		(0x00|0x11),		//accel rate 2g, accel lpf 136hz: 
    176          	IMU_ACCEL_SMPLRT_DIV_1, 0x00,
    177          	IMU_ACCEL_SMPLRT_DIV_2, 0x26, 				//set acceleration ODR to 190Hz 
    178          	
    179          	IMU_REG_BANK_SEL,		BANK0,
    180          	IMU_ENABLE_1,			0x01,				//set raw data ready interrupt.
    181              0xFF, 0x0									// Terminate array
    182          };
    183          /* PUBLIC VARIABLES ----------------------------------------------------------*/
    184          
    185          /* --- FOR ISR-USE ONLY --- */
    186          volatile uint8_t spiTxRxByteCount = 0;
    187          volatile uint8_t spiTxRxByteState = 0xFF;   // RF_SPI_INIT_STATE;
    188          
    189          uint32_t            rxErrors;
    190          uint8_t*            pSpiTxBuf;
    191          uint8_t*            pSpiRxBuf;
    192          rxPkt_t             rxPkt;
    193          uint8_t             scratchBuf[FRAME_LENGTH_MAX + 5 + 20];      // 20 more bytes for sending FIFO clear command
    194          
    195          OS_FlagID           flagRadioTxDone = 0xFF;
    196          OS_FlagID           flagRadioTxAllow = 0xFF;
    197          OS_FlagID           flagRadioTxDoneUser = 0xFF;
    198          OS_EventID          semIMUAllow;
    199          OS_MutexID 			flagSPIIODone;       // For exclusive accessing radio SPI
    200          volatile uint16_t txDoneType = 1;        // 0: successful, 1: failed
    201          volatile uint16_t rxDoneType = 1;        // 0: successful, 1: failed
    202          volatile uint16_t rxFIFOError = 0;       // 0: no error, 1: with rror
    203          volatile uint16_t txFIFOError = 0;       // 0: no error, 1: with rror
    204          
    205          OS_FlagID flagSPIMachineDone = 0xFF;
    206          
    207          uint8_t         radio_off = 0;
    208          uint8_t         rxCount;
    209          uint8_t         cc2520_flags0;
    210          uint8_t         cc2520_flags1;
    211          uint8_t         cc2520_flags2;
    212          StatusType      txError;
    213          
    214          
    215          //Developing secondary SPI buffer primarily for IMU. Don't want to edit currently working functionality of radio
    216          volatile uint8_t spiIMUCount = 0;
    217          volatile uint8_t spiIMUByteState = IMU_SPI_INIT_STATE;
    218          	
    219          volatile uint8_t*		pSpiRxBuf_IMU;
    220          uint8_t*		pSpiTxBuf_IMU;
    221          
    222          uint8_t	IMU_TXBuffer[]={IMU_READBIT|IMU_ACCEL_XOUT_H,	//start address to read	
    223          								0,0,0,0,0,0,						//6 empty tx bytes to acquire 6 bytes of accel data	
    224          								0,0,0,0,0,0};					//6 empty tx bytes to acquire 6 bytes of gyro data	
    225          volatile uint8_t	IMU_RawData[12];
    226          
    227          //both radio and IMU 
    228          //SPI3_CS_TypeDef SPI3_CS;	//indicate chip selection on the SPI line.
    229          
    230          /* PRIVATE FUNCTION PROTOTYPES -----------------------------------------------*/
    231          
    232          //static void             RadioCheckException(void);
    233          static uint8_t          RadioBuildHdr(txPktHdr_t *pktHdr, uint16_t destAddr, uint8_t beacon, uint8_t payloadLength);
    234          
    235          void RadioWaitGrabSPI();
    236          void RadioReleaseSPI(void);
    237          void Enable_Osc(void);
    238          void Load_2520_Defaults(void);
    239          void RxTx_Setup(void);
    240          void RadioTxTest(void);
    241          
    242          /* PRIVATE FUNCTIONS ---------------------------------------------------------*/
    243          
    244          
    245          /*******************************************************************************
    246          * Description : Builds packet header according to IEEE 802.15.4 frame format
    247          * Input       :
    248          * Return      : size of header (in bytes)
    249          *******************************************************************************/
    250          static uint8_t RadioBuildHdr(txPktHdr_t *pktHdr, uint16_t destAddr, uint8_t beacon, uint8_t payloadLength) {
    251              static uint8_t txSeqNumber = 0;
    252          
    253              // 802.15.4 Frame Format with Short Addressing
    254              pktHdr->frameLength = payloadLength + MHR_SIZE + MFR_SIZE;
    255              if (beacon) {
    256                  pktHdr->fcf0 = LO_UINT16(BASIC_RF_FCF_BEACON);
    257                  pktHdr->fcf1 = HI_UINT16(BASIC_RF_FCF_BEACON);
    258              } else {
    259                  pktHdr->fcf0 = LO_UINT16(BASIC_RF_FCF_DATA);
    260                  pktHdr->fcf1 = HI_UINT16(BASIC_RF_FCF_DATA);
    261              }
    262              pktHdr->seqNumber = txSeqNumber++;
    263              pktHdr->panId = radioConfig.myPanId;
    264              pktHdr->destAddr = destAddr;
    265              pktHdr->srcAddr = radioConfig.myAddr;
    266          
    267              return (MHR_SIZE + PHR_SIZE);
    268          }
    269          
    270          
    271          /*******************************************************************************
    272          * Description : Tasks access SPI exclusively
    273          * Input       : -
    274          * Return      : -
    275          *******************************************************************************/
    276          void RadioIMU_WaitGrabSPI() {
    277            CoEnterMutexSection(flagSPIIODone);
    278          }
    279          
    280          /*******************************************************************************
    281          * Description : Release SPI for other tasks
    282          * Input       : -
    283          * Return      : -
    284          *******************************************************************************/
    285          void RadioIMU_ReleaseSPI(void) {
    286              CoLeaveMutexSection(flagSPIIODone);
    287          }
    288          
    289          /*******************************************************************************
    290          * Description : [API] Initialize and Configure Radio with default settings
    291          * Input       : -
    292          * Return      : -
    293          *******************************************************************************/
    294          void RadioInit(uint16_t panId, uint16_t shortAddr, uint8_t chan, uint8_t test) {
    295          #ifdef OLIMEX
    296              GPIO_WriteBit(GPIOD, GPIO_Pin_3, Bit_RESET);       // reset radio...
    297              HwWait(10);
    298              GPIO_WriteBit(GPIOD, GPIO_Pin_3, Bit_SET);
    299          #endif /* OLIMEX */
    300          #ifdef BC_HW_REVB
    301              Send_SPI_2byte(CC2520_INS_SRES, CC2520_INS_SRES);
    302              Send_SPI_2byte(CC2520_INS_SXOSCON, CC2520_INS_SNOP);
    303          #endif
    304          #ifdef BC_HW_REVC
    305                     HwGPOHigh(GPO_RF_EN);  // enable the pwer supply
    306                      HwWait(10);
    307                    HwGPOLow(GPO_2520_RST);  // take rest low
    308                      HwWait(10);
    309                    HwGPOHigh(GPO_2520_RST);  // rest high
    310          #endif
    311          #ifdef BC_HW_REVJ
    312          		HwGPOHigh(GPO_RF_EN);
    313          		HwWait(10);
    314          		HwGPOLow(GPO_2520_RST);
    315          		HwWait(10);
    316          		HwGPOHigh(GPO_2520_RST);
    317          #endif
    318              HwWait(10);  // wait a bit
    319              // see if the SPI bus comes ready
    320              assert( Send_SPI_byte(CC2520_INS_SNOP) & CC2520_STB_XOSC_STABLE_BM );
    321          
    322              flagSPIIODone     = CoCreateMutex();
    323              flagSPIMachineDone = CoCreateFlag(0, 0); // manual-reset, flag clear
    324          
    325          
    326              flagRadioTxDone      = CoCreateFlag(1, 1); // auto-reset, flag set
    327              flagRadioTxAllow     = CoCreateFlag(1, 0); // auto-reset, flag clear
    328              semIMUAllow         = CoCreateSem(1, 1, EVENT_SORT_TYPE_FIFO);
    329              Send_SPI_byte(CC2520_INS_SRFOFF);
    330          
    331              //Enable_Osc();   //Turn on the oscillator
    332              /* Load defalt Radio enable values   */
    333              Load_2520_Defaults();  // load the defaults
    334          
    335              // Initialize radioConfig struct
    336              radioConfig.myAddr = shortAddr;
    337              radioConfig.myPanId = panId;
    338              radioConfig.channel = chan;
    339          
    340              // Set channel
    341              TK_BK_REGWR8(CC2520_FREQCTRL, MIN_CHANNEL + (((radioConfig.channel)-MIN_CHANNEL) * CHANNEL_SPACING));
    342          
    343              TK_BK_REGWR8(CC2520_TXPOWER,TxAmpValues[config.TxLevel]);   // Max TX output power
    344          
    345          //      TK_BK_REGWR8(CC2520_TXPOWER,0xF7);
    346          
    347              // Write the short address and the PAN ID to the CC2520 RAM
    348              TK_BK_MEMWR16(CC2520_RAM_SHORTADDR, radioConfig.myAddr);
    349              TK_BK_MEMWR16(CC2520_RAM_PANID, radioConfig.myPanId);
    350          
    351              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // flush the rx fifo to clear any errors
    352              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // ... [CC2520 Bug#1]
    353          
    354              Send_SPI_byte(CC2520_INS_SFLUSHTX);     // flush the tx FIFO
    355              Send_SPI_byte(CC2520_INS_SFLUSHTX);     // again just in case an exception in previous SFLUSHTX
    356          
    357              // Set up 2520 GPIO 0 (TP35) as RX_FRM_DONE Output
    358              TK_BK_REGWR8(CC2520_GPIOCTRL0, CC2520_GPIO_RX_FRM_DONE);
    359          
    360              // Set up 2520 GPIO 1 (TP36) as TX_FRM_DONE Output
    361              TK_BK_REGWR8(CC2520_GPIOCTRL1, CC2520_GPIO_TX_FRM_DONE);
    362          
    363              // now enable RADIO_GPIO0 and RADIO_GPIO1 EXTIs
    364              HwRadioEXTIInit();
    365          
    366          #if 0  //check radio - does it work?
    367              TK_BK_MEMWR8(0x17F, 0xC1);
    368              rxCount = TK_BK_MEMRD8(0x17F);
    369          #endif
    370          
    371              // And...Turn on Rx ,mode as default
    372              Send_SPI_byte(CC2520_INS_SRXON);        // enable RX
    373              assert( Send_SPI_byte(CC2520_INS_SNOP) & CC2520_STB_RX_ACTIVE_BM  );
    374          }
    375          
    376          
    377          /*******************************************************************************
    378          * Description : SOXON  turns on internal oscilator for analog potion of chip
    379          * Input       :
    380          * Return      :
    381          *******************************************************************************/
    382          void Enable_Osc(void){
    383              Send_SPI_2byte(CC2520_INS_SXOSCON, CC2520_INS_SNOP); // turn on the oscillator
    384          
    385          
    386              HwWait(10);
    387              assert( Send_SPI_byte(CC2520_INS_SNOP) & CC2520_STB_XOSC_STABLE_BM );
    388          
    389          }
    390          /*******************************************************************************
    391          * Description : Loads 2520 registers
    392          * Input       :
    393          * Return      :
    394          *******************************************************************************/
    395          void Load_2520_Defaults(void){
    396              regVal_t *p = regVal;
    397              while (p->reg != 0) {
    398                  TK_BK_MEMWR8(p->reg, p->val);
    399                  p++;
    400              }
    401          
    402          }
    403          
    404          void RadioPrint2520Registers(uint8_t flag){
    405            regVal_t *p = regVal;
    406            uint8_t val;
    407            SAVE_POINT
    408            RadioIMU_WaitGrabSPI();
    409            SAVE_POINT
    410                while (p->reg != 0) {
    411                  val = TK_BK_MEMRD8(p->reg);
    412                  if(val != p->val)
    413                  {
    414                    TRACE("reg(0x%X) = 0x%X\n\r", p->reg, val);
    415                  }
    416                  p++;
    417                }
    418          
    419                {
    420                  val = TK_BK_MEMRD8(CC2520_EXCFLAG2);
    421                  TRACE("EXCFLAG2 = 0x%X\n\r", val);
    422                }
    423          
    424                {
    425                  val = TK_BK_MEMRD8(CC2520_FSMSTAT0);
    426                  TRACE("FSMSTAT0 = 0x%X\n\r", val);
    427                }
    428          
    429                {
    430                  val = TK_BK_MEMRD8(CC2520_FSMSTAT1);
    431                  TRACE("FSMSTAT1 = 0x%X\n\r", val);
    432                }
    433          
    434                RadioIMU_ReleaseSPI();
    435          
    436          }
    437          
    438          //CC2520 when raises RX_OVERFLOW (happens async) stops receiving until RX_OVERFLOW
    439          //is cleared
    440          // handle rx overflow & underflow errors
    441          void ProcessRXError() {
    442              assert(spiTxRxByteState == RF_SPI_INIT_STATE);      // State machine must be stopped first
    443              while (CoAcceptSem(semRFRxFrames) != E_SEM_EMPTY);        // remove all pending singnals
    444              rxErrors++;
    445              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // double flush ...
    446              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // ... [CC2520 Bug#1]
    447              Send_SPI_byte(CC2520_INS_ABORT);
    448              Send_SPI_byte(CC2520_INS_SRXON);
    449          
    450              TK_BK_REGWR8(CC2520_EXCFLAG0, 0);
    451              TK_BK_REGWR8(CC2520_EXCFLAG1, 0);
    452              TK_BK_REGWR8(CC2520_EXCFLAG2, 0);
    453              Send_SPI_byte(CC2520_INS_SRXON);
    454          
    455              HwWait(1);      // turn around time
    456          }
    457          
    458          
    459          
    460          /*******************************************************************************
    461          * Description : [API] wait and gets a new Received Packet
    462          *******************************************************************************/
    463          rxPkt_t* RadioRxPkt() {
    464          
    465             SAVE_POINT
    466              //read count and first byte;
    467              rxCount 		= TK_BK_REGRD8(CC2520_RXFIFOCNT);
    468              cc2520_flags0	= TK_BK_REGRD8(CC2520_EXCFLAG0);
    469              cc2520_flags1 	= TK_BK_REGRD8(CC2520_EXCFLAG1);
    470              cc2520_flags2 	= TK_BK_REGRD8(CC2520_EXCFLAG2);
    471          
    472          //    assert((cc2520_flags0 & (1 << CC2520_EXC_RX_OVERFLOW)) == 0);
    473              scratchBuf[0] 	= CC2520_INS_BCLR;    // reset RX_FRM_DONE signal/exception
    474              scratchBuf[1] 	= (CC2520_EXCFLAG1 << 3) | (CC2520_EXC_RX_FRM_DONE - 8);
    475              scratchBuf[2] 	= CC2520_INS_SNOP;    // pad to 16-bit word align
    476             // scratchBuf[3] = CC2520_INS_REGRD | CC2520_RXFIFOCNT;
    477             // scratchBuf[4] = CC2520_INS_SNOP;
    478              scratchBuf[3] 	= CC2520_INS_RXBUF;
    479              scratchBuf[4] 	= CC2520_INS_SNOP;
    480          
    481              spiTxRxByteCount = 5;  // go to RXBUF_Part2
    482              assert(spiTxRxByteState == RF_SPI_INIT_STATE);
    483              spiTxRxByteState = RF_SPI_RX1_UPLOADCMD_STATE;
    484          
    485              pSpiTxBuf = scratchBuf;
    486              pSpiRxBuf = (uint8_t*)&rxPkt;
    487          
    488              rxDoneType = 1;     // Assuming not successful State Machine will change it to 0 if successful
    489              CoClearFlag(flagSPIMachineDone);        // Must set before enabling SPI IO as SPI might happen at once (rear but possible)
    490              // roll state machine
    491          	//CS_SPI3 = RADIO_CS;
    492              HwSPISSAssert(SPI_RADIO);
    493              SPI_I2S_ITConfig(SPI_RADIO_IMU_SPI, SPI_I2S_IT_RXNE, ENABLE);
    494              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, *pSpiTxBuf++);
    495          
    496              CoWaitForSingleFlag(flagSPIMachineDone, 0);
    497              SAVE_POINT
    498              if (rxDoneType == 1) {      //overflow or underflow, which can stop SPI actions
    499                if (rxCount) {
    500                  //TODO - should I flash? Sets rxFIFOError to flash
    501                  TRACE("RX error rxCount=%d\n\r", rxCount);
    502                } // else false IRQ - ignore
    503                  return NULL;
    504              }
    505          
    506              rxPkt.payloadSize = rxPkt.frameLength - MHR_SIZE - MFR_SIZE;
    507              rxPkt.rssi = rxPkt.payload[rxPkt.payloadSize];
    508          
    509              // printf("*RSSI*: %x \n\r",rxPkt.rssi);
    510              // check if received CRC good
    511              rxPkt.lqi = rxPkt.payload[rxPkt.payloadSize + 1];
    512              if (radio_off) {
    513                return NULL;
    514              }
    515              if (rxPkt.lqi & 0x80) {
    516                  rxPkt.lqi &= 0x7F;
    517                  random =  RadioGetRandom();
    518                  if (config.flags & FLAG_TRACE_BEACON) {
    519                    TRACE("OK srcAddr=0x%04X panId=%d rxCount=%d sec=%d flags=0x%02X\n\r",
    520                        rxPkt.srcAddr, rxPkt.panId, rxCount, sec, cc2520_flags0);
    521                  }
    522                  //while(rxPkt.destAddr != 0xFFFF || rxPkt.srcAddr != 0xABCD);
    523              } else {
    524                if ( config.flags & FLAG_TRACE_CRC) {
    525                  TRACE("Bad CRC. Abort rxCount=%d sec=%d.%d flags=0x%02X\n\r", rxCount, sec, TIM1->CNT, cc2520_flags0);
    526                }
    527                return NULL;    // bad CRC => reject packet
    528              }
    529          
    530              // TODO!!! post to receive task; or should not happen if the first packet is not finished processing yet
    531              // give user a copy of receive packet (avoid clobbering by next ISR-received pkt)
    532              memcpy((void*)&rxPktCopy, (void*)&rxPkt, sizeof(rxPkt_t));
    533              return &rxPktCopy;
    534          }
    535          
    536          uint8_t readCCA;
    537          uint32_t txErrors;
    538          uint32_t sem;
    539          StatusType semAllowPost;
    540          extern uint8_t semAllow;
    541          uint16_t txLine;
    542          
    543          /*******************************************************************************
    544          * Description : [API] Transmit a Packet Immediately
    545          * Input       : trigger => 0 = on GPIO2 rising-edge; 1 = right away
    546          * Return      : -
    547          *******************************************************************************/
    548          void RadioTxPkt(uint16_t dstAddr, uint8_t beacon, uint8_t payloadSize, uint8_t *payload, uint8_t trigger) {
    549          
    550            SAVE_POINT
    551            txLine = __LINE__;
    552            if (radio_off) {
    553              // radio off
    554              return;
    555            }
    556            SAVE_POINT
    557            txLine = __LINE__;
    558              if (txFIFOError) {          // TODO!!! Question: when SPI uploading a frame a TX-FIFO takes place, will the behaviour get affected???  Now assuming No
    559                  txFIFOError = 0;
    560                  assert(spiTxRxByteState == RF_SPI_INIT_STATE);      // State machine must be stopped first
    561                  // Clear TX-FIFO error
    562                  Send_SPI_byte(CC2520_INS_SFLUSHTX);
    563                  Send_SPI_byte(CC2520_INS_SFLUSHTX);
    564          
    565                  TK_BK_REGWR8(CC2520_EXCFLAG0, 0);
    566                  TK_BK_REGWR8(CC2520_EXCFLAG1, 0);
    567                  TK_BK_REGWR8(CC2520_EXCFLAG2, 0);
    568                  txErrors++;
    569                  txLine = line = __LINE__;
    570                  HwWait(1);      // turn around time
    571                  return;
    572              }
    573          
    574              uint8_t hdrBytes;
    575          
    576              // flush Tx-FIFO to be safe
    577              txBuf[0] = CC2520_INS_SFLUSHTX;
    578              // insert CC2520 STXON, or not
    579              if (trigger)
    580              {
    581          #ifdef CCA_EN
    582                  txBuf[1] = CC2520_INS_STXONCCA; // 192us Tx Turnaround Time + 160us Preamble+SFD Tx Time
    583          #else
    584                  txBuf[1] = CC2520_INS_STXON; // [[DEBUG]]
    585          #endif
    586              }
    587              else
    588              {
    589                  txBuf[1] = CC2520_INS_SNOP;
    590              }
    591              // double-flush Rx-FIFO [CC2520 Bug#1]
    592              txBuf[2] = CC2520_INS_SNOP;
    593              txBuf[3] = CC2520_INS_SNOP;
    594              // insert TXBUF instruction to write data to Tx-FIFO
    595              txBuf[4] = CC2520_INS_TXBUF;
    596              // create the packet header (PHR+MHR) in the transmit buffer
    597              hdrBytes = RadioBuildHdr((txPktHdr_t*)(txBuf + 5), dstAddr, beacon, payloadSize);
    598              // copy over the payload (to avoid clobbering by user upon function exit)
    599              memcpy((void*)(txBuf + hdrBytes + 5), (void*)payload, payloadSize);
    600              txLine = line = __LINE__;
    601          
    602              // prev TX is done, so reset TX_FRM_DONE signal/exception
    603              TK_BK_REGWR8(CC2520_EXCFLAG0, ~CC2520_EXC0_TX_FRM_DONE_BM);
    604          
    605              // kick off ISR-driven SPI upload
    606              pSpiTxBuf = txBuf;
    607              pSpiRxBuf = scratchBuf;
    608          
    609              spiTxRxByteCount = 5 + hdrBytes + payloadSize;
    610              assert(spiTxRxByteState == RF_SPI_INIT_STATE);
    611              spiTxRxByteState = RF_SPI_UPLOAD_ONLY_STATE;
    612              readCCA = 2;
    613              txDoneType = 1;     // Assuming not successful. State Machine will change it to 0 if successful
    614              // Roll state machine when time slot arrives
    615          
    616              // TODO!!! change logic here:
    617              // wait till we are allowed to TX (i.e. not within TX Inhibit guard-band)
    618              txLine = line = __LINE__;
    619          
    620          #ifndef CCA_EN
    621              if (config.flags & FLAG_TRACE_USE_TIMESLOT) {
    622                  // imitate "event" synchornization. could be slower
    623                 // CoClearFlag(flagRadioTxAllow);
    624                if (CoAcceptSingleFlag(flagRadioTxAllow) == E_OK) {
    625                  // that means flag already was raised, no worry,
    626                  // the flag was cleared, will deliver in the next
    627                  // slot
    628                }
    629                SAVE_POINT
    630                txLine = __LINE__;
    631                CoWaitForSingleFlag(flagRadioTxAllow, 0);
    632                SAVE_POINT
    633                txLine = __LINE__;
    634          
    635              }
    636          #endif
    637          
    638              txLine = __LINE__;
    639          
    640              if (config.flags & FLAG_TRACE_TIMESLOT) {
    641                  // time slot debug
    642                  extern uint16_t txTimeSlot;
    643                  extern uint32_t secs;
    644                  uint16_t checkPoint = TIM_GetCounter(TIM2);
    645                  uint16_t slotDelta = 2100;
    646                  uint16_t slot2Offset = 60000 / 2 +  + txTimeSlot;
    647                  BOOL error = 0;
    648                  if (   (checkPoint >= txTimeSlot && checkPoint < txTimeSlot + slotDelta)
    649                      || (checkPoint >= slot2Offset && checkPoint < slot2Offset + slotDelta)
    650                          ) {
    651                              error = 0;
    652                          }
    653                  else {
    654                      error = 1;
    655                  }
    656                  TRACE("[%d-%d %d-%d]=>(%d.%d %c)-", txTimeSlot, txTimeSlot + slotDelta, slot2Offset, slot2Offset + slotDelta, secs, checkPoint, error == 0 ? ' ' : 'E');
    657              }
    658          
    659              CoClearFlag(flagSPIMachineDone);         // Must set before enabling SPI IO as SPI might happen at once (rear but possible)
    660              
    661          	//CS_SPI3 = RADIO_CS;
    662          	HwSPISSAssert(SPI_RADIO);
    663              SPI_I2S_ITConfig(SPI_RADIO_IMU_SPI, SPI_I2S_IT_RXNE, ENABLE);
    664              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, *pSpiTxBuf++);      // send first byte. Other will be handled by SPI3 interrupt
    665              txLine =  __LINE__;
    666              SAVE_POINT
    667              CoWaitForSingleFlag(flagSPIMachineDone, 0);
    668              SAVE_POINT
    669              txLine = __LINE__;
    670              if (txDoneType == 1) {      //overflow or underflow, which can stop SPI actions
    671                  TRACE("TX error\n\r");
    672              }
    673          
    674               // Upload to CC2520 does not mean that the frame has been sent out into the air
    675              if ((txError = CoWaitForSingleFlag(flagRadioTxDone, 50)) != E_OK) {  // TODO!!! verify if it can happen. If not, use infinit wait
    676                  //assert(0);      // should not happen. Happened when unluging ST-Link in debug mode
    677                SAVE_POINT
    678                txLine = __LINE__;
    679                TRACE("TX timout error =%d sec=%d.%d\n\r", txError, sec, TIM1->CNT);
    680                  // put radio back into known state
    681              //}
    682                  Send_SPI_byte(CC2520_INS_SFLUSHTX);
    683                  Send_SPI_byte(CC2520_INS_SFLUSHTX);
    684          
    685                  TK_BK_REGWR8(CC2520_EXCFLAG0, 0);
    686                  TK_BK_REGWR8(CC2520_EXCFLAG1, 0);
    687                  TK_BK_REGWR8(CC2520_EXCFLAG2, 0);
    688                  HwWait(1);      // turn around time
    689              }
    690              SAVE_POINT
    691              txLine = __LINE__;
    692              if (config.flags & FLAG_TRACE_TIMESLOT) {
    693                TRACE("radio done at %d.%d\r\n", secs, TIM2->CNT);
    694              }
    695          
    696              semAllowPost = CoPostSem(semIMUAllow);
    697              semAllow = 1;
    698              sem++;
    699              txLine = line = __LINE__;
    700          
    701          }
    702          
    703          /*******************************************************************************
    704          * Description : [API] Call this RIGHT AFTER asserting GPIO2 Trigger (STXON)
    705          *               [CC2520 Bug #1] => STXON may cause Rx-FIFO corruption
    706          *               !NOTE!: To avoid flushing a good RX packet in the Rx-FIFO, call
    707          *                       this function only right after STXON trigger
    708          * Input       : -
    709          * Return      : -
    710          *******************************************************************************/
    711          void RadioSTXONBugFlush(void) {
    712              SAVE_POINT
    713              RadioIMU_WaitGrabSPI();
    714              SAVE_POINT
    715              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // double flush ...
    716              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // ... [CC2520 Bug#1]
    717              RadioIMU_ReleaseSPI();
    718          }
    719          
    720          /*******************************************************************************
    721          * Description : [API] Sets new PAN ID and Short Source Address
    722          * Input       :
    723          * Return      : -
    724          *******************************************************************************/
    725          void RadioSetPanIdShortAddr(uint16_t panId, uint16_t shortAddr) {
    726              radioConfig.myPanId = panId;
    727              radioConfig.myAddr = shortAddr;
    728              // Write the short address and the PAN ID to the CC2520 RAM
    729              SAVE_POINT
    730              RadioIMU_WaitGrabSPI();
    731              SAVE_POINT
    732              TK_BK_MEMWR16(CC2520_RAM_PANID, panId);
    733              TK_BK_MEMWR16(CC2520_RAM_SHORTADDR, shortAddr);
    734              RadioIMU_ReleaseSPI();
    735          }
    736          
    737          /*******************************************************************************
    738          * Description : [API] Sets new RF Channel
    739          * Input       : chan => {11 - 26}
    740          * Return      : -
    741          *******************************************************************************/
    742          void RadioSetRFChan(uint8_t chan) {
    743              radioConfig.channel = chan;
    744              SAVE_POINT
    745              RadioIMU_WaitGrabSPI();
    746              SAVE_POINT
    747              Send_SPI_byte(CC2520_INS_SRFOFF);
    748              TK_BK_REGWR8(CC2520_FREQCTRL, MIN_CHANNEL + ((chan - MIN_CHANNEL) * CHANNEL_SPACING) );
    749              Send_SPI_byte(CC2520_INS_SRXON);
    750              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // double flush ...
    751              Send_SPI_byte(CC2520_INS_SFLUSHRX);     // ... [CC2520 Bug#1]
    752          
    753              TK_BK_REGWR8(CC2520_EXCFLAG0, 0);
    754              TK_BK_REGWR8(CC2520_EXCFLAG1, 0);
    755              TK_BK_REGWR8(CC2520_EXCFLAG2, 0);
    756              Send_SPI_byte(CC2520_INS_SRXON);
    757          
    758              RadioIMU_ReleaseSPI();
    759          }
    760          
    761          
    762          /*******************************************************************************
    763          * Description : [API] Sets new RF Tx Level
    764          * Input       : chan => {11 - 26}
    765          * Return      : -
    766          *******************************************************************************/
    767          void RadioSetRFLevel(uint8_t TxLev) {
    768          //    radioConfig.channel = chan;
    769          int8_t status;
    770           //NO RadioWaitGrabSPI??? Potential bug!
    771              SAVE_POINT
    772              RadioIMU_WaitGrabSPI();
    773              status = Send_SPI_byte(CC2520_INS_SNOP); // save curent status
    774              Send_SPI_byte(CC2520_INS_SRFOFF);
    775          	TK_BK_MEMWR8(CC2520_TXPOWER, TxAmpValues[TxLev]);
    776              Send_SPI_byte(CC2520_INS_SNOP);
    777              Send_SPI_byte(CC2520_INS_SNOP);
    778              if( status & CC2520_STB_TX_ACTIVE_BM){
    779                  Send_SPI_byte(CC2520_INS_STXON);  // turn on the radio
    780              }else{
    781                  Send_SPI_byte(CC2520_INS_SRXON);
    782                  Send_SPI_byte(CC2520_INS_SFLUSHRX);     // double flush ...
    783                  Send_SPI_byte(CC2520_INS_SFLUSHRX);
    784              }
    785              HwWait(10);
    786          	RadioIMU_WaitGrabSPI();
    787          }
    788          /*******************************************************************************
    789          * Description : [API] Gets RF Tx Level from 2520 X Level register
    790          * Input       :
    791          * Return      : Level
    792          *******************************************************************************/
    793          uint8_t RadioGetFLevel(void){
    794          uint8_t tx_power;
    795          
    796                SAVE_POINT
    797                RadioIMU_WaitGrabSPI();
    798                SAVE_POINT
    799                tx_power= TK_BK_REGRD8(CC2520_TXPOWER);
    800                RadioIMU_ReleaseSPI();
    801                return tx_power;
    802          }
    803          
    804          /*******************************************************************************
    805          * Description : [API] sets 2520 radio GPIO 0 as analog temperature out
    806          * Input       :
    807          * Return      :
    808          *******************************************************************************/
    809          
    810          /*******************************************************************************
    811          * Description : [API] REVJ. Sets up the IMU to default settings
    812          * Input       :
    813          * Return      :
    814          *******************************************************************************/
    815          void IMUInit(void){	
    816          	const uint8_t whoami = 0xEA;
    817              regVal_t *p = regVal_IMU;
    818          
    819              IMU_SelectBank(BANK0);
    820          	if(IMU_ReadOneByte(IMU_WHO_AM_I, 0x01)!=whoami){
    821          		IMUPresent=0;
    822          		assert(0);
    823          	}
    824          	else IMUPresent=1;
    825          	
    826          	while (p->reg != 0xFF) {
    827                  IMU_WriteOneByte(p->reg, p->val);
    828                  p++;
    829              }
    830          	
    831          	
    832          	//setup external gpio interrupts if required on the stm.
    833          	HwIMUEXTIInit();
    834          }
    835          
    836          /*******************************************************************************
    837          * Description : [API] REVJ. Sets up IMU_TX buffer to gather IMU raw data.
    838          * Input       :
    839          * Return      :
    840          *******************************************************************************/
    841          void IMUProcess(void){
    842          	pSpiRxBuf_IMU = IMU_RawData;
    843          	pSpiTxBuf_IMU = IMU_TXBuffer;
    844          	spiIMUCount = 12;
    845          	spiIMUByteState = IMU_SPI_INIT_STATE;
    846          	
    847          	SAVE_POINT
    848          	//CS_SPI3 = IMU_CS;
    849          	HwSPISSAssert(SPI_IMU);
    850          	SAVE_POINT
    851          	//I want to send: address read at address 0x33 (1 byte) + 6 bytes to ready gyro data (uint16_t) x,y,z.
    852          	SPI_I2S_ITConfig(SPI_RADIO_IMU_SPI, SPI_I2S_IT_RXNE, ENABLE);
    853              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, *pSpiTxBuf_IMU++);
    854          	
    855          	SAVE_POINT	
    856          	CoWaitForSingleFlag(flagIMUNewData, 0);
    857          	SAVE_POINT	
    858          	//HwSPISSDeAssert(SPI_IMU); 		//Deassert within ISR when received all data.
    859          }
    860          /******************* (C) COPYRIGHT 2011 NaturalPoint, Inc. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  Enable_Osc
              8 -> HwWait
              8 -> Send_SPI_2byte
              8 -> Send_SPI_byte
              8 -> assert_failed
       16  IMUInit
             16 -> HwIMUEXTIInit
             16 -> IMU_ReadOneByte
             16 -> IMU_SelectBank
             16 -> IMU_WriteOneByte
             16 -> assert_failed
        8  IMUProcess
              8 -> CoWaitForSingleFlag
              8 -> HwSPISSAssert
              8 -> SPI_I2S_ITConfig
              8 -> SPI_I2S_SendData
        8  Load_2520_Defaults
              8 -> TK_BK_MEMWR8
        8  ProcessRXError
              8 -> CoAcceptSem
              8 -> HwWait
              8 -> Send_SPI_byte
              8 -> TK_BK_REGWR8
              8 -> assert_failed
        8  RadioBuildHdr
        8  RadioGetFLevel
              8 -> RadioIMU_ReleaseSPI
              8 -> RadioIMU_WaitGrabSPI
              8 -> TK_BK_REGRD8
        8  RadioIMU_ReleaseSPI
              8 -> CoLeaveMutexSection
        8  RadioIMU_WaitGrabSPI
              8 -> CoEnterMutexSection
       24  RadioInit
             24 -> CoCreateFlag
             24 -> CoCreateMutex
             24 -> CoCreateSem
             24 -> HwGPOHigh
             24 -> HwGPOLow
             24 -> HwRadioEXTIInit
             24 -> HwWait
             24 -> Load_2520_Defaults
             24 -> Send_SPI_byte
             24 -> TK_BK_MEMWR16
             24 -> TK_BK_REGWR8
             24 -> assert_failed
       16  RadioPrint2520Registers
             16 -> RadioIMU_ReleaseSPI
             16 -> RadioIMU_WaitGrabSPI
             16 -> TK_BK_MEMRD8
             16 -> TRACE
       16  RadioRxPkt
             16 -> CoClearFlag
             16 -> CoWaitForSingleFlag
             16 -> HwSPISSAssert
             16 -> RadioGetRandom
             16 -> SPI_I2S_ITConfig
             16 -> SPI_I2S_SendData
             16 -> TK_BK_REGRD8
             16 -> TRACE
             16 -> assert_failed
             16 -> memcpy
        8  RadioSTXONBugFlush
              8 -> RadioIMU_ReleaseSPI
              8 -> RadioIMU_WaitGrabSPI
              8 -> Send_SPI_byte
       16  RadioSetPanIdShortAddr
             16 -> RadioIMU_ReleaseSPI
             16 -> RadioIMU_WaitGrabSPI
             16 -> TK_BK_MEMWR16
        8  RadioSetRFChan
              8 -> RadioIMU_ReleaseSPI
              8 -> RadioIMU_WaitGrabSPI
              8 -> Send_SPI_byte
              8 -> TK_BK_REGWR8
       16  RadioSetRFLevel
             16 -> HwWait
             16 -> RadioIMU_WaitGrabSPI
             16 -> Send_SPI_byte
             16 -> TK_BK_MEMWR8
       64  RadioTxPkt
             64 -> CoAcceptSingleFlag
             64 -> CoClearFlag
             64 -> CoPostSem
             64 -> CoWaitForSingleFlag
             64 -> HwSPISSAssert
             64 -> HwWait
             64 -> RadioBuildHdr
             64 -> SPI_I2S_ITConfig
             64 -> SPI_I2S_SendData
             64 -> Send_SPI_byte
             64 -> TIM_GetCounter
             64 -> TK_BK_REGWR8
             64 -> TRACE
             64 -> assert_failed
             64 -> memcpy
       16  memcpy
             16 -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      52  ?<Constant "Bad CRC. Abort rxCoun...">
     112  ?<Constant "C:\\Users\\User\\Documen...">
      20  ?<Constant "EXCFLAG2 = 0x%X\n\r">
      20  ?<Constant "FSMSTAT0 = 0x%X\n\r">
      20  ?<Constant "FSMSTAT1 = 0x%X\n\r">
      60  ?<Constant "OK srcAddr=0x%04X pan...">
      24  ?<Constant "RX error rxCount=%d\n\r">
      12  ?<Constant "TX error\n\r">
      32  ?<Constant "TX timout error =%d s...">
      28  ?<Constant "[%d-%d %d-%d]=>(%d.%d...">
      24  ?<Constant "radio done at %d.%d\r\n">
      20  ?<Constant "reg(0x%X) = 0x%X\n\r">
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_34
       4  ??DataTable16_35
       4  ??DataTable16_36
       4  ??DataTable16_37
       4  ??DataTable16_38
       4  ??DataTable16_39
       4  ??DataTable16_4
       4  ??DataTable16_40
       4  ??DataTable16_41
       4  ??DataTable16_42
       4  ??DataTable16_43
       4  ??DataTable16_44
       4  ??DataTable16_45
       4  ??DataTable16_46
       4  ??DataTable16_47
       4  ??DataTable16_48
       4  ??DataTable16_49
       4  ??DataTable16_5
       4  ??DataTable16_50
       4  ??DataTable16_51
       4  ??DataTable16_52
       4  ??DataTable16_53
       4  ??DataTable16_54
       4  ??DataTable16_55
       4  ??DataTable16_56
       4  ??DataTable16_57
       4  ??DataTable16_58
       4  ??DataTable16_59
       4  ??DataTable16_6
       4  ??DataTable16_60
       4  ??DataTable16_61
       4  ??DataTable16_62
       4  ??DataTable16_63
       4  ??DataTable16_64
       4  ??DataTable16_65
       4  ??DataTable16_66
       4  ??DataTable16_67
       4  ??DataTable16_68
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      40  Enable_Osc
      74  IMUInit
     130  IMUProcess
      12  IMU_RawData
      16  IMU_TXBuffer
      28  Load_2520_Defaults
     120  ProcessRXError
       1  RF_SPI_CCA_CMD_STATE
       1  RF_SPI_INIT_STATE
       1  RF_SPI_RX1_UPLOADCMD_STATE
       1  RF_SPI_RX2_DOWNLOAD_HEADER_STATE
       1  RF_SPI_RX3_DOWNLOAD_BODY_STATE
       1  RF_SPI_STXONCCA_CMD_STATE
       1  RF_SPI_UPLOAD_ONLY_STATE
      80  RadioBuildHdr
      52  RadioGetFLevel
      14  RadioIMU_ReleaseSPI
      14  RadioIMU_WaitGrabSPI
     306  RadioInit
     160  RadioPrint2520Registers
     556  RadioRxPkt
      52  RadioSTXONBugFlush
      76  RadioSetPanIdShortAddr
     120  RadioSetRFChan
     102  RadioSetRFLevel
    1108  RadioTxPkt
      12  TxAmpValues
       1  cc2520_flags0
       1  cc2520_flags1
       1  cc2520_flags2
       1  flagRadioTxAllow
       1  flagRadioTxDone
       1  flagRadioTxDoneUser
       1  flagSPIIODone
       1  flagSPIMachineDone
      22  memcpy
       4  pSpiRxBuf
       4  pSpiRxBuf_IMU
       4  pSpiTxBuf
       4  pSpiTxBuf_IMU
       8  radioConfig
       1  radio_off
       1  readCCA
      64  regVal
      28  regVal_IMU
       1  rxCount
       2  rxDoneType
       4  rxErrors
       2  rxFIFOError
     148  rxPkt
     148  rxPktCopy
     152  scratchBuf
       4  sem
       1  semAllowPost
       1  semIMUAllow
       1  spiIMUByteState
       1  spiIMUCount
       1  spiTxRxByteCount
       1  spiTxRxByteState
     132  txBuf
       2  txDoneType
       1  txError
       4  txErrors
       2  txFIFOError
       2  txLine
       1  txSeqNumber
     152  -- Other

 
   648 bytes in section .bss
   117 bytes in section .data
   595 bytes in section .rodata
 3 366 bytes in section .text
 
 3 344 bytes of CODE  memory (+ 22 bytes shared)
   595 bytes of CONST memory
   765 bytes of DATA  memory

Errors: none
Warnings: 1
