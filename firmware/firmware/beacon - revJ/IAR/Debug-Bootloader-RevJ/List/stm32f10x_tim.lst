###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     29/Oct/2019  16:43:15 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_tim.c                        #
#    Command line =  "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_tim.c" -D BEACON_APP -D      #
#                    USE_STDPERIPH_DRIVER -D STM32F10X_CL -D COOS -D          #
#                    USE_MY_ASSERT -D _DEBUG -D BOOTLOADER -D EE_M24C02 -D    #
#                    TASKS_PROFILE -D BATTERY_CHECK -D CCA_EN_NO -D           #
#                    NEW_BEACON -D USE_TIM4 -D WDT_ENABLE -D OLD_CONFIG -D    #
#                    CIRCULAR_LOG -D BC_HW_REVJ -lcN                          #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\" -o                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\App\" -I "C:\Users\kmak\Documents\Cortex_Git #
#                    \BLKT-01\Source Code\BLKT-01                             #
#                    Beacon\Source\firmware\beacon -                          #
#                    revJ\IAR\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F1 #
#                    0x\" -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Sour #
#                    ce Code\BLKT-01 Beacon\Source\firmware\beacon -          #
#                    revJ\IAR\..\..\common\STM32F10x_StdPeriph_Driver\inc\"   #
#                    -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\kernel\" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\portable\" -I                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\..\common\" -I                            #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\USB-Device-CDC\" -I                #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\" -I "C:\Users\kmak\Documents\Cort #
#                    ex_Git\BLKT-01\Source Code\BLKT-01                       #
#                    Beacon\Source\firmware\beacon - revJ\IAR\" -On           #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\stm32f10x_tim.lst    #
#    Object file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\stm32f10x_tim.o       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_tim.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the TIM firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_tim.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup TIM 
     31            * @brief TIM driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup TIM_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup TIM_Private_Defines
     44            * @{
     45            */
     46          
     47          /* ---------------------- TIM registers bit mask ------------------------ */
     48          #define SMCR_ETR_Mask               ((uint16_t)0x00FF)
     49          #define CCMR_Offset                 ((uint16_t)0x0018)
     50          #define CCER_CCE_Set                ((uint16_t)0x0001)
     51          #define CCER_CCNE_Set               ((uint16_t)0x0004)
     52          
     53          /**
     54            * @}
     55            */
     56          
     57          /** @defgroup TIM_Private_Macros
     58            * @{
     59            */
     60          
     61          /**
     62            * @}
     63            */
     64          
     65          /** @defgroup TIM_Private_Variables
     66            * @{
     67            */
     68          
     69          /**
     70            * @}
     71            */
     72          
     73          /** @defgroup TIM_Private_FunctionPrototypes
     74            * @{
     75            */
     76          
     77          static void TI1_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     78              uint16_t TIM_ICFilter);
     79          static void TI2_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     80              uint16_t TIM_ICFilter);
     81          static void TI3_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     82              uint16_t TIM_ICFilter);
     83          static void TI4_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     84              uint16_t TIM_ICFilter);
     85          /**
     86            * @}
     87            */
     88          
     89          /** @defgroup TIM_Private_Macros
     90            * @{
     91            */
     92          
     93          /**
     94            * @}
     95            */
     96          
     97          /** @defgroup TIM_Private_Variables
     98            * @{
     99            */
    100          
    101          /**
    102            * @}
    103            */
    104          
    105          /** @defgroup TIM_Private_FunctionPrototypes
    106            * @{
    107            */
    108          
    109          /**
    110            * @}
    111            */
    112          
    113          /** @defgroup TIM_Private_Functions
    114            * @{
    115            */
    116          
    117          /**
    118            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    119            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    120            * @retval None
    121            */
    122          void TIM_DeInit(TIM_TypeDef *TIMx) {
    123              /* Check the parameters */
    124              assert_param(IS_TIM_ALL_PERIPH(TIMx));
    125          
    126              if (TIMx == TIM1) {
    127                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    128                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);
    129              } else if (TIMx == TIM2) {
    130                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    131                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    132              } else if (TIMx == TIM3) {
    133                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    134                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    135              } else if (TIMx == TIM4) {
    136                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    137                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    138              } else if (TIMx == TIM5) {
    139                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    140                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    141              } else if (TIMx == TIM6) {
    142                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    143                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    144              } else if (TIMx == TIM7) {
    145                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    146                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    147              } else if (TIMx == TIM8) {
    148                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    149                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
    150              } else if (TIMx == TIM9) {
    151                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    152                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);
    153              } else if (TIMx == TIM10) {
    154                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    155                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);
    156              } else if (TIMx == TIM11) {
    157                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    158                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);
    159              } else if (TIMx == TIM12) {
    160                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    161                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);
    162              } else if (TIMx == TIM13) {
    163                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    164                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);
    165              } else if (TIMx == TIM14) {
    166                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    167                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);
    168              } else if (TIMx == TIM15) {
    169                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
    170                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
    171              } else if (TIMx == TIM16) {
    172                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
    173                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
    174              } else {
    175                  if (TIMx == TIM17) {
    176                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
    177                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
    178                  }
    179              }
    180          }
    181          
    182          /**
    183            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    184            *         the specified parameters in the TIM_TimeBaseInitStruct.
    185            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    186            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    187            *         structure that contains the configuration information for the 
    188            *         specified TIM peripheral.
    189            * @retval None
    190            */
    191          void TIM_TimeBaseInit(TIM_TypeDef *TIMx, TIM_TimeBaseInitTypeDef *TIM_TimeBaseInitStruct) {
    192              uint16_t tmpcr1 = 0;
    193          
    194              /* Check the parameters */
    195              assert_param(IS_TIM_ALL_PERIPH(TIMx));
    196              assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    197              assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    198          
    199              tmpcr1 = TIMx->CR1;
    200          
    201              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) || (TIMx == TIM4)
    202                  || (TIMx == TIM5)) {
    203                  /* Select the Counter Mode */
    204                  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    205                  tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    206              }
    207          
    208              if ((TIMx != TIM6) && (TIMx != TIM7)) {
    209                  /* Set the clock division */
    210                  tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
    211                  tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    212              }
    213          
    214              TIMx->CR1 = tmpcr1;
    215          
    216              /* Set the Autoreload value */
    217              TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period;
    218          
    219              /* Set the Prescaler value */
    220              TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    221          
    222              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17)) {
    223                  /* Set the Repetition Counter value */
    224                  TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    225              }
    226          
    227              /* Generate an update event to reload the Prescaler and the Repetition counter
    228                 values immediately */
    229              TIMx->EGR = TIM_PSCReloadMode_Immediate;
    230          }
    231          
    232          /**
    233            * @brief  Initializes the TIMx Channel1 according to the specified
    234            *         parameters in the TIM_OCInitStruct.
    235            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
    236            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    237            *         that contains the configuration information for the specified TIM peripheral.
    238            * @retval None
    239            */
    240          void TIM_OC1Init(TIM_TypeDef *TIMx, TIM_OCInitTypeDef *TIM_OCInitStruct) {
    241              uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    242          
    243              /* Check the parameters */
    244              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    245              assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    246              assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    247              assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    248              /* Disable the Channel 1: Reset the CC1E Bit */
    249              TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
    250              /* Get the TIMx CCER register value */
    251              tmpccer = TIMx->CCER;
    252              /* Get the TIMx CR2 register value */
    253              tmpcr2 = TIMx->CR2;
    254          
    255              /* Get the TIMx CCMR1 register value */
    256              tmpccmrx = TIMx->CCMR1;
    257          
    258              /* Reset the Output Compare Mode Bits */
    259              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
    260              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
    261          
    262              /* Select the Output Compare Mode */
    263              tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    264          
    265              /* Reset the Output Polarity level */
    266              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
    267              /* Set the Output Compare Polarity */
    268              tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    269          
    270              /* Set the Output State */
    271              tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    272          
    273              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17)) {
    274                  assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    275                  assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    276                  assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    277                  assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    278          
    279                  /* Reset the Output N Polarity level */
    280                  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
    281                  /* Set the Output N Polarity */
    282                  tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    283          
    284                  /* Reset the Output N State */
    285                  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));
    286                  /* Set the Output N State */
    287                  tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    288          
    289                  /* Reset the Output Compare and Output Compare N IDLE State */
    290                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
    291                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
    292          
    293                  /* Set the Output Idle state */
    294                  tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    295                  /* Set the Output N Idle state */
    296                  tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    297              }
    298              /* Write to TIMx CR2 */
    299              TIMx->CR2 = tmpcr2;
    300          
    301              /* Write to TIMx CCMR1 */
    302              TIMx->CCMR1 = tmpccmrx;
    303          
    304              /* Set the Capture Compare Register value */
    305              TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    306          
    307              /* Write to TIMx CCER */
    308              TIMx->CCER = tmpccer;
    309          }
    310          
    311          /**
    312            * @brief  Initializes the TIMx Channel2 according to the specified
    313            *         parameters in the TIM_OCInitStruct.
    314            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
    315            *         the TIM peripheral.
    316            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    317            *         that contains the configuration information for the specified TIM peripheral.
    318            * @retval None
    319            */
    320          void TIM_OC2Init(TIM_TypeDef *TIMx, TIM_OCInitTypeDef *TIM_OCInitStruct) {
    321              uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    322          
    323              /* Check the parameters */
    324              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    325              assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    326              assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    327              assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    328              /* Disable the Channel 2: Reset the CC2E Bit */
    329              TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
    330          
    331              /* Get the TIMx CCER register value */
    332              tmpccer = TIMx->CCER;
    333              /* Get the TIMx CR2 register value */
    334              tmpcr2 = TIMx->CR2;
    335          
    336              /* Get the TIMx CCMR1 register value */
    337              tmpccmrx = TIMx->CCMR1;
    338          
    339              /* Reset the Output Compare mode and Capture/Compare selection Bits */
    340              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
    341              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
    342          
    343              /* Select the Output Compare Mode */
    344              tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    345          
    346              /* Reset the Output Polarity level */
    347              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
    348              /* Set the Output Compare Polarity */
    349              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    350          
    351              /* Set the Output State */
    352              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    353          
    354              if ((TIMx == TIM1) || (TIMx == TIM8)) {
    355                  assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    356                  assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    357                  assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    358                  assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    359          
    360                  /* Reset the Output N Polarity level */
    361                  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
    362                  /* Set the Output N Polarity */
    363                  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    364          
    365                  /* Reset the Output N State */
    366                  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));
    367                  /* Set the Output N State */
    368                  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    369          
    370                  /* Reset the Output Compare and Output Compare N IDLE State */
    371                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
    372                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
    373          
    374                  /* Set the Output Idle state */
    375                  tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    376                  /* Set the Output N Idle state */
    377                  tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    378              }
    379              /* Write to TIMx CR2 */
    380              TIMx->CR2 = tmpcr2;
    381          
    382              /* Write to TIMx CCMR1 */
    383              TIMx->CCMR1 = tmpccmrx;
    384          
    385              /* Set the Capture Compare Register value */
    386              TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    387          
    388              /* Write to TIMx CCER */
    389              TIMx->CCER = tmpccer;
    390          }
    391          
    392          /**
    393            * @brief  Initializes the TIMx Channel3 according to the specified
    394            *         parameters in the TIM_OCInitStruct.
    395            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    396            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    397            *         that contains the configuration information for the specified TIM peripheral.
    398            * @retval None
    399            */
    400          void TIM_OC3Init(TIM_TypeDef *TIMx, TIM_OCInitTypeDef *TIM_OCInitStruct) {
    401              uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    402          
    403              /* Check the parameters */
    404              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    405              assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    406              assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    407              assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    408              /* Disable the Channel 2: Reset the CC2E Bit */
    409              TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
    410          
    411              /* Get the TIMx CCER register value */
    412              tmpccer = TIMx->CCER;
    413              /* Get the TIMx CR2 register value */
    414              tmpcr2 = TIMx->CR2;
    415          
    416              /* Get the TIMx CCMR2 register value */
    417              tmpccmrx = TIMx->CCMR2;
    418          
    419              /* Reset the Output Compare mode and Capture/Compare selection Bits */
    420              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
    421              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));
    422              /* Select the Output Compare Mode */
    423              tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    424          
    425              /* Reset the Output Polarity level */
    426              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
    427              /* Set the Output Compare Polarity */
    428              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    429          
    430              /* Set the Output State */
    431              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    432          
    433              if ((TIMx == TIM1) || (TIMx == TIM8)) {
    434                  assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    435                  assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    436                  assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    437                  assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    438          
    439                  /* Reset the Output N Polarity level */
    440                  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
    441                  /* Set the Output N Polarity */
    442                  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    443                  /* Reset the Output N State */
    444                  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
    445          
    446                  /* Set the Output N State */
    447                  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    448                  /* Reset the Output Compare and Output Compare N IDLE State */
    449                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    450                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
    451                  /* Set the Output Idle state */
    452                  tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    453                  /* Set the Output N Idle state */
    454                  tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    455              }
    456              /* Write to TIMx CR2 */
    457              TIMx->CR2 = tmpcr2;
    458          
    459              /* Write to TIMx CCMR2 */
    460              TIMx->CCMR2 = tmpccmrx;
    461          
    462              /* Set the Capture Compare Register value */
    463              TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    464          
    465              /* Write to TIMx CCER */
    466              TIMx->CCER = tmpccer;
    467          }
    468          
    469          /**
    470            * @brief  Initializes the TIMx Channel4 according to the specified
    471            *         parameters in the TIM_OCInitStruct.
    472            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    473            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    474            *         that contains the configuration information for the specified TIM peripheral.
    475            * @retval None
    476            */
    477          void TIM_OC4Init(TIM_TypeDef *TIMx, TIM_OCInitTypeDef *TIM_OCInitStruct) {
    478              uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    479          
    480              /* Check the parameters */
    481              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    482              assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    483              assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    484              assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    485              /* Disable the Channel 2: Reset the CC4E Bit */
    486              TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
    487          
    488              /* Get the TIMx CCER register value */
    489              tmpccer = TIMx->CCER;
    490              /* Get the TIMx CR2 register value */
    491              tmpcr2 = TIMx->CR2;
    492          
    493              /* Get the TIMx CCMR2 register value */
    494              tmpccmrx = TIMx->CCMR2;
    495          
    496              /* Reset the Output Compare mode and Capture/Compare selection Bits */
    497              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
    498              tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
    499          
    500              /* Select the Output Compare Mode */
    501              tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    502          
    503              /* Reset the Output Polarity level */
    504              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
    505              /* Set the Output Compare Polarity */
    506              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    507          
    508              /* Set the Output State */
    509              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    510          
    511              if ((TIMx == TIM1) || (TIMx == TIM8)) {
    512                  assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    513                  /* Reset the Output Compare IDLE State */
    514                  tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
    515                  /* Set the Output Idle state */
    516                  tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    517              }
    518              /* Write to TIMx CR2 */
    519              TIMx->CR2 = tmpcr2;
    520          
    521              /* Write to TIMx CCMR2 */
    522              TIMx->CCMR2 = tmpccmrx;
    523          
    524              /* Set the Capture Compare Register value */
    525              TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    526          
    527              /* Write to TIMx CCER */
    528              TIMx->CCER = tmpccer;
    529          }
    530          
    531          /**
    532            * @brief  Initializes the TIM peripheral according to the specified
    533            *         parameters in the TIM_ICInitStruct.
    534            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
    535            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    536            *         that contains the configuration information for the specified TIM peripheral.
    537            * @retval None
    538            */
    539          void TIM_ICInit(TIM_TypeDef *TIMx, TIM_ICInitTypeDef *TIM_ICInitStruct) {
    540              /* Check the parameters */
    541              assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    542              assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    543              assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    544              assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    545          
    546              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) || (TIMx == TIM4)
    547                  || (TIMx == TIM5)) {
    548                  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    549              } else {
    550                  assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
    551              }
    552          
    553              if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1) {
    554                  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    555                  /* TI1 Configuration */
    556                  TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    557                      TIM_ICInitStruct->TIM_ICFilter);
    558                  /* Set the Input Capture Prescaler value */
    559                  TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    560              } else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2) {
    561                  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    562                  /* TI2 Configuration */
    563                  TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    564                      TIM_ICInitStruct->TIM_ICFilter);
    565                  /* Set the Input Capture Prescaler value */
    566                  TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    567              } else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3) {
    568                  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    569                  /* TI3 Configuration */
    570                  TI3_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    571                      TIM_ICInitStruct->TIM_ICFilter);
    572                  /* Set the Input Capture Prescaler value */
    573                  TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    574              } else {
    575                  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    576                  /* TI4 Configuration */
    577                  TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    578                      TIM_ICInitStruct->TIM_ICFilter);
    579                  /* Set the Input Capture Prescaler value */
    580                  TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    581              }
    582          }
    583          
    584          /**
    585            * @brief  Configures the TIM peripheral according to the specified
    586            *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
    587            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
    588            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    589            *         that contains the configuration information for the specified TIM peripheral.
    590            * @retval None
    591            */
    592          void TIM_PWMIConfig(TIM_TypeDef *TIMx, TIM_ICInitTypeDef *TIM_ICInitStruct) {
    593              uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
    594              uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
    595              /* Check the parameters */
    596              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    597              /* Select the Opposite Input Polarity */
    598              if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising) {
    599                  icoppositepolarity = TIM_ICPolarity_Falling;
    600              } else {
    601                  icoppositepolarity = TIM_ICPolarity_Rising;
    602              }
    603              /* Select the Opposite Input */
    604              if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI) {
    605                  icoppositeselection = TIM_ICSelection_IndirectTI;
    606              } else {
    607                  icoppositeselection = TIM_ICSelection_DirectTI;
    608              }
    609          
    610              if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1) {
    611                  /* TI1 Configuration */
    612                  TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    613                      TIM_ICInitStruct->TIM_ICFilter);
    614                  /* Set the Input Capture Prescaler value */
    615                  TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    616                  /* TI2 Configuration */
    617                  TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    618                  /* Set the Input Capture Prescaler value */
    619                  TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    620              } else {
    621                  /* TI2 Configuration */
    622                  TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    623                      TIM_ICInitStruct->TIM_ICFilter);
    624                  /* Set the Input Capture Prescaler value */
    625                  TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    626                  /* TI1 Configuration */
    627                  TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    628                  /* Set the Input Capture Prescaler value */
    629                  TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    630              }
    631          }
    632          
    633          /**
    634            * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
    635            *         the OSSR State and the AOE(automatic output enable).
    636            * @param  TIMx: where x can be  1 or 8 to select the TIM 
    637            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
    638            *         contains the BDTR Register configuration  information for the TIM peripheral.
    639            * @retval None
    640            */
    641          void TIM_BDTRConfig(TIM_TypeDef *TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct) {
    642              /* Check the parameters */
    643              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    644              assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    645              assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    646              assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    647              assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    648              assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    649              assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    650              /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    651                 the OSSI State, the dead time value and the Automatic Output Enable Bit */
    652              TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState
    653                  | TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime
    654                  | TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity
    655                  | TIM_BDTRInitStruct->TIM_AutomaticOutput;
    656          }
    657          
    658          /**
    659            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    660            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    661            *         structure which will be initialized.
    662            * @retval None
    663            */
    664          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef *TIM_TimeBaseInitStruct) {
    665              /* Set the default configuration */
    666              TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
    667              TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    668              TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    669              TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    670              TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    671          }
    672          
    673          /**
    674            * @brief  Fills each TIM_OCInitStruct member with its default value.
    675            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    676            *         be initialized.
    677            * @retval None
    678            */
    679          void TIM_OCStructInit(TIM_OCInitTypeDef *TIM_OCInitStruct) {
    680              /* Set the default configuration */
    681              TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    682              TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    683              TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    684              TIM_OCInitStruct->TIM_Pulse = 0x0000;
    685              TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    686              TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    687              TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    688              TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    689          }
    690          
    691          /**
    692            * @brief  Fills each TIM_ICInitStruct member with its default value.
    693            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
    694            *         be initialized.
    695            * @retval None
    696            */
    697          void TIM_ICStructInit(TIM_ICInitTypeDef *TIM_ICInitStruct) {
    698              /* Set the default configuration */
    699              TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
    700              TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
    701              TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
    702              TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
    703              TIM_ICInitStruct->TIM_ICFilter = 0x00;
    704          }
    705          
    706          /**
    707            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
    708            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
    709            *         will be initialized.
    710            * @retval None
    711            */
    712          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef *TIM_BDTRInitStruct) {
    713              /* Set the default configuration */
    714              TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
    715              TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
    716              TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
    717              TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
    718              TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
    719              TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
    720              TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
    721          }
    722          
    723          /**
    724            * @brief  Enables or disables the specified TIM peripheral.
    725            * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
    726            * @param  NewState: new state of the TIMx peripheral.
    727            *   This parameter can be: ENABLE or DISABLE.
    728            * @retval None
    729            */
    730          void TIM_Cmd(TIM_TypeDef *TIMx, FunctionalState NewState) {
    731              /* Check the parameters */
    732              assert_param(IS_TIM_ALL_PERIPH(TIMx));
    733              assert_param(IS_FUNCTIONAL_STATE(NewState));
    734          
    735              if (NewState != DISABLE) {
    736                  /* Enable the TIM Counter */
    737                  TIMx->CR1 |= TIM_CR1_CEN;
    738              } else {
    739                  /* Disable the TIM Counter */
    740                  TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
    741              }
    742          }
    743          
    744          /**
    745            * @brief  Enables or disables the TIM peripheral Main Outputs.
    746            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.
    747            * @param  NewState: new state of the TIM peripheral Main Outputs.
    748            *   This parameter can be: ENABLE or DISABLE.
    749            * @retval None
    750            */
    751          void TIM_CtrlPWMOutputs(TIM_TypeDef *TIMx, FunctionalState NewState) {
    752              /* Check the parameters */
    753              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    754              assert_param(IS_FUNCTIONAL_STATE(NewState));
    755          
    756              if (NewState != DISABLE) {
    757                  /* Enable the TIM Main Output */
    758                  TIMx->BDTR |= TIM_BDTR_MOE;
    759              } else {
    760                  /* Disable the TIM Main Output */
    761                  TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
    762              }
    763          }
    764          
    765          /**
    766            * @brief  Enables or disables the specified TIM interrupts.
    767            * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
    768            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
    769            *   This parameter can be any combination of the following values:
    770            *     @arg TIM_IT_Update: TIM update Interrupt source
    771            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    772            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    773            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    774            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    775            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
    776            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
    777            *     @arg TIM_IT_Break: TIM Break Interrupt source
    778            * @note 
    779            *   - TIM6 and TIM7 can only generate an update interrupt.
    780            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
    781            *      TIM_IT_CC2 or TIM_IT_Trigger. 
    782            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
    783            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
    784            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
    785            * @param  NewState: new state of the TIM interrupts.
    786            *   This parameter can be: ENABLE or DISABLE.
    787            * @retval None
    788            */
    789          void TIM_ITConfig(TIM_TypeDef *TIMx, uint16_t TIM_IT, FunctionalState NewState) {
    790              /* Check the parameters */
    791              assert_param(IS_TIM_ALL_PERIPH(TIMx));
    792              assert_param(IS_TIM_IT(TIM_IT));
    793              assert_param(IS_FUNCTIONAL_STATE(NewState));
    794          
    795              if (NewState != DISABLE) {
    796                  /* Enable the Interrupt sources */
    797                  TIMx->DIER |= TIM_IT;
    798              } else {
    799                  /* Disable the Interrupt sources */
    800                  TIMx->DIER &= (uint16_t) ~TIM_IT;
    801              }
    802          }
    803          
    804          /**
    805            * @brief  Configures the TIMx event to be generate by software.
    806            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    807            * @param  TIM_EventSource: specifies the event source.
    808            *   This parameter can be one or more of the following values:	   
    809            *     @arg TIM_EventSource_Update: Timer update Event source
    810            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    811            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    812            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    813            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    814            *     @arg TIM_EventSource_COM: Timer COM event source  
    815            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
    816            *     @arg TIM_EventSource_Break: Timer Break event source
    817            * @note 
    818            *   - TIM6 and TIM7 can only generate an update event. 
    819            *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
    820            * @retval None
    821            */
    822          void TIM_GenerateEvent(TIM_TypeDef *TIMx, uint16_t TIM_EventSource) {
    823              /* Check the parameters */
    824              assert_param(IS_TIM_ALL_PERIPH(TIMx));
    825              assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    826          
    827              /* Set the event sources */
    828              TIMx->EGR = TIM_EventSource;
    829          }
    830          
    831          /**
    832            * @brief  Configures the TIMx's DMA interface.
    833            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
    834            *   the TIM peripheral.
    835            * @param  TIM_DMABase: DMA Base address.
    836            *   This parameter can be one of the following values:
    837            *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    838            *          TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    839            *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    840            *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    841            *          TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    842            *          TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    843            *          TIM_DMABase_DCR.
    844            * @param  TIM_DMABurstLength: DMA Burst length.
    845            *   This parameter can be one value between:
    846            *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
    847            * @retval None
    848            */
    849          void TIM_DMAConfig(TIM_TypeDef *TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength) {
    850              /* Check the parameters */
    851              assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    852              assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
    853              assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    854              /* Set the DMA Base and the DMA Burst Length */
    855              TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
    856          }
    857          
    858          /**
    859            * @brief  Enables or disables the TIMx's DMA Requests.
    860            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17 
    861            *   to select the TIM peripheral. 
    862            * @param  TIM_DMASource: specifies the DMA Request sources.
    863            *   This parameter can be any combination of the following values:
    864            *     @arg TIM_DMA_Update: TIM update Interrupt source
    865            *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    866            *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    867            *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    868            *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    869            *     @arg TIM_DMA_COM: TIM Commutation DMA source
    870            *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
    871            * @param  NewState: new state of the DMA Request sources.
    872            *   This parameter can be: ENABLE or DISABLE.
    873            * @retval None
    874            */
    875          void TIM_DMACmd(TIM_TypeDef *TIMx, uint16_t TIM_DMASource, FunctionalState NewState) {
    876              /* Check the parameters */
    877              assert_param(IS_TIM_LIST9_PERIPH(TIMx));
    878              assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    879              assert_param(IS_FUNCTIONAL_STATE(NewState));
    880          
    881              if (NewState != DISABLE) {
    882                  /* Enable the DMA sources */
    883                  TIMx->DIER |= TIM_DMASource;
    884              } else {
    885                  /* Disable the DMA sources */
    886                  TIMx->DIER &= (uint16_t) ~TIM_DMASource;
    887              }
    888          }
    889          
    890          /**
    891            * @brief  Configures the TIMx internal Clock
    892            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
    893            *         to select the TIM peripheral.
    894            * @retval None
    895            */
    896          void TIM_InternalClockConfig(TIM_TypeDef *TIMx) {
    897              /* Check the parameters */
    898              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    899              /* Disable slave mode to clock the prescaler directly with the internal clock */
    900              TIMx->SMCR &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
    901          }
    902          
    903          /**
    904            * @brief  Configures the TIMx Internal Trigger as External Clock
    905            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
    906            * @param  TIM_ITRSource: Trigger source.
    907            *   This parameter can be one of the following values:
    908            * @param  TIM_TS_ITR0: Internal Trigger 0
    909            * @param  TIM_TS_ITR1: Internal Trigger 1
    910            * @param  TIM_TS_ITR2: Internal Trigger 2
    911            * @param  TIM_TS_ITR3: Internal Trigger 3
    912            * @retval None
    913            */
    914          void TIM_ITRxExternalClockConfig(TIM_TypeDef *TIMx, uint16_t TIM_InputTriggerSource) {
    915              /* Check the parameters */
    916              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    917              assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
    918              /* Select the Internal Trigger */
    919              TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
    920              /* Select the External clock mode1 */
    921              TIMx->SMCR |= TIM_SlaveMode_External1;
    922          }
    923          
    924          /**
    925            * @brief  Configures the TIMx Trigger as External Clock
    926            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
    927            * @param  TIM_TIxExternalCLKSource: Trigger source.
    928            *   This parameter can be one of the following values:
    929            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
    930            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
    931            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
    932            * @param  TIM_ICPolarity: specifies the TIx Polarity.
    933            *   This parameter can be one of the following values:
    934            *     @arg TIM_ICPolarity_Rising
    935            *     @arg TIM_ICPolarity_Falling
    936            * @param  ICFilter : specifies the filter value.
    937            *   This parameter must be a value between 0x0 and 0xF.
    938            * @retval None
    939            */
    940          void TIM_TIxExternalClockConfig(TIM_TypeDef *TIMx, uint16_t TIM_TIxExternalCLKSource,
    941              uint16_t TIM_ICPolarity, uint16_t ICFilter) {
    942              /* Check the parameters */
    943              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    944              assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
    945              assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
    946              assert_param(IS_TIM_IC_FILTER(ICFilter));
    947              /* Configure the Timer Input Clock Source */
    948              if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2) {
    949                  TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    950              } else {
    951                  TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    952              }
    953              /* Select the Trigger source */
    954              TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
    955              /* Select the External clock mode1 */
    956              TIMx->SMCR |= TIM_SlaveMode_External1;
    957          }
    958          
    959          /**
    960            * @brief  Configures the External clock Mode1
    961            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    962            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    963            *   This parameter can be one of the following values:
    964            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
    965            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
    966            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
    967            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
    968            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
    969            *   This parameter can be one of the following values:
    970            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
    971            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
    972            * @param  ExtTRGFilter: External Trigger Filter.
    973            *   This parameter must be a value between 0x00 and 0x0F
    974            * @retval None
    975            */
    976          void TIM_ETRClockMode1Config(TIM_TypeDef *TIMx, uint16_t TIM_ExtTRGPrescaler,
    977              uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter) {
    978              uint16_t tmpsmcr = 0;
    979              /* Check the parameters */
    980              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    981              assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    982              assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    983              assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
    984              /* Configure the ETR Clock source */
    985              TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    986          
    987              /* Get the TIMx SMCR register value */
    988              tmpsmcr = TIMx->SMCR;
    989              /* Reset the SMS Bits */
    990              tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
    991              /* Select the External clock mode1 */
    992              tmpsmcr |= TIM_SlaveMode_External1;
    993              /* Select the Trigger selection : ETRF */
    994              tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
    995              tmpsmcr |= TIM_TS_ETRF;
    996              /* Write to TIMx SMCR */
    997              TIMx->SMCR = tmpsmcr;
    998          }
    999          
   1000          /**
   1001            * @brief  Configures the External clock Mode2
   1002            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1003            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1004            *   This parameter can be one of the following values:
   1005            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1006            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1007            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1008            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1009            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1010            *   This parameter can be one of the following values:
   1011            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1012            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1013            * @param  ExtTRGFilter: External Trigger Filter.
   1014            *   This parameter must be a value between 0x00 and 0x0F
   1015            * @retval None
   1016            */
   1017          void TIM_ETRClockMode2Config(TIM_TypeDef *TIMx, uint16_t TIM_ExtTRGPrescaler,
   1018              uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter) {
   1019              /* Check the parameters */
   1020              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1021              assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1022              assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1023              assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1024              /* Configure the ETR Clock source */
   1025              TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   1026              /* Enable the External clock mode2 */
   1027              TIMx->SMCR |= TIM_SMCR_ECE;
   1028          }
   1029          
   1030          /**
   1031            * @brief  Configures the TIMx External Trigger (ETR).
   1032            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1033            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1034            *   This parameter can be one of the following values:
   1035            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1036            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1037            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1038            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1039            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1040            *   This parameter can be one of the following values:
   1041            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1042            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1043            * @param  ExtTRGFilter: External Trigger Filter.
   1044            *   This parameter must be a value between 0x00 and 0x0F
   1045            * @retval None
   1046            */
   1047          void TIM_ETRConfig(TIM_TypeDef *TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1048              uint16_t ExtTRGFilter) {
   1049              uint16_t tmpsmcr = 0;
   1050              /* Check the parameters */
   1051              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1052              assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1053              assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1054              assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1055              tmpsmcr = TIMx->SMCR;
   1056              /* Reset the ETR Bits */
   1057              tmpsmcr &= SMCR_ETR_Mask;
   1058              /* Set the Prescaler, the Filter value and the Polarity */
   1059              tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler
   1060                  | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   1061              /* Write to TIMx SMCR */
   1062              TIMx->SMCR = tmpsmcr;
   1063          }
   1064          
   1065          /**
   1066            * @brief  Configures the TIMx Prescaler.
   1067            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   1068            * @param  Prescaler: specifies the Prescaler Register value
   1069            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1070            *   This parameter can be one of the following values:
   1071            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
   1072            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
   1073            * @retval None
   1074            */
   1075          void TIM_PrescalerConfig(TIM_TypeDef *TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode) {
   1076              /* Check the parameters */
   1077              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1078              assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1079              /* Set the Prescaler value */
   1080              TIMx->PSC = Prescaler;
   1081              /* Set or reset the UG Bit */
   1082              TIMx->EGR = TIM_PSCReloadMode;
   1083          }
   1084          
   1085          /**
   1086            * @brief  Specifies the TIMx Counter Mode to be used.
   1087            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1088            * @param  TIM_CounterMode: specifies the Counter Mode to be used
   1089            *   This parameter can be one of the following values:
   1090            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
   1091            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
   1092            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1093            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1094            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1095            * @retval None
   1096            */
   1097          void TIM_CounterModeConfig(TIM_TypeDef *TIMx, uint16_t TIM_CounterMode) {
   1098              uint16_t tmpcr1 = 0;
   1099              /* Check the parameters */
   1100              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1101              assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1102              tmpcr1 = TIMx->CR1;
   1103              /* Reset the CMS and DIR Bits */
   1104              tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
   1105              /* Set the Counter Mode */
   1106              tmpcr1 |= TIM_CounterMode;
   1107              /* Write to TIMx CR1 register */
   1108              TIMx->CR1 = tmpcr1;
   1109          }
   1110          
   1111          /**
   1112            * @brief  Selects the Input Trigger source
   1113            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1114            * @param  TIM_InputTriggerSource: The Input Trigger source.
   1115            *   This parameter can be one of the following values:
   1116            *     @arg TIM_TS_ITR0: Internal Trigger 0
   1117            *     @arg TIM_TS_ITR1: Internal Trigger 1
   1118            *     @arg TIM_TS_ITR2: Internal Trigger 2
   1119            *     @arg TIM_TS_ITR3: Internal Trigger 3
   1120            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   1121            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   1122            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   1123            *     @arg TIM_TS_ETRF: External Trigger input
   1124            * @retval None
   1125            */
   1126          void TIM_SelectInputTrigger(TIM_TypeDef *TIMx, uint16_t TIM_InputTriggerSource) {
   1127              uint16_t tmpsmcr = 0;
   1128              /* Check the parameters */
   1129              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1130              assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1131              /* Get the TIMx SMCR register value */
   1132              tmpsmcr = TIMx->SMCR;
   1133              /* Reset the TS Bits */
   1134              tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   1135              /* Set the Input Trigger source */
   1136              tmpsmcr |= TIM_InputTriggerSource;
   1137              /* Write to TIMx SMCR */
   1138              TIMx->SMCR = tmpsmcr;
   1139          }
   1140          
   1141          /**
   1142            * @brief  Configures the TIMx Encoder Interface.
   1143            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1144            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1145            *   This parameter can be one of the following values:
   1146            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   1147            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   1148            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   1149            *                                on the level of the other input.
   1150            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   1151            *   This parameter can be one of the following values:
   1152            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1153            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1154            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   1155            *   This parameter can be one of the following values:
   1156            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1157            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1158            * @retval None
   1159            */
   1160          void TIM_EncoderInterfaceConfig(TIM_TypeDef *TIMx, uint16_t TIM_EncoderMode,
   1161              uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity) {
   1162              uint16_t tmpsmcr = 0;
   1163              uint16_t tmpccmr1 = 0;
   1164              uint16_t tmpccer = 0;
   1165          
   1166              /* Check the parameters */
   1167              assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   1168              assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1169              assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1170              assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1171          
   1172              /* Get the TIMx SMCR register value */
   1173              tmpsmcr = TIMx->SMCR;
   1174          
   1175              /* Get the TIMx CCMR1 register value */
   1176              tmpccmr1 = TIMx->CCMR1;
   1177          
   1178              /* Get the TIMx CCER register value */
   1179              tmpccer = TIMx->CCER;
   1180          
   1181              /* Set the encoder Mode */
   1182              tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   1183              tmpsmcr |= TIM_EncoderMode;
   1184          
   1185              /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1186              tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(
   1187                  ~((uint16_t)TIM_CCMR1_CC2S)));
   1188              tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   1189          
   1190              /* Set the TI1 and the TI2 Polarities */
   1191              tmpccer &=
   1192                  (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
   1193              tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   1194          
   1195              /* Write to TIMx SMCR */
   1196              TIMx->SMCR = tmpsmcr;
   1197              /* Write to TIMx CCMR1 */
   1198              TIMx->CCMR1 = tmpccmr1;
   1199              /* Write to TIMx CCER */
   1200              TIMx->CCER = tmpccer;
   1201          }
   1202          
   1203          /**
   1204            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1205            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1206            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1207            *   This parameter can be one of the following values:
   1208            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1209            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1210            * @retval None
   1211            */
   1212          void TIM_ForcedOC1Config(TIM_TypeDef *TIMx, uint16_t TIM_ForcedAction) {
   1213              uint16_t tmpccmr1 = 0;
   1214              /* Check the parameters */
   1215              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1216              assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1217              tmpccmr1 = TIMx->CCMR1;
   1218              /* Reset the OC1M Bits */
   1219              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
   1220              /* Configure The Forced output Mode */
   1221              tmpccmr1 |= TIM_ForcedAction;
   1222              /* Write to TIMx CCMR1 register */
   1223              TIMx->CCMR1 = tmpccmr1;
   1224          }
   1225          
   1226          /**
   1227            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1228            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1229            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1230            *   This parameter can be one of the following values:
   1231            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1232            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1233            * @retval None
   1234            */
   1235          void TIM_ForcedOC2Config(TIM_TypeDef *TIMx, uint16_t TIM_ForcedAction) {
   1236              uint16_t tmpccmr1 = 0;
   1237              /* Check the parameters */
   1238              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1239              assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1240              tmpccmr1 = TIMx->CCMR1;
   1241              /* Reset the OC2M Bits */
   1242              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
   1243              /* Configure The Forced output Mode */
   1244              tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1245              /* Write to TIMx CCMR1 register */
   1246              TIMx->CCMR1 = tmpccmr1;
   1247          }
   1248          
   1249          /**
   1250            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1251            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1252            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1253            *   This parameter can be one of the following values:
   1254            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1255            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1256            * @retval None
   1257            */
   1258          void TIM_ForcedOC3Config(TIM_TypeDef *TIMx, uint16_t TIM_ForcedAction) {
   1259              uint16_t tmpccmr2 = 0;
   1260              /* Check the parameters */
   1261              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1262              assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1263              tmpccmr2 = TIMx->CCMR2;
   1264              /* Reset the OC1M Bits */
   1265              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
   1266              /* Configure The Forced output Mode */
   1267              tmpccmr2 |= TIM_ForcedAction;
   1268              /* Write to TIMx CCMR2 register */
   1269              TIMx->CCMR2 = tmpccmr2;
   1270          }
   1271          
   1272          /**
   1273            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1274            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1275            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1276            *   This parameter can be one of the following values:
   1277            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1278            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1279            * @retval None
   1280            */
   1281          void TIM_ForcedOC4Config(TIM_TypeDef *TIMx, uint16_t TIM_ForcedAction) {
   1282              uint16_t tmpccmr2 = 0;
   1283              /* Check the parameters */
   1284              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1285              assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1286              tmpccmr2 = TIMx->CCMR2;
   1287              /* Reset the OC2M Bits */
   1288              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
   1289              /* Configure The Forced output Mode */
   1290              tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1291              /* Write to TIMx CCMR2 register */
   1292              TIMx->CCMR2 = tmpccmr2;
   1293          }
   1294          
   1295          /**
   1296            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
   1297            * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.
   1298            * @param  NewState: new state of the TIMx peripheral Preload register
   1299            *   This parameter can be: ENABLE or DISABLE.
   1300            * @retval None
   1301            */
   1302          void TIM_ARRPreloadConfig(TIM_TypeDef *TIMx, FunctionalState NewState) {
   1303              /* Check the parameters */
   1304              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1305              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1306          
   1307              if (NewState != DISABLE) {
   1308                  /* Set the ARR Preload Bit */
   1309                  TIMx->CR1 |= TIM_CR1_ARPE;
   1310              } else {
   1311                  /* Reset the ARR Preload Bit */
   1312                  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
   1313              }
   1314          }
   1315          
   1316          /**
   1317            * @brief  Selects the TIM peripheral Commutation event.
   1318            * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral
   1319            * @param  NewState: new state of the Commutation event.
   1320            *   This parameter can be: ENABLE or DISABLE.
   1321            * @retval None
   1322            */
   1323          void TIM_SelectCOM(TIM_TypeDef *TIMx, FunctionalState NewState) {
   1324              /* Check the parameters */
   1325              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1326              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1327          
   1328              if (NewState != DISABLE) {
   1329                  /* Set the COM Bit */
   1330                  TIMx->CR2 |= TIM_CR2_CCUS;
   1331              } else {
   1332                  /* Reset the COM Bit */
   1333                  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
   1334              }
   1335          }
   1336          
   1337          /**
   1338            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   1339            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
   1340            *         the TIM peripheral.
   1341            * @param  NewState: new state of the Capture Compare DMA source
   1342            *   This parameter can be: ENABLE or DISABLE.
   1343            * @retval None
   1344            */
   1345          void TIM_SelectCCDMA(TIM_TypeDef *TIMx, FunctionalState NewState) {
   1346              /* Check the parameters */
   1347              assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1348              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1349          
   1350              if (NewState != DISABLE) {
   1351                  /* Set the CCDS Bit */
   1352                  TIMx->CR2 |= TIM_CR2_CCDS;
   1353              } else {
   1354                  /* Reset the CCDS Bit */
   1355                  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
   1356              }
   1357          }
   1358          
   1359          /**
   1360            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   1361            * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15 
   1362            *         to select the TIMx peripheral
   1363            * @param  NewState: new state of the Capture Compare Preload Control bit
   1364            *   This parameter can be: ENABLE or DISABLE.
   1365            * @retval None
   1366            */
   1367          void TIM_CCPreloadControl(TIM_TypeDef *TIMx, FunctionalState NewState) {
   1368              /* Check the parameters */
   1369              assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   1370              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1371          
   1372              if (NewState != DISABLE) {
   1373                  /* Set the CCPC Bit */
   1374                  TIMx->CR2 |= TIM_CR2_CCPC;
   1375              } else {
   1376                  /* Reset the CCPC Bit */
   1377                  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
   1378              }
   1379          }
   1380          
   1381          /**
   1382            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1383            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1384            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1385            *   This parameter can be one of the following values:
   1386            *     @arg TIM_OCPreload_Enable
   1387            *     @arg TIM_OCPreload_Disable
   1388            * @retval None
   1389            */
   1390          void TIM_OC1PreloadConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPreload) {
   1391              uint16_t tmpccmr1 = 0;
   1392              /* Check the parameters */
   1393              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1394              assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1395              tmpccmr1 = TIMx->CCMR1;
   1396              /* Reset the OC1PE Bit */
   1397              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
   1398              /* Enable or Disable the Output Compare Preload feature */
   1399              tmpccmr1 |= TIM_OCPreload;
   1400              /* Write to TIMx CCMR1 register */
   1401              TIMx->CCMR1 = tmpccmr1;
   1402          }
   1403          
   1404          /**
   1405            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1406            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
   1407            *         the TIM peripheral.
   1408            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1409            *   This parameter can be one of the following values:
   1410            *     @arg TIM_OCPreload_Enable
   1411            *     @arg TIM_OCPreload_Disable
   1412            * @retval None
   1413            */
   1414          void TIM_OC2PreloadConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPreload) {
   1415              uint16_t tmpccmr1 = 0;
   1416              /* Check the parameters */
   1417              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1418              assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1419              tmpccmr1 = TIMx->CCMR1;
   1420              /* Reset the OC2PE Bit */
   1421              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
   1422              /* Enable or Disable the Output Compare Preload feature */
   1423              tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1424              /* Write to TIMx CCMR1 register */
   1425              TIMx->CCMR1 = tmpccmr1;
   1426          }
   1427          
   1428          /**
   1429            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1430            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1431            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1432            *   This parameter can be one of the following values:
   1433            *     @arg TIM_OCPreload_Enable
   1434            *     @arg TIM_OCPreload_Disable
   1435            * @retval None
   1436            */
   1437          void TIM_OC3PreloadConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPreload) {
   1438              uint16_t tmpccmr2 = 0;
   1439              /* Check the parameters */
   1440              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1441              assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1442              tmpccmr2 = TIMx->CCMR2;
   1443              /* Reset the OC3PE Bit */
   1444              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
   1445              /* Enable or Disable the Output Compare Preload feature */
   1446              tmpccmr2 |= TIM_OCPreload;
   1447              /* Write to TIMx CCMR2 register */
   1448              TIMx->CCMR2 = tmpccmr2;
   1449          }
   1450          
   1451          /**
   1452            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1453            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1454            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1455            *   This parameter can be one of the following values:
   1456            *     @arg TIM_OCPreload_Enable
   1457            *     @arg TIM_OCPreload_Disable
   1458            * @retval None
   1459            */
   1460          void TIM_OC4PreloadConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPreload) {
   1461              uint16_t tmpccmr2 = 0;
   1462              /* Check the parameters */
   1463              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1464              assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1465              tmpccmr2 = TIMx->CCMR2;
   1466              /* Reset the OC4PE Bit */
   1467              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
   1468              /* Enable or Disable the Output Compare Preload feature */
   1469              tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1470              /* Write to TIMx CCMR2 register */
   1471              TIMx->CCMR2 = tmpccmr2;
   1472          }
   1473          
   1474          /**
   1475            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1476            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1477            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1478            *   This parameter can be one of the following values:
   1479            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1480            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1481            * @retval None
   1482            */
   1483          void TIM_OC1FastConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCFast) {
   1484              uint16_t tmpccmr1 = 0;
   1485              /* Check the parameters */
   1486              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1487              assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1488              /* Get the TIMx CCMR1 register value */
   1489              tmpccmr1 = TIMx->CCMR1;
   1490              /* Reset the OC1FE Bit */
   1491              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
   1492              /* Enable or Disable the Output Compare Fast Bit */
   1493              tmpccmr1 |= TIM_OCFast;
   1494              /* Write to TIMx CCMR1 */
   1495              TIMx->CCMR1 = tmpccmr1;
   1496          }
   1497          
   1498          /**
   1499            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1500            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
   1501            *         the TIM peripheral.
   1502            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1503            *   This parameter can be one of the following values:
   1504            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1505            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1506            * @retval None
   1507            */
   1508          void TIM_OC2FastConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCFast) {
   1509              uint16_t tmpccmr1 = 0;
   1510              /* Check the parameters */
   1511              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1512              assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1513              /* Get the TIMx CCMR1 register value */
   1514              tmpccmr1 = TIMx->CCMR1;
   1515              /* Reset the OC2FE Bit */
   1516              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
   1517              /* Enable or Disable the Output Compare Fast Bit */
   1518              tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1519              /* Write to TIMx CCMR1 */
   1520              TIMx->CCMR1 = tmpccmr1;
   1521          }
   1522          
   1523          /**
   1524            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1525            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1526            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1527            *   This parameter can be one of the following values:
   1528            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1529            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1530            * @retval None
   1531            */
   1532          void TIM_OC3FastConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCFast) {
   1533              uint16_t tmpccmr2 = 0;
   1534              /* Check the parameters */
   1535              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1536              assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1537              /* Get the TIMx CCMR2 register value */
   1538              tmpccmr2 = TIMx->CCMR2;
   1539              /* Reset the OC3FE Bit */
   1540              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
   1541              /* Enable or Disable the Output Compare Fast Bit */
   1542              tmpccmr2 |= TIM_OCFast;
   1543              /* Write to TIMx CCMR2 */
   1544              TIMx->CCMR2 = tmpccmr2;
   1545          }
   1546          
   1547          /**
   1548            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1549            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1550            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1551            *   This parameter can be one of the following values:
   1552            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1553            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1554            * @retval None
   1555            */
   1556          void TIM_OC4FastConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCFast) {
   1557              uint16_t tmpccmr2 = 0;
   1558              /* Check the parameters */
   1559              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1560              assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1561              /* Get the TIMx CCMR2 register value */
   1562              tmpccmr2 = TIMx->CCMR2;
   1563              /* Reset the OC4FE Bit */
   1564              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
   1565              /* Enable or Disable the Output Compare Fast Bit */
   1566              tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1567              /* Write to TIMx CCMR2 */
   1568              TIMx->CCMR2 = tmpccmr2;
   1569          }
   1570          
   1571          /**
   1572            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1573            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1574            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1575            *   This parameter can be one of the following values:
   1576            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1577            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1578            * @retval None
   1579            */
   1580          void TIM_ClearOC1Ref(TIM_TypeDef *TIMx, uint16_t TIM_OCClear) {
   1581              uint16_t tmpccmr1 = 0;
   1582              /* Check the parameters */
   1583              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1584              assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1585          
   1586              tmpccmr1 = TIMx->CCMR1;
   1587          
   1588              /* Reset the OC1CE Bit */
   1589              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
   1590              /* Enable or Disable the Output Compare Clear Bit */
   1591              tmpccmr1 |= TIM_OCClear;
   1592              /* Write to TIMx CCMR1 register */
   1593              TIMx->CCMR1 = tmpccmr1;
   1594          }
   1595          
   1596          /**
   1597            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1598            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1599            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1600            *   This parameter can be one of the following values:
   1601            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1602            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1603            * @retval None
   1604            */
   1605          void TIM_ClearOC2Ref(TIM_TypeDef *TIMx, uint16_t TIM_OCClear) {
   1606              uint16_t tmpccmr1 = 0;
   1607              /* Check the parameters */
   1608              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1609              assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1610              tmpccmr1 = TIMx->CCMR1;
   1611              /* Reset the OC2CE Bit */
   1612              tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
   1613              /* Enable or Disable the Output Compare Clear Bit */
   1614              tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1615              /* Write to TIMx CCMR1 register */
   1616              TIMx->CCMR1 = tmpccmr1;
   1617          }
   1618          
   1619          /**
   1620            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1621            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1622            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1623            *   This parameter can be one of the following values:
   1624            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1625            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1626            * @retval None
   1627            */
   1628          void TIM_ClearOC3Ref(TIM_TypeDef *TIMx, uint16_t TIM_OCClear) {
   1629              uint16_t tmpccmr2 = 0;
   1630              /* Check the parameters */
   1631              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1632              assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1633              tmpccmr2 = TIMx->CCMR2;
   1634              /* Reset the OC3CE Bit */
   1635              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
   1636              /* Enable or Disable the Output Compare Clear Bit */
   1637              tmpccmr2 |= TIM_OCClear;
   1638              /* Write to TIMx CCMR2 register */
   1639              TIMx->CCMR2 = tmpccmr2;
   1640          }
   1641          
   1642          /**
   1643            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1644            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1645            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1646            *   This parameter can be one of the following values:
   1647            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1648            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1649            * @retval None
   1650            */
   1651          void TIM_ClearOC4Ref(TIM_TypeDef *TIMx, uint16_t TIM_OCClear) {
   1652              uint16_t tmpccmr2 = 0;
   1653              /* Check the parameters */
   1654              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1655              assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1656              tmpccmr2 = TIMx->CCMR2;
   1657              /* Reset the OC4CE Bit */
   1658              tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
   1659              /* Enable or Disable the Output Compare Clear Bit */
   1660              tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1661              /* Write to TIMx CCMR2 register */
   1662              TIMx->CCMR2 = tmpccmr2;
   1663          }
   1664          
   1665          /**
   1666            * @brief  Configures the TIMx channel 1 polarity.
   1667            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1668            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1669            *   This parameter can be one of the following values:
   1670            *     @arg TIM_OCPolarity_High: Output Compare active high
   1671            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1672            * @retval None
   1673            */
   1674          void TIM_OC1PolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPolarity) {
   1675              uint16_t tmpccer = 0;
   1676              /* Check the parameters */
   1677              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1678              assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1679              tmpccer = TIMx->CCER;
   1680              /* Set or Reset the CC1P Bit */
   1681              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
   1682              tmpccer |= TIM_OCPolarity;
   1683              /* Write to TIMx CCER register */
   1684              TIMx->CCER = tmpccer;
   1685          }
   1686          
   1687          /**
   1688            * @brief  Configures the TIMx Channel 1N polarity.
   1689            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
   1690            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1691            *   This parameter can be one of the following values:
   1692            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1693            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1694            * @retval None
   1695            */
   1696          void TIM_OC1NPolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCNPolarity) {
   1697              uint16_t tmpccer = 0;
   1698              /* Check the parameters */
   1699              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1700              assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1701          
   1702              tmpccer = TIMx->CCER;
   1703              /* Set or Reset the CC1NP Bit */
   1704              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
   1705              tmpccer |= TIM_OCNPolarity;
   1706              /* Write to TIMx CCER register */
   1707              TIMx->CCER = tmpccer;
   1708          }
   1709          
   1710          /**
   1711            * @brief  Configures the TIMx channel 2 polarity.
   1712            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1713            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1714            *   This parameter can be one of the following values:
   1715            *     @arg TIM_OCPolarity_High: Output Compare active high
   1716            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1717            * @retval None
   1718            */
   1719          void TIM_OC2PolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPolarity) {
   1720              uint16_t tmpccer = 0;
   1721              /* Check the parameters */
   1722              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1723              assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1724              tmpccer = TIMx->CCER;
   1725              /* Set or Reset the CC2P Bit */
   1726              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
   1727              tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1728              /* Write to TIMx CCER register */
   1729              TIMx->CCER = tmpccer;
   1730          }
   1731          
   1732          /**
   1733            * @brief  Configures the TIMx Channel 2N polarity.
   1734            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1735            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1736            *   This parameter can be one of the following values:
   1737            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1738            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1739            * @retval None
   1740            */
   1741          void TIM_OC2NPolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCNPolarity) {
   1742              uint16_t tmpccer = 0;
   1743              /* Check the parameters */
   1744              assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1745              assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1746          
   1747              tmpccer = TIMx->CCER;
   1748              /* Set or Reset the CC2NP Bit */
   1749              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
   1750              tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1751              /* Write to TIMx CCER register */
   1752              TIMx->CCER = tmpccer;
   1753          }
   1754          
   1755          /**
   1756            * @brief  Configures the TIMx channel 3 polarity.
   1757            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1758            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1759            *   This parameter can be one of the following values:
   1760            *     @arg TIM_OCPolarity_High: Output Compare active high
   1761            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1762            * @retval None
   1763            */
   1764          void TIM_OC3PolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPolarity) {
   1765              uint16_t tmpccer = 0;
   1766              /* Check the parameters */
   1767              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1768              assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1769              tmpccer = TIMx->CCER;
   1770              /* Set or Reset the CC3P Bit */
   1771              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
   1772              tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1773              /* Write to TIMx CCER register */
   1774              TIMx->CCER = tmpccer;
   1775          }
   1776          
   1777          /**
   1778            * @brief  Configures the TIMx Channel 3N polarity.
   1779            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1780            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1781            *   This parameter can be one of the following values:
   1782            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1783            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1784            * @retval None
   1785            */
   1786          void TIM_OC3NPolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCNPolarity) {
   1787              uint16_t tmpccer = 0;
   1788          
   1789              /* Check the parameters */
   1790              assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1791              assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1792          
   1793              tmpccer = TIMx->CCER;
   1794              /* Set or Reset the CC3NP Bit */
   1795              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
   1796              tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1797              /* Write to TIMx CCER register */
   1798              TIMx->CCER = tmpccer;
   1799          }
   1800          
   1801          /**
   1802            * @brief  Configures the TIMx channel 4 polarity.
   1803            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1804            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1805            *   This parameter can be one of the following values:
   1806            *     @arg TIM_OCPolarity_High: Output Compare active high
   1807            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1808            * @retval None
   1809            */
   1810          void TIM_OC4PolarityConfig(TIM_TypeDef *TIMx, uint16_t TIM_OCPolarity) {
   1811              uint16_t tmpccer = 0;
   1812              /* Check the parameters */
   1813              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1814              assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1815              tmpccer = TIMx->CCER;
   1816              /* Set or Reset the CC4P Bit */
   1817              tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
   1818              tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1819              /* Write to TIMx CCER register */
   1820              TIMx->CCER = tmpccer;
   1821          }
   1822          
   1823          /**
   1824            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1825            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1826            * @param  TIM_Channel: specifies the TIM Channel
   1827            *   This parameter can be one of the following values:
   1828            *     @arg TIM_Channel_1: TIM Channel 1
   1829            *     @arg TIM_Channel_2: TIM Channel 2
   1830            *     @arg TIM_Channel_3: TIM Channel 3
   1831            *     @arg TIM_Channel_4: TIM Channel 4
   1832            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1833            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1834            * @retval None
   1835            */
   1836          void TIM_CCxCmd(TIM_TypeDef *TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx) {
   1837              uint16_t tmp = 0;
   1838          
   1839              /* Check the parameters */
   1840              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1841              assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1842              assert_param(IS_TIM_CCX(TIM_CCx));
   1843          
   1844              tmp = CCER_CCE_Set << TIM_Channel;
   1845          
   1846              /* Reset the CCxE Bit */
   1847              TIMx->CCER &= (uint16_t) ~tmp;
   1848          
   1849              /* Set or reset the CCxE Bit */
   1850              TIMx->CCER |= (uint16_t)(TIM_CCx << TIM_Channel);
   1851          }
   1852          
   1853          /**
   1854            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1855            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
   1856            * @param  TIM_Channel: specifies the TIM Channel
   1857            *   This parameter can be one of the following values:
   1858            *     @arg TIM_Channel_1: TIM Channel 1
   1859            *     @arg TIM_Channel_2: TIM Channel 2
   1860            *     @arg TIM_Channel_3: TIM Channel 3
   1861            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1862            *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1863            * @retval None
   1864            */
   1865          void TIM_CCxNCmd(TIM_TypeDef *TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN) {
   1866              uint16_t tmp = 0;
   1867          
   1868              /* Check the parameters */
   1869              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1870              assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1871              assert_param(IS_TIM_CCXN(TIM_CCxN));
   1872          
   1873              tmp = CCER_CCNE_Set << TIM_Channel;
   1874          
   1875              /* Reset the CCxNE Bit */
   1876              TIMx->CCER &= (uint16_t) ~tmp;
   1877          
   1878              /* Set or reset the CCxNE Bit */
   1879              TIMx->CCER |= (uint16_t)(TIM_CCxN << TIM_Channel);
   1880          }
   1881          
   1882          /**
   1883            * @brief  Selects the TIM Output Compare Mode.
   1884            * @note   This function disables the selected channel before changing the Output
   1885            *         Compare Mode.
   1886            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
   1887            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1888            * @param  TIM_Channel: specifies the TIM Channel
   1889            *   This parameter can be one of the following values:
   1890            *     @arg TIM_Channel_1: TIM Channel 1
   1891            *     @arg TIM_Channel_2: TIM Channel 2
   1892            *     @arg TIM_Channel_3: TIM Channel 3
   1893            *     @arg TIM_Channel_4: TIM Channel 4
   1894            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   1895            *   This parameter can be one of the following values:
   1896            *     @arg TIM_OCMode_Timing
   1897            *     @arg TIM_OCMode_Active
   1898            *     @arg TIM_OCMode_Toggle
   1899            *     @arg TIM_OCMode_PWM1
   1900            *     @arg TIM_OCMode_PWM2
   1901            *     @arg TIM_ForcedAction_Active
   1902            *     @arg TIM_ForcedAction_InActive
   1903            * @retval None
   1904            */
   1905          void TIM_SelectOCxM(TIM_TypeDef *TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode) {
   1906              uint32_t tmp = 0;
   1907              uint16_t tmp1 = 0;
   1908          
   1909              /* Check the parameters */
   1910              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1911              assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1912              assert_param(IS_TIM_OCM(TIM_OCMode));
   1913          
   1914              tmp = (uint32_t)TIMx;
   1915              tmp += CCMR_Offset;
   1916          
   1917              tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
   1918          
   1919              /* Disable the Channel: Reset the CCxE Bit */
   1920              TIMx->CCER &= (uint16_t) ~tmp1;
   1921          
   1922              if ((TIM_Channel == TIM_Channel_1) || (TIM_Channel == TIM_Channel_3)) {
   1923                  tmp += (TIM_Channel >> 1);
   1924          
   1925                  /* Reset the OCxM bits in the CCMRx register */
   1926                  *(__IO uint32_t *)tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
   1927          
   1928                  /* Configure the OCxM bits in the CCMRx register */
   1929                  *(__IO uint32_t *)tmp |= TIM_OCMode;
   1930              } else {
   1931                  tmp += (uint16_t)(TIM_Channel - (uint16_t)4) >> (uint16_t)1;
   1932          
   1933                  /* Reset the OCxM bits in the CCMRx register */
   1934                  *(__IO uint32_t *)tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
   1935          
   1936                  /* Configure the OCxM bits in the CCMRx register */
   1937                  *(__IO uint32_t *)tmp |= (uint16_t)(TIM_OCMode << 8);
   1938              }
   1939          }
   1940          
   1941          /**
   1942            * @brief  Enables or Disables the TIMx Update event.
   1943            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   1944            * @param  NewState: new state of the TIMx UDIS bit
   1945            *   This parameter can be: ENABLE or DISABLE.
   1946            * @retval None
   1947            */
   1948          void TIM_UpdateDisableConfig(TIM_TypeDef *TIMx, FunctionalState NewState) {
   1949              /* Check the parameters */
   1950              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1951              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1952          
   1953              if (NewState != DISABLE) {
   1954                  /* Set the Update Disable Bit */
   1955                  TIMx->CR1 |= TIM_CR1_UDIS;
   1956              } else {
   1957                  /* Reset the Update Disable Bit */
   1958                  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
   1959              }
   1960          }
   1961          
   1962          /**
   1963            * @brief  Configures the TIMx Update Request Interrupt source.
   1964            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   1965            * @param  TIM_UpdateSource: specifies the Update source.
   1966            *   This parameter can be one of the following values:
   1967            *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
   1968                                                 or the setting of UG bit, or an update generation
   1969                                                 through the slave mode controller.
   1970            *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
   1971            * @retval None
   1972            */
   1973          void TIM_UpdateRequestConfig(TIM_TypeDef *TIMx, uint16_t TIM_UpdateSource) {
   1974              /* Check the parameters */
   1975              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1976              assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   1977          
   1978              if (TIM_UpdateSource != TIM_UpdateSource_Global) {
   1979                  /* Set the URS Bit */
   1980                  TIMx->CR1 |= TIM_CR1_URS;
   1981              } else {
   1982                  /* Reset the URS Bit */
   1983                  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
   1984              }
   1985          }
   1986          
   1987          /**
   1988            * @brief  Enables or disables the TIMx's Hall sensor interface.
   1989            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1990            * @param  NewState: new state of the TIMx Hall sensor interface.
   1991            *   This parameter can be: ENABLE or DISABLE.
   1992            * @retval None
   1993            */
   1994          void TIM_SelectHallSensor(TIM_TypeDef *TIMx, FunctionalState NewState) {
   1995              /* Check the parameters */
   1996              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1997              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1998          
   1999              if (NewState != DISABLE) {
   2000                  /* Set the TI1S Bit */
   2001                  TIMx->CR2 |= TIM_CR2_TI1S;
   2002              } else {
   2003                  /* Reset the TI1S Bit */
   2004                  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
   2005              }
   2006          }
   2007          
   2008          /**
   2009            * @brief  Selects the TIMx's One Pulse Mode.
   2010            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2011            * @param  TIM_OPMode: specifies the OPM Mode to be used.
   2012            *   This parameter can be one of the following values:
   2013            *     @arg TIM_OPMode_Single
   2014            *     @arg TIM_OPMode_Repetitive
   2015            * @retval None
   2016            */
   2017          void TIM_SelectOnePulseMode(TIM_TypeDef *TIMx, uint16_t TIM_OPMode) {
   2018              /* Check the parameters */
   2019              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2020              assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2021              /* Reset the OPM Bit */
   2022              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
   2023              /* Configure the OPM Mode */
   2024              TIMx->CR1 |= TIM_OPMode;
   2025          }
   2026          
   2027          /**
   2028            * @brief  Selects the TIMx Trigger Output Mode.
   2029            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.
   2030            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2031            *   This paramter can be one of the following values:
   2032            *
   2033            *  - For all TIMx
   2034            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2035            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2036            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2037            *
   2038            *  - For all TIMx except TIM6 and TIM7
   2039            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2040            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2041            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2042            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2043            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2044            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2045            *
   2046            * @retval None
   2047            */
   2048          void TIM_SelectOutputTrigger(TIM_TypeDef *TIMx, uint16_t TIM_TRGOSource) {
   2049              /* Check the parameters */
   2050              assert_param(IS_TIM_LIST7_PERIPH(TIMx));
   2051              assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2052              /* Reset the MMS Bits */
   2053              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
   2054              /* Select the TRGO source */
   2055              TIMx->CR2 |= TIM_TRGOSource;
   2056          }
   2057          
   2058          /**
   2059            * @brief  Selects the TIMx Slave Mode.
   2060            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2061            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2062            *   This parameter can be one of the following values:
   2063            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2064            *                               the counter and triggers an update of the registers.
   2065            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2066            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2067            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2068            * @retval None
   2069            */
   2070          void TIM_SelectSlaveMode(TIM_TypeDef *TIMx, uint16_t TIM_SlaveMode) {
   2071              /* Check the parameters */
   2072              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2073              assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2074              /* Reset the SMS Bits */
   2075              TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
   2076              /* Select the Slave Mode */
   2077              TIMx->SMCR |= TIM_SlaveMode;
   2078          }
   2079          
   2080          /**
   2081            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2082            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2083            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2084            *   This parameter can be one of the following values:
   2085            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2086            *                                      and its slaves (through TRGO).
   2087            *     @arg TIM_MasterSlaveMode_Disable: No action
   2088            * @retval None
   2089            */
   2090          void TIM_SelectMasterSlaveMode(TIM_TypeDef *TIMx, uint16_t TIM_MasterSlaveMode) {
   2091              /* Check the parameters */
   2092              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2093              assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2094              /* Reset the MSM Bit */
   2095              TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
   2096          
   2097              /* Set or Reset the MSM Bit */
   2098              TIMx->SMCR |= TIM_MasterSlaveMode;
   2099          }
   2100          
   2101          /**
   2102            * @brief  Sets the TIMx Counter Register value
   2103            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2104            * @param  Counter: specifies the Counter register new value.
   2105            * @retval None
   2106            */
   2107          void TIM_SetCounter(TIM_TypeDef *TIMx, uint16_t Counter) {
   2108              /* Check the parameters */
   2109              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2110              /* Set the Counter Register value */
   2111              TIMx->CNT = Counter;
   2112          }
   2113          
   2114          /**
   2115            * @brief  Sets the TIMx Autoreload Register value
   2116            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2117            * @param  Autoreload: specifies the Autoreload register new value.
   2118            * @retval None
   2119            */
   2120          void TIM_SetAutoreload(TIM_TypeDef *TIMx, uint16_t Autoreload) {
   2121              /* Check the parameters */
   2122              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2123              /* Set the Autoreload Register value */
   2124              TIMx->ARR = Autoreload;
   2125          }
   2126          
   2127          /**
   2128            * @brief  Sets the TIMx Capture Compare1 Register value
   2129            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2130            * @param  Compare1: specifies the Capture Compare1 register new value.
   2131            * @retval None
   2132            */
   2133          void TIM_SetCompare1(TIM_TypeDef *TIMx, uint16_t Compare1) {
   2134              /* Check the parameters */
   2135              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2136              /* Set the Capture Compare1 Register value */
   2137              TIMx->CCR1 = Compare1;
   2138          }
   2139          
   2140          /**
   2141            * @brief  Sets the TIMx Capture Compare2 Register value
   2142            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2143            * @param  Compare2: specifies the Capture Compare2 register new value.
   2144            * @retval None
   2145            */
   2146          void TIM_SetCompare2(TIM_TypeDef *TIMx, uint16_t Compare2) {
   2147              /* Check the parameters */
   2148              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2149              /* Set the Capture Compare2 Register value */
   2150              TIMx->CCR2 = Compare2;
   2151          }
   2152          
   2153          /**
   2154            * @brief  Sets the TIMx Capture Compare3 Register value
   2155            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2156            * @param  Compare3: specifies the Capture Compare3 register new value.
   2157            * @retval None
   2158            */
   2159          void TIM_SetCompare3(TIM_TypeDef *TIMx, uint16_t Compare3) {
   2160              /* Check the parameters */
   2161              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2162              /* Set the Capture Compare3 Register value */
   2163              TIMx->CCR3 = Compare3;
   2164          }
   2165          
   2166          /**
   2167            * @brief  Sets the TIMx Capture Compare4 Register value
   2168            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2169            * @param  Compare4: specifies the Capture Compare4 register new value.
   2170            * @retval None
   2171            */
   2172          void TIM_SetCompare4(TIM_TypeDef *TIMx, uint16_t Compare4) {
   2173              /* Check the parameters */
   2174              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2175              /* Set the Capture Compare4 Register value */
   2176              TIMx->CCR4 = Compare4;
   2177          }
   2178          
   2179          /**
   2180            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2181            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2182            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2183            *   This parameter can be one of the following values:
   2184            *     @arg TIM_ICPSC_DIV1: no prescaler
   2185            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2186            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2187            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2188            * @retval None
   2189            */
   2190          void TIM_SetIC1Prescaler(TIM_TypeDef *TIMx, uint16_t TIM_ICPSC) {
   2191              /* Check the parameters */
   2192              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2193              assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2194              /* Reset the IC1PSC Bits */
   2195              TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
   2196              /* Set the IC1PSC value */
   2197              TIMx->CCMR1 |= TIM_ICPSC;
   2198          }
   2199          
   2200          /**
   2201            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2202            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2203            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2204            *   This parameter can be one of the following values:
   2205            *     @arg TIM_ICPSC_DIV1: no prescaler
   2206            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2207            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2208            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2209            * @retval None
   2210            */
   2211          void TIM_SetIC2Prescaler(TIM_TypeDef *TIMx, uint16_t TIM_ICPSC) {
   2212              /* Check the parameters */
   2213              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2214              assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2215              /* Reset the IC2PSC Bits */
   2216              TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
   2217              /* Set the IC2PSC value */
   2218              TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2219          }
   2220          
   2221          /**
   2222            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2223            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2224            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2225            *   This parameter can be one of the following values:
   2226            *     @arg TIM_ICPSC_DIV1: no prescaler
   2227            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2228            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2229            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2230            * @retval None
   2231            */
   2232          void TIM_SetIC3Prescaler(TIM_TypeDef *TIMx, uint16_t TIM_ICPSC) {
   2233              /* Check the parameters */
   2234              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2235              assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2236              /* Reset the IC3PSC Bits */
   2237              TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
   2238              /* Set the IC3PSC value */
   2239              TIMx->CCMR2 |= TIM_ICPSC;
   2240          }
   2241          
   2242          /**
   2243            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2244            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2245            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2246            *   This parameter can be one of the following values:
   2247            *     @arg TIM_ICPSC_DIV1: no prescaler
   2248            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2249            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2250            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2251            * @retval None
   2252            */
   2253          void TIM_SetIC4Prescaler(TIM_TypeDef *TIMx, uint16_t TIM_ICPSC) {
   2254              /* Check the parameters */
   2255              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2256              assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2257              /* Reset the IC4PSC Bits */
   2258              TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
   2259              /* Set the IC4PSC value */
   2260              TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2261          }
   2262          
   2263          /**
   2264            * @brief  Sets the TIMx Clock Division value.
   2265            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select 
   2266            *   the TIM peripheral.
   2267            * @param  TIM_CKD: specifies the clock division value.
   2268            *   This parameter can be one of the following value:
   2269            *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
   2270            *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2271            *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2272            * @retval None
   2273            */
   2274          void TIM_SetClockDivision(TIM_TypeDef *TIMx, uint16_t TIM_CKD) {
   2275              /* Check the parameters */
   2276              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2277              assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2278              /* Reset the CKD Bits */
   2279              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
   2280              /* Set the CKD value */
   2281              TIMx->CR1 |= TIM_CKD;
   2282          }
   2283          
   2284          /**
   2285            * @brief  Gets the TIMx Input Capture 1 value.
   2286            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2287            * @retval Capture Compare 1 Register value.
   2288            */
   2289          uint16_t TIM_GetCapture1(TIM_TypeDef *TIMx) {
   2290              /* Check the parameters */
   2291              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2292              /* Get the Capture 1 Register value */
   2293              return TIMx->CCR1;
   2294          }
   2295          
   2296          /**
   2297            * @brief  Gets the TIMx Input Capture 2 value.
   2298            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2299            * @retval Capture Compare 2 Register value.
   2300            */
   2301          uint16_t TIM_GetCapture2(TIM_TypeDef *TIMx) {
   2302              /* Check the parameters */
   2303              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2304              /* Get the Capture 2 Register value */
   2305              return TIMx->CCR2;
   2306          }
   2307          
   2308          /**
   2309            * @brief  Gets the TIMx Input Capture 3 value.
   2310            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2311            * @retval Capture Compare 3 Register value.
   2312            */
   2313          uint16_t TIM_GetCapture3(TIM_TypeDef *TIMx) {
   2314              /* Check the parameters */
   2315              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2316              /* Get the Capture 3 Register value */
   2317              return TIMx->CCR3;
   2318          }
   2319          
   2320          /**
   2321            * @brief  Gets the TIMx Input Capture 4 value.
   2322            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2323            * @retval Capture Compare 4 Register value.
   2324            */
   2325          uint16_t TIM_GetCapture4(TIM_TypeDef *TIMx) {
   2326              /* Check the parameters */
   2327              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2328              /* Get the Capture 4 Register value */
   2329              return TIMx->CCR4;
   2330          }
   2331          
   2332          /**
   2333            * @brief  Gets the TIMx Counter value.
   2334            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2335            * @retval Counter Register value.
   2336            */
   2337          uint16_t TIM_GetCounter(TIM_TypeDef *TIMx) {
   2338              /* Check the parameters */
   2339              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2340              /* Get the Counter Register value */
   2341              return TIMx->CNT;
   2342          }
   2343          
   2344          /**
   2345            * @brief  Gets the TIMx Prescaler value.
   2346            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2347            * @retval Prescaler Register value.
   2348            */
   2349          uint16_t TIM_GetPrescaler(TIM_TypeDef *TIMx) {
   2350              /* Check the parameters */
   2351              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2352              /* Get the Prescaler Register value */
   2353              return TIMx->PSC;
   2354          }
   2355          
   2356          /**
   2357            * @brief  Checks whether the specified TIM flag is set or not.
   2358            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2359            * @param  TIM_FLAG: specifies the flag to check.
   2360            *   This parameter can be one of the following values:
   2361            *     @arg TIM_FLAG_Update: TIM update Flag
   2362            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2363            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2364            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2365            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2366            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2367            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2368            *     @arg TIM_FLAG_Break: TIM Break Flag
   2369            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2370            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2371            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2372            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2373            * @note
   2374            *   - TIM6 and TIM7 can have only one update flag. 
   2375            *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
   2376            *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
   2377            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
   2378            *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
   2379            *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
   2380            * @retval The new state of TIM_FLAG (SET or RESET).
   2381            */
   2382          FlagStatus TIM_GetFlagStatus(TIM_TypeDef *TIMx, uint16_t TIM_FLAG) {
   2383              ITStatus bitstatus = RESET;
   2384              /* Check the parameters */
   2385              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2386              assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2387          
   2388              if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET) {
   2389                  bitstatus = SET;
   2390              } else {
   2391                  bitstatus = RESET;
   2392              }
   2393              return bitstatus;
   2394          }
   2395          
   2396          /**
   2397            * @brief  Clears the TIMx's pending flags.
   2398            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2399            * @param  TIM_FLAG: specifies the flag bit to clear.
   2400            *   This parameter can be any combination of the following values:
   2401            *     @arg TIM_FLAG_Update: TIM update Flag
   2402            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2403            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2404            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2405            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2406            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2407            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2408            *     @arg TIM_FLAG_Break: TIM Break Flag
   2409            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2410            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2411            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2412            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2413            * @note
   2414            *   - TIM6 and TIM7 can have only one update flag. 
   2415            *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
   2416            *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
   2417            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
   2418            *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
   2419            *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.   
   2420            * @retval None
   2421            */
   2422          void TIM_ClearFlag(TIM_TypeDef *TIMx, uint16_t TIM_FLAG) {
   2423              /* Check the parameters */
   2424              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2425              assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   2426          
   2427              /* Clear the flags */
   2428              TIMx->SR = (uint16_t) ~TIM_FLAG;
   2429          }
   2430          
   2431          /**
   2432            * @brief  Checks whether the TIM interrupt has occurred or not.
   2433            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2434            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2435            *   This parameter can be one of the following values:
   2436            *     @arg TIM_IT_Update: TIM update Interrupt source
   2437            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2438            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2439            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2440            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2441            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2442            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2443            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2444            * @note
   2445            *   - TIM6 and TIM7 can generate only an update interrupt.
   2446            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
   2447            *      TIM_IT_CC2 or TIM_IT_Trigger. 
   2448            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
   2449            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
   2450            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.  
   2451            * @retval The new state of the TIM_IT(SET or RESET).
   2452            */
   2453          ITStatus TIM_GetITStatus(TIM_TypeDef *TIMx, uint16_t TIM_IT) {
   2454              ITStatus bitstatus = RESET;
   2455              uint16_t itstatus = 0x0, itenable = 0x0;
   2456              /* Check the parameters */
   2457              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2458              assert_param(IS_TIM_GET_IT(TIM_IT));
   2459          
   2460              itstatus = TIMx->SR & TIM_IT;
   2461          
   2462              itenable = TIMx->DIER & TIM_IT;
   2463          
   2464              if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET)) {
   2465                  bitstatus = SET;
   2466              } else {
   2467                  bitstatus = RESET;
   2468              }
   2469              return bitstatus;
   2470          }
   2471          
   2472          /**
   2473            * @brief  Clears the TIMx's interrupt pending bits.
   2474            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2475            * @param  TIM_IT: specifies the pending bit to clear.
   2476            *   This parameter can be any combination of the following values:
   2477            *     @arg TIM_IT_Update: TIM1 update Interrupt source
   2478            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2479            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2480            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2481            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2482            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2483            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2484            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2485            * @note
   2486            *   - TIM6 and TIM7 can generate only an update interrupt.
   2487            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
   2488            *      TIM_IT_CC2 or TIM_IT_Trigger. 
   2489            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
   2490            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
   2491            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
   2492            * @retval None
   2493            */
   2494          void TIM_ClearITPendingBit(TIM_TypeDef *TIMx, uint16_t TIM_IT) {
   2495              /* Check the parameters */
   2496              assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2497              assert_param(IS_TIM_IT(TIM_IT));
   2498              /* Clear the IT pending Bit */
   2499              TIMx->SR = (uint16_t) ~TIM_IT;
   2500          }
   2501          
   2502          /**
   2503            * @brief  Configure the TI1 as Input.
   2504            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2505            * @param  TIM_ICPolarity : The Input Polarity.
   2506            *   This parameter can be one of the following values:
   2507            *     @arg TIM_ICPolarity_Rising
   2508            *     @arg TIM_ICPolarity_Falling
   2509            * @param  TIM_ICSelection: specifies the input to be used.
   2510            *   This parameter can be one of the following values:
   2511            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2512            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2513            *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   2514            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2515            *   This parameter must be a value between 0x00 and 0x0F.
   2516            * @retval None
   2517            */
   2518          static void TI1_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2519              uint16_t TIM_ICFilter) {
   2520              uint16_t tmpccmr1 = 0, tmpccer = 0;
   2521              /* Disable the Channel 1: Reset the CC1E Bit */
   2522              TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
   2523              tmpccmr1 = TIMx->CCMR1;
   2524              tmpccer = TIMx->CCER;
   2525              /* Select the Input and set the filter */
   2526              tmpccmr1 &=
   2527                  (uint16_t)
   2528                      (((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
   2529              tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   2530          
   2531              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) || (TIMx == TIM4)
   2532                  || (TIMx == TIM5)) {
   2533                  /* Select the Polarity and set the CC1E Bit */
   2534                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
   2535                  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   2536              } else {
   2537                  /* Select the Polarity and set the CC1E Bit */
   2538                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
   2539                  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   2540              }
   2541          
   2542              /* Write to TIMx CCMR1 and CCER registers */
   2543              TIMx->CCMR1 = tmpccmr1;
   2544              TIMx->CCER = tmpccer;
   2545          }
   2546          
   2547          /**
   2548            * @brief  Configure the TI2 as Input.
   2549            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2550            * @param  TIM_ICPolarity : The Input Polarity.
   2551            *   This parameter can be one of the following values:
   2552            *     @arg TIM_ICPolarity_Rising
   2553            *     @arg TIM_ICPolarity_Falling
   2554            * @param  TIM_ICSelection: specifies the input to be used.
   2555            *   This parameter can be one of the following values:
   2556            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2557            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2558            *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   2559            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2560            *   This parameter must be a value between 0x00 and 0x0F.
   2561            * @retval None
   2562            */
   2563          static void TI2_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2564              uint16_t TIM_ICFilter) {
   2565              uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2566              /* Disable the Channel 2: Reset the CC2E Bit */
   2567              TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
   2568              tmpccmr1 = TIMx->CCMR1;
   2569              tmpccer = TIMx->CCER;
   2570              tmp = (uint16_t)(TIM_ICPolarity << 4);
   2571              /* Select the Input and set the filter */
   2572              tmpccmr1 &=
   2573                  (uint16_t)
   2574                      (((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
   2575              tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   2576              tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   2577          
   2578              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) || (TIMx == TIM4)
   2579                  || (TIMx == TIM5)) {
   2580                  /* Select the Polarity and set the CC2E Bit */
   2581                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
   2582                  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   2583              } else {
   2584                  /* Select the Polarity and set the CC2E Bit */
   2585                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
   2586                  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
   2587              }
   2588          
   2589              /* Write to TIMx CCMR1 and CCER registers */
   2590              TIMx->CCMR1 = tmpccmr1;
   2591              TIMx->CCER = tmpccer;
   2592          }
   2593          
   2594          /**
   2595            * @brief  Configure the TI3 as Input.
   2596            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2597            * @param  TIM_ICPolarity : The Input Polarity.
   2598            *   This parameter can be one of the following values:
   2599            *     @arg TIM_ICPolarity_Rising
   2600            *     @arg TIM_ICPolarity_Falling
   2601            * @param  TIM_ICSelection: specifies the input to be used.
   2602            *   This parameter can be one of the following values:
   2603            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2604            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2605            *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   2606            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2607            *   This parameter must be a value between 0x00 and 0x0F.
   2608            * @retval None
   2609            */
   2610          static void TI3_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2611              uint16_t TIM_ICFilter) {
   2612              uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2613              /* Disable the Channel 3: Reset the CC3E Bit */
   2614              TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
   2615              tmpccmr2 = TIMx->CCMR2;
   2616              tmpccer = TIMx->CCER;
   2617              tmp = (uint16_t)(TIM_ICPolarity << 8);
   2618              /* Select the Input and set the filter */
   2619              tmpccmr2 &=
   2620                  (uint16_t)
   2621                      (((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
   2622              tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   2623          
   2624              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) || (TIMx == TIM4)
   2625                  || (TIMx == TIM5)) {
   2626                  /* Select the Polarity and set the CC3E Bit */
   2627                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
   2628                  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   2629              } else {
   2630                  /* Select the Polarity and set the CC3E Bit */
   2631                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
   2632                  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
   2633              }
   2634          
   2635              /* Write to TIMx CCMR2 and CCER registers */
   2636              TIMx->CCMR2 = tmpccmr2;
   2637              TIMx->CCER = tmpccer;
   2638          }
   2639          
   2640          /**
   2641            * @brief  Configure the TI4 as Input.
   2642            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2643            * @param  TIM_ICPolarity : The Input Polarity.
   2644            *   This parameter can be one of the following values:
   2645            *     @arg TIM_ICPolarity_Rising
   2646            *     @arg TIM_ICPolarity_Falling
   2647            * @param  TIM_ICSelection: specifies the input to be used.
   2648            *   This parameter can be one of the following values:
   2649            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2650            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2651            *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   2652            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2653            *   This parameter must be a value between 0x00 and 0x0F.
   2654            * @retval None
   2655            */
   2656          static void TI4_Config(TIM_TypeDef *TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2657              uint16_t TIM_ICFilter) {
   2658              uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2659          
   2660              /* Disable the Channel 4: Reset the CC4E Bit */
   2661              TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
   2662              tmpccmr2 = TIMx->CCMR2;
   2663              tmpccer = TIMx->CCER;
   2664              tmp = (uint16_t)(TIM_ICPolarity << 12);
   2665              /* Select the Input and set the filter */
   2666              tmpccmr2 &=
   2667                  (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
   2668              tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   2669              tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   2670          
   2671              if ((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) || (TIMx == TIM4)
   2672                  || (TIMx == TIM5)) {
   2673                  /* Select the Polarity and set the CC4E Bit */
   2674                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
   2675                  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   2676              } else {
   2677                  /* Select the Polarity and set the CC4E Bit */
   2678                  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
   2679                  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
   2680              }
   2681              /* Write to TIMx CCMR2 and CCER registers */
   2682              TIMx->CCMR2 = tmpccmr2;
   2683              TIMx->CCER = tmpccer;
   2684          }
   2685          
   2686          /**
   2687            * @}
   2688            */
   2689          
   2690          /**
   2691            * @}
   2692            */
   2693          
   2694          /**
   2695            * @}
   2696            */
   2697          
   2698          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  TI1_Config
       16  TI2_Config
       16  TI3_Config
       16  TI4_Config
        0  TIM_ARRPreloadConfig
        0  TIM_BDTRConfig
        0  TIM_BDTRStructInit
        0  TIM_CCPreloadControl
        8  TIM_CCxCmd
        8  TIM_CCxNCmd
        0  TIM_ClearFlag
        0  TIM_ClearITPendingBit
        0  TIM_ClearOC1Ref
        0  TIM_ClearOC2Ref
        0  TIM_ClearOC3Ref
        0  TIM_ClearOC4Ref
        0  TIM_Cmd
        0  TIM_CounterModeConfig
        0  TIM_CtrlPWMOutputs
        0  TIM_DMACmd
        0  TIM_DMAConfig
        8  TIM_DeInit
              8 -> RCC_APB1PeriphResetCmd
              8 -> RCC_APB2PeriphResetCmd
       24  TIM_ETRClockMode1Config
             24 -> TIM_ETRConfig
       24  TIM_ETRClockMode2Config
             24 -> TIM_ETRConfig
        8  TIM_ETRConfig
       16  TIM_EncoderInterfaceConfig
        0  TIM_ForcedOC1Config
        0  TIM_ForcedOC2Config
        0  TIM_ForcedOC3Config
        0  TIM_ForcedOC4Config
        0  TIM_GenerateEvent
        0  TIM_GetCapture1
        0  TIM_GetCapture2
        0  TIM_GetCapture3
        0  TIM_GetCapture4
        0  TIM_GetCounter
        0  TIM_GetFlagStatus
        8  TIM_GetITStatus
        0  TIM_GetPrescaler
       16  TIM_ICInit
             16 -> TI1_Config
             16 -> TI2_Config
             16 -> TI3_Config
             16 -> TI4_Config
             16 -> TIM_SetIC1Prescaler
             16 -> TIM_SetIC2Prescaler
             16 -> TIM_SetIC3Prescaler
             16 -> TIM_SetIC4Prescaler
        0  TIM_ICStructInit
        0  TIM_ITConfig
       16  TIM_ITRxExternalClockConfig
             16 -> TIM_SelectInputTrigger
        0  TIM_InternalClockConfig
        0  TIM_OC1FastConfig
       12  TIM_OC1Init
        0  TIM_OC1NPolarityConfig
        0  TIM_OC1PolarityConfig
        0  TIM_OC1PreloadConfig
        0  TIM_OC2FastConfig
       12  TIM_OC2Init
        0  TIM_OC2NPolarityConfig
        0  TIM_OC2PolarityConfig
        0  TIM_OC2PreloadConfig
        0  TIM_OC3FastConfig
       12  TIM_OC3Init
        0  TIM_OC3NPolarityConfig
        0  TIM_OC3PolarityConfig
        0  TIM_OC3PreloadConfig
        0  TIM_OC4FastConfig
       12  TIM_OC4Init
        0  TIM_OC4PolarityConfig
        0  TIM_OC4PreloadConfig
        0  TIM_OCStructInit
       24  TIM_PWMIConfig
             24 -> TI1_Config
             24 -> TI2_Config
             24 -> TIM_SetIC1Prescaler
             24 -> TIM_SetIC2Prescaler
        0  TIM_PrescalerConfig
        0  TIM_SelectCCDMA
        0  TIM_SelectCOM
        0  TIM_SelectHallSensor
        0  TIM_SelectInputTrigger
        0  TIM_SelectMasterSlaveMode
       12  TIM_SelectOCxM
        0  TIM_SelectOnePulseMode
        0  TIM_SelectOutputTrigger
        0  TIM_SelectSlaveMode
        0  TIM_SetAutoreload
        0  TIM_SetClockDivision
        0  TIM_SetCompare1
        0  TIM_SetCompare2
        0  TIM_SetCompare3
        0  TIM_SetCompare4
        0  TIM_SetCounter
        0  TIM_SetIC1Prescaler
        0  TIM_SetIC2Prescaler
        0  TIM_SetIC3Prescaler
        0  TIM_SetIC4Prescaler
       24  TIM_TIxExternalClockConfig
             24 -> TI1_Config
             24 -> TI2_Config
             24 -> TIM_SelectInputTrigger
        0  TIM_TimeBaseInit
        0  TIM_TimeBaseStructInit
        0  TIM_UpdateDisableConfig
        0  TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
     106  TI1_Config
     116  TI2_Config
     114  TI3_Config
     116  TI4_Config
      28  TIM_ARRPreloadConfig
      32  TIM_BDTRConfig
      30  TIM_BDTRStructInit
      28  TIM_CCPreloadControl
      32  TIM_CCxCmd
      32  TIM_CCxNCmd
       8  TIM_ClearFlag
       8  TIM_ClearITPendingBit
      18  TIM_ClearOC1Ref
      18  TIM_ClearOC2Ref
      18  TIM_ClearOC3Ref
      18  TIM_ClearOC4Ref
      28  TIM_Cmd
      18  TIM_CounterModeConfig
      34  TIM_CtrlPWMOutputs
      22  TIM_DMACmd
      10  TIM_DMAConfig
     480  TIM_DeInit
      70  TIM_ETRClockMode1Config
      38  TIM_ETRClockMode2Config
      24  TIM_ETRConfig
      62  TIM_EncoderInterfaceConfig
      18  TIM_ForcedOC1Config
      20  TIM_ForcedOC2Config
      18  TIM_ForcedOC3Config
      20  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       6  TIM_GetCapture4
       4  TIM_GetCounter
      24  TIM_GetFlagStatus
      50  TIM_GetITStatus
       4  TIM_GetPrescaler
     160  TIM_ICInit
      22  TIM_ICStructInit
      22  TIM_ITConfig
      26  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      18  TIM_OC1FastConfig
     154  TIM_OC1Init
      18  TIM_OC1NPolarityConfig
      18  TIM_OC1PolarityConfig
      18  TIM_OC1PreloadConfig
      20  TIM_OC2FastConfig
     144  TIM_OC2Init
      20  TIM_OC2NPolarityConfig
      20  TIM_OC2PolarityConfig
      20  TIM_OC2PreloadConfig
      18  TIM_OC3FastConfig
     142  TIM_OC3Init
      20  TIM_OC3NPolarityConfig
      20  TIM_OC3PolarityConfig
      18  TIM_OC3PreloadConfig
      20  TIM_OC4FastConfig
     110  TIM_OC4Init
      20  TIM_OC4PolarityConfig
      20  TIM_OC4PreloadConfig
      34  TIM_OCStructInit
     140  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      28  TIM_SelectCCDMA
      28  TIM_SelectCOM
      28  TIM_SelectHallSensor
      18  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
      92  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      18  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       6  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
      70  TIM_TIxExternalClockConfig
     148  TIM_TimeBaseInit
      24  TIM_TimeBaseStructInit
      28  TIM_UpdateDisableConfig
      28  TIM_UpdateRequestConfig

 
 3 716 bytes in section .text
 
 3 716 bytes of CODE memory

Errors: none
Warnings: none
