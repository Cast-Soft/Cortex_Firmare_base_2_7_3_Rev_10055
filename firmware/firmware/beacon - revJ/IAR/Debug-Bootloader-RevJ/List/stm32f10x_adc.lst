###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     29/Oct/2019  16:43:11 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_adc.c                        #
#    Command line =  "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_adc.c" -D BEACON_APP -D      #
#                    USE_STDPERIPH_DRIVER -D STM32F10X_CL -D COOS -D          #
#                    USE_MY_ASSERT -D _DEBUG -D BOOTLOADER -D EE_M24C02 -D    #
#                    TASKS_PROFILE -D BATTERY_CHECK -D CCA_EN_NO -D           #
#                    NEW_BEACON -D USE_TIM4 -D WDT_ENABLE -D OLD_CONFIG -D    #
#                    CIRCULAR_LOG -D BC_HW_REVJ -lcN                          #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\" -o                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\App\" -I "C:\Users\kmak\Documents\Cortex_Git #
#                    \BLKT-01\Source Code\BLKT-01                             #
#                    Beacon\Source\firmware\beacon -                          #
#                    revJ\IAR\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F1 #
#                    0x\" -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Sour #
#                    ce Code\BLKT-01 Beacon\Source\firmware\beacon -          #
#                    revJ\IAR\..\..\common\STM32F10x_StdPeriph_Driver\inc\"   #
#                    -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\kernel\" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\portable\" -I                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\..\common\" -I                            #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\USB-Device-CDC\" -I                #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\" -I "C:\Users\kmak\Documents\Cort #
#                    ex_Git\BLKT-01\Source Code\BLKT-01                       #
#                    Beacon\Source\firmware\beacon - revJ\IAR\" -On           #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\stm32f10x_adc.lst    #
#    Object file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\stm32f10x_adc.o       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_StdPeriph_Driver\src\stm32f10x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_adc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the ADC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_adc.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup ADC 
     31            * @brief ADC driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup ADC_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup ADC_Private_Defines
     44            * @{
     45            */
     46          
     47          /* ADC DISCNUM mask */
     48          #define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
     49          
     50          /* ADC DISCEN mask */
     51          #define CR1_DISCEN_Set              ((uint32_t)0x00000800)
     52          #define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
     53          
     54          /* ADC JAUTO mask */
     55          #define CR1_JAUTO_Set               ((uint32_t)0x00000400)
     56          #define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
     57          
     58          /* ADC JDISCEN mask */
     59          #define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
     60          #define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
     61          
     62          /* ADC AWDCH mask */
     63          #define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
     64          
     65          /* ADC Analog watchdog enable mode mask */
     66          #define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
     67          
     68          /* CR1 register Mask */
     69          #define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
     70          
     71          /* ADC ADON mask */
     72          #define CR2_ADON_Set                ((uint32_t)0x00000001)
     73          #define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
     74          
     75          /* ADC DMA mask */
     76          #define CR2_DMA_Set                 ((uint32_t)0x00000100)
     77          #define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
     78          
     79          /* ADC RSTCAL mask */
     80          #define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
     81          
     82          /* ADC CAL mask */
     83          #define CR2_CAL_Set                 ((uint32_t)0x00000004)
     84          
     85          /* ADC SWSTART mask */
     86          #define CR2_SWSTART_Set             ((uint32_t)0x00400000)
     87          
     88          /* ADC EXTTRIG mask */
     89          #define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
     90          #define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
     91          
     92          /* ADC Software start mask */
     93          #define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
     94          #define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
     95          
     96          /* ADC JEXTSEL mask */
     97          #define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
     98          
     99          /* ADC JEXTTRIG mask */
    100          #define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
    101          #define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
    102          
    103          /* ADC JSWSTART mask */
    104          #define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
    105          
    106          /* ADC injected software start mask */
    107          #define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
    108          #define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
    109          
    110          /* ADC TSPD mask */
    111          #define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
    112          #define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
    113          
    114          /* CR2 register Mask */
    115          #define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
    116          
    117          /* ADC SQx mask */
    118          #define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
    119          #define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
    120          #define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
    121          
    122          /* SQR1 register Mask */
    123          #define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
    124          
    125          /* ADC JSQx mask */
    126          #define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
    127          
    128          /* ADC JL mask */
    129          #define JSQR_JL_Set                 ((uint32_t)0x00300000)
    130          #define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
    131          
    132          /* ADC SMPx mask */
    133          #define SMPR1_SMP_Set               ((uint32_t)0x00000007)
    134          #define SMPR2_SMP_Set               ((uint32_t)0x00000007)
    135          
    136          /* ADC JDRx registers offset */
    137          #define JDR_Offset                  ((uint8_t)0x28)
    138          
    139          /* ADC1 DR register base address */
    140          #define DR_ADDRESS                  ((uint32_t)0x4001244C)
    141          
    142          /**
    143            * @}
    144            */
    145          
    146          /** @defgroup ADC_Private_Macros
    147            * @{
    148            */
    149          
    150          /**
    151            * @}
    152            */
    153          
    154          /** @defgroup ADC_Private_Variables
    155            * @{
    156            */
    157          
    158          /**
    159            * @}
    160            */
    161          
    162          /** @defgroup ADC_Private_FunctionPrototypes
    163            * @{
    164            */
    165          
    166          /**
    167            * @}
    168            */
    169          
    170          /** @defgroup ADC_Private_Functions
    171            * @{
    172            */
    173          
    174          /**
    175            * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
    176            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    177            * @retval None
    178            */
    179          
    180          void ADC_DeInit(ADC_TypeDef *ADCx) {
    181              /* Check the parameters */
    182              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    183          
    184              if (ADCx == ADC1) {
    185                  /* Enable ADC1 reset state */
    186                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
    187                  /* Release ADC1 from reset state */
    188                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
    189              } else if (ADCx == ADC2) {
    190                  /* Enable ADC2 reset state */
    191                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
    192                  /* Release ADC2 from reset state */
    193                  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
    194              } else {
    195                  if (ADCx == ADC3) {
    196                      /* Enable ADC3 reset state */
    197                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
    198                      /* Release ADC3 from reset state */
    199                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
    200                  }
    201              }
    202          }
    203          
    204          /**
    205            * @brief  Initializes the ADCx peripheral according to the specified parameters
    206            *         in the ADC_InitStruct.
    207            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    208            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    209            *         the configuration information for the specified ADC peripheral.
    210            * @retval None
    211            */
    212          void ADC_Init(ADC_TypeDef *ADCx, ADC_InitTypeDef *ADC_InitStruct) {
    213              uint32_t tmpreg1 = 0;
    214              uint8_t tmpreg2 = 0;
    215              /* Check the parameters */
    216              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    217              assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
    218              assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    219              assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
    220              assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));
    221              assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
    222              assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
    223          
    224              /*---------------------------- ADCx CR1 Configuration -----------------*/
    225              /* Get the ADCx CR1 value */
    226              tmpreg1 = ADCx->CR1;
    227              /* Clear DUALMOD and SCAN bits */
    228              tmpreg1 &= CR1_CLEAR_Mask;
    229              /* Configure ADCx: Dual mode and scan conversion mode */
    230              /* Set DUALMOD bits according to ADC_Mode value */
    231              /* Set SCAN bit according to ADC_ScanConvMode value */
    232              tmpreg1 |=
    233                  (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
    234              /* Write to ADCx CR1 */
    235              ADCx->CR1 = tmpreg1;
    236          
    237              /*---------------------------- ADCx CR2 Configuration -----------------*/
    238              /* Get the ADCx CR2 value */
    239              tmpreg1 = ADCx->CR2;
    240              /* Clear CONT, ALIGN and EXTSEL bits */
    241              tmpreg1 &= CR2_CLEAR_Mask;
    242              /* Configure ADCx: external trigger event and continuous conversion mode */
    243              /* Set ALIGN bit according to ADC_DataAlign value */
    244              /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    245              /* Set CONT bit according to ADC_ContinuousConvMode value */
    246              tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv
    247                  | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    248              /* Write to ADCx CR2 */
    249              ADCx->CR2 = tmpreg1;
    250          
    251              /*---------------------------- ADCx SQR1 Configuration -----------------*/
    252              /* Get the ADCx SQR1 value */
    253              tmpreg1 = ADCx->SQR1;
    254              /* Clear L bits */
    255              tmpreg1 &= SQR1_CLEAR_Mask;
    256              /* Configure ADCx: regular channel sequence length */
    257              /* Set L bits according to ADC_NbrOfChannel value */
    258              tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
    259              tmpreg1 |= (uint32_t)tmpreg2 << 20;
    260              /* Write to ADCx SQR1 */
    261              ADCx->SQR1 = tmpreg1;
    262          }
    263          
    264          /**
    265            * @brief  Fills each ADC_InitStruct member with its default value.
    266            * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
    267            * @retval None
    268            */
    269          void ADC_StructInit(ADC_InitTypeDef *ADC_InitStruct) {
    270              /* Reset ADC init structure parameters values */
    271              /* Initialize the ADC_Mode member */
    272              ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
    273              /* initialize the ADC_ScanConvMode member */
    274              ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    275              /* Initialize the ADC_ContinuousConvMode member */
    276              ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    277              /* Initialize the ADC_ExternalTrigConv member */
    278              ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    279              /* Initialize the ADC_DataAlign member */
    280              ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    281              /* Initialize the ADC_NbrOfChannel member */
    282              ADC_InitStruct->ADC_NbrOfChannel = 1;
    283          }
    284          
    285          /**
    286            * @brief  Enables or disables the specified ADC peripheral.
    287            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    288            * @param  NewState: new state of the ADCx peripheral.
    289            *   This parameter can be: ENABLE or DISABLE.
    290            * @retval None
    291            */
    292          void ADC_Cmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    293              /* Check the parameters */
    294              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    295              assert_param(IS_FUNCTIONAL_STATE(NewState));
    296          
    297              if (NewState != DISABLE) {
    298                  /* Set the ADON bit to wake up the ADC from power down mode */
    299                  ADCx->CR2 |= CR2_ADON_Set;
    300              } else {
    301                  /* Disable the selected ADC peripheral */
    302                  ADCx->CR2 &= CR2_ADON_Reset;
    303              }
    304          }
    305          
    306          /**
    307            * @brief  Enables or disables the specified ADC DMA request.
    308            * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
    309            *   Note: ADC2 hasn't a DMA capability.
    310            * @param  NewState: new state of the selected ADC DMA transfer.
    311            *   This parameter can be: ENABLE or DISABLE.
    312            * @retval None
    313            */
    314          void ADC_DMACmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    315              /* Check the parameters */
    316              assert_param(IS_ADC_DMA_PERIPH(ADCx));
    317              assert_param(IS_FUNCTIONAL_STATE(NewState));
    318          
    319              if (NewState != DISABLE) {
    320                  /* Enable the selected ADC DMA request */
    321                  ADCx->CR2 |= CR2_DMA_Set;
    322              } else {
    323                  /* Disable the selected ADC DMA request */
    324                  ADCx->CR2 &= CR2_DMA_Reset;
    325              }
    326          }
    327          
    328          /**
    329            * @brief  Enables or disables the specified ADC interrupts.
    330            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    331            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
    332            *   This parameter can be any combination of the following values:
    333            *     @arg ADC_IT_EOC: End of conversion interrupt mask
    334            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
    335            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
    336            * @param  NewState: new state of the specified ADC interrupts.
    337            *   This parameter can be: ENABLE or DISABLE.
    338            * @retval None
    339            */
    340          void ADC_ITConfig(ADC_TypeDef *ADCx, uint16_t ADC_IT, FunctionalState NewState) {
    341              uint8_t itmask = 0;
    342              /* Check the parameters */
    343              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    344              assert_param(IS_FUNCTIONAL_STATE(NewState));
    345              assert_param(IS_ADC_IT(ADC_IT));
    346              /* Get the ADC IT index */
    347              itmask = (uint8_t)ADC_IT;
    348          
    349              if (NewState != DISABLE) {
    350                  /* Enable the selected ADC interrupts */
    351                  ADCx->CR1 |= itmask;
    352              } else {
    353                  /* Disable the selected ADC interrupts */
    354                  ADCx->CR1 &= (~(uint32_t)itmask);
    355              }
    356          }
    357          
    358          /**
    359            * @brief  Resets the selected ADC calibration registers.
    360            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    361            * @retval None
    362            */
    363          void ADC_ResetCalibration(ADC_TypeDef *ADCx) {
    364              /* Check the parameters */
    365              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    366              /* Resets the selected ADC calibration registers */
    367              ADCx->CR2 |= CR2_RSTCAL_Set;
    368          }
    369          
    370          /**
    371            * @brief  Gets the selected ADC reset calibration registers status.
    372            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    373            * @retval The new state of ADC reset calibration registers (SET or RESET).
    374            */
    375          FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef *ADCx) {
    376              FlagStatus bitstatus = RESET;
    377              /* Check the parameters */
    378              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    379              /* Check the status of RSTCAL bit */
    380              if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET) {
    381                  /* RSTCAL bit is set */
    382                  bitstatus = SET;
    383              } else {
    384                  /* RSTCAL bit is reset */
    385                  bitstatus = RESET;
    386              }
    387              /* Return the RSTCAL bit status */
    388              return bitstatus;
    389          }
    390          
    391          /**
    392            * @brief  Starts the selected ADC calibration process.
    393            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    394            * @retval None
    395            */
    396          void ADC_StartCalibration(ADC_TypeDef *ADCx) {
    397              /* Check the parameters */
    398              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    399              /* Enable the selected ADC calibration process */
    400              ADCx->CR2 |= CR2_CAL_Set;
    401          }
    402          
    403          /**
    404            * @brief  Gets the selected ADC calibration status.
    405            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    406            * @retval The new state of ADC calibration (SET or RESET).
    407            */
    408          FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef *ADCx) {
    409              FlagStatus bitstatus = RESET;
    410              /* Check the parameters */
    411              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    412              /* Check the status of CAL bit */
    413              if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET) {
    414                  /* CAL bit is set: calibration on going */
    415                  bitstatus = SET;
    416              } else {
    417                  /* CAL bit is reset: end of calibration */
    418                  bitstatus = RESET;
    419              }
    420              /* Return the CAL bit status */
    421              return bitstatus;
    422          }
    423          
    424          /**
    425            * @brief  Enables or disables the selected ADC software start conversion .
    426            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    427            * @param  NewState: new state of the selected ADC software start conversion.
    428            *   This parameter can be: ENABLE or DISABLE.
    429            * @retval None
    430            */
    431          void ADC_SoftwareStartConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    432              /* Check the parameters */
    433              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    434              assert_param(IS_FUNCTIONAL_STATE(NewState));
    435          
    436              if (NewState != DISABLE) {
    437                  /* Enable the selected ADC conversion on external event and start the selected
    438                     ADC conversion */
    439                  ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
    440              } else {
    441                  /* Disable the selected ADC conversion on external event and stop the selected
    442                     ADC conversion */
    443                  ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
    444              }
    445          }
    446          
    447          /**
    448            * @brief  Gets the selected ADC Software start conversion Status.
    449            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    450            * @retval The new state of ADC software start conversion (SET or RESET).
    451            */
    452          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef *ADCx) {
    453              FlagStatus bitstatus = RESET;
    454              /* Check the parameters */
    455              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    456              /* Check the status of SWSTART bit */
    457              if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET) {
    458                  /* SWSTART bit is set */
    459                  bitstatus = SET;
    460              } else {
    461                  /* SWSTART bit is reset */
    462                  bitstatus = RESET;
    463              }
    464              /* Return the SWSTART bit status */
    465              return bitstatus;
    466          }
    467          
    468          /**
    469            * @brief  Configures the discontinuous mode for the selected ADC regular
    470            *         group channel.
    471            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    472            * @param  Number: specifies the discontinuous mode regular channel
    473            *         count value. This number must be between 1 and 8.
    474            * @retval None
    475            */
    476          void ADC_DiscModeChannelCountConfig(ADC_TypeDef *ADCx, uint8_t Number) {
    477              uint32_t tmpreg1 = 0;
    478              uint32_t tmpreg2 = 0;
    479              /* Check the parameters */
    480              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    481              assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    482              /* Get the old register value */
    483              tmpreg1 = ADCx->CR1;
    484              /* Clear the old discontinuous mode channel count */
    485              tmpreg1 &= CR1_DISCNUM_Reset;
    486              /* Set the discontinuous mode channel count */
    487              tmpreg2 = Number - 1;
    488              tmpreg1 |= tmpreg2 << 13;
    489              /* Store the new register value */
    490              ADCx->CR1 = tmpreg1;
    491          }
    492          
    493          /**
    494            * @brief  Enables or disables the discontinuous mode on regular group
    495            *         channel for the specified ADC
    496            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    497            * @param  NewState: new state of the selected ADC discontinuous mode
    498            *         on regular group channel.
    499            *         This parameter can be: ENABLE or DISABLE.
    500            * @retval None
    501            */
    502          void ADC_DiscModeCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    503              /* Check the parameters */
    504              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    505              assert_param(IS_FUNCTIONAL_STATE(NewState));
    506          
    507              if (NewState != DISABLE) {
    508                  /* Enable the selected ADC regular discontinuous mode */
    509                  ADCx->CR1 |= CR1_DISCEN_Set;
    510              } else {
    511                  /* Disable the selected ADC regular discontinuous mode */
    512                  ADCx->CR1 &= CR1_DISCEN_Reset;
    513              }
    514          }
    515          
    516          /**
    517            * @brief  Configures for the selected ADC regular channel its corresponding
    518            *         rank in the sequencer and its sample time.
    519            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    520            * @param  ADC_Channel: the ADC channel to configure. 
    521            *   This parameter can be one of the following values:
    522            *     @arg ADC_Channel_0: ADC Channel0 selected
    523            *     @arg ADC_Channel_1: ADC Channel1 selected
    524            *     @arg ADC_Channel_2: ADC Channel2 selected
    525            *     @arg ADC_Channel_3: ADC Channel3 selected
    526            *     @arg ADC_Channel_4: ADC Channel4 selected
    527            *     @arg ADC_Channel_5: ADC Channel5 selected
    528            *     @arg ADC_Channel_6: ADC Channel6 selected
    529            *     @arg ADC_Channel_7: ADC Channel7 selected
    530            *     @arg ADC_Channel_8: ADC Channel8 selected
    531            *     @arg ADC_Channel_9: ADC Channel9 selected
    532            *     @arg ADC_Channel_10: ADC Channel10 selected
    533            *     @arg ADC_Channel_11: ADC Channel11 selected
    534            *     @arg ADC_Channel_12: ADC Channel12 selected
    535            *     @arg ADC_Channel_13: ADC Channel13 selected
    536            *     @arg ADC_Channel_14: ADC Channel14 selected
    537            *     @arg ADC_Channel_15: ADC Channel15 selected
    538            *     @arg ADC_Channel_16: ADC Channel16 selected
    539            *     @arg ADC_Channel_17: ADC Channel17 selected
    540            * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
    541            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    542            *   This parameter can be one of the following values:
    543            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    544            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    545            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    546            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    547            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    548            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    549            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    550            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    551            * @retval None
    552            */
    553          void ADC_RegularChannelConfig(ADC_TypeDef *ADCx, uint8_t ADC_Channel, uint8_t Rank,
    554              uint8_t ADC_SampleTime) {
    555              uint32_t tmpreg1 = 0, tmpreg2 = 0;
    556              /* Check the parameters */
    557              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    558              assert_param(IS_ADC_CHANNEL(ADC_Channel));
    559              assert_param(IS_ADC_REGULAR_RANK(Rank));
    560              assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    561              /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    562              if (ADC_Channel > ADC_Channel_9) {
    563                  /* Get the old register value */
    564                  tmpreg1 = ADCx->SMPR1;
    565                  /* Calculate the mask to clear */
    566                  tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    567                  /* Clear the old channel sample time */
    568                  tmpreg1 &= ~tmpreg2;
    569                  /* Calculate the mask to set */
    570                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    571                  /* Set the new channel sample time */
    572                  tmpreg1 |= tmpreg2;
    573                  /* Store the new register value */
    574                  ADCx->SMPR1 = tmpreg1;
    575              } else /* ADC_Channel include in ADC_Channel_[0..9] */
    576              {
    577                  /* Get the old register value */
    578                  tmpreg1 = ADCx->SMPR2;
    579                  /* Calculate the mask to clear */
    580                  tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    581                  /* Clear the old channel sample time */
    582                  tmpreg1 &= ~tmpreg2;
    583                  /* Calculate the mask to set */
    584                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    585                  /* Set the new channel sample time */
    586                  tmpreg1 |= tmpreg2;
    587                  /* Store the new register value */
    588                  ADCx->SMPR2 = tmpreg1;
    589              }
    590              /* For Rank 1 to 6 */
    591              if (Rank < 7) {
    592                  /* Get the old register value */
    593                  tmpreg1 = ADCx->SQR3;
    594                  /* Calculate the mask to clear */
    595                  tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    596                  /* Clear the old SQx bits for the selected rank */
    597                  tmpreg1 &= ~tmpreg2;
    598                  /* Calculate the mask to set */
    599                  tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    600                  /* Set the SQx bits for the selected rank */
    601                  tmpreg1 |= tmpreg2;
    602                  /* Store the new register value */
    603                  ADCx->SQR3 = tmpreg1;
    604              }
    605              /* For Rank 7 to 12 */
    606              else if (Rank < 13) {
    607                  /* Get the old register value */
    608                  tmpreg1 = ADCx->SQR2;
    609                  /* Calculate the mask to clear */
    610                  tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    611                  /* Clear the old SQx bits for the selected rank */
    612                  tmpreg1 &= ~tmpreg2;
    613                  /* Calculate the mask to set */
    614                  tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    615                  /* Set the SQx bits for the selected rank */
    616                  tmpreg1 |= tmpreg2;
    617                  /* Store the new register value */
    618                  ADCx->SQR2 = tmpreg1;
    619              }
    620              /* For Rank 13 to 16 */
    621              else {
    622                  /* Get the old register value */
    623                  tmpreg1 = ADCx->SQR1;
    624                  /* Calculate the mask to clear */
    625                  tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    626                  /* Clear the old SQx bits for the selected rank */
    627                  tmpreg1 &= ~tmpreg2;
    628                  /* Calculate the mask to set */
    629                  tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    630                  /* Set the SQx bits for the selected rank */
    631                  tmpreg1 |= tmpreg2;
    632                  /* Store the new register value */
    633                  ADCx->SQR1 = tmpreg1;
    634              }
    635          }
    636          
    637          /**
    638            * @brief  Enables or disables the ADCx conversion through external trigger.
    639            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    640            * @param  NewState: new state of the selected ADC external trigger start of conversion.
    641            *   This parameter can be: ENABLE or DISABLE.
    642            * @retval None
    643            */
    644          void ADC_ExternalTrigConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    645              /* Check the parameters */
    646              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    647              assert_param(IS_FUNCTIONAL_STATE(NewState));
    648          
    649              if (NewState != DISABLE) {
    650                  /* Enable the selected ADC conversion on external event */
    651                  ADCx->CR2 |= CR2_EXTTRIG_Set;
    652              } else {
    653                  /* Disable the selected ADC conversion on external event */
    654                  ADCx->CR2 &= CR2_EXTTRIG_Reset;
    655              }
    656          }
    657          
    658          /**
    659            * @brief  Returns the last ADCx conversion result data for regular channel.
    660            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    661            * @retval The Data conversion value.
    662            */
    663          uint16_t ADC_GetConversionValue(ADC_TypeDef *ADCx) {
    664              /* Check the parameters */
    665              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    666              /* Return the selected ADC conversion value */
    667              return (uint16_t)ADCx->DR;
    668          }
    669          
    670          /**
    671            * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
    672            * @retval The Data conversion value.
    673            */
    674          uint32_t ADC_GetDualModeConversionValue(void) {
    675              /* Return the dual mode conversion value */
    676              return (*(__IO uint32_t *)DR_ADDRESS);
    677          }
    678          
    679          /**
    680            * @brief  Enables or disables the selected ADC automatic injected group
    681            *         conversion after regular one.
    682            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    683            * @param  NewState: new state of the selected ADC auto injected conversion
    684            *   This parameter can be: ENABLE or DISABLE.
    685            * @retval None
    686            */
    687          void ADC_AutoInjectedConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    688              /* Check the parameters */
    689              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    690              assert_param(IS_FUNCTIONAL_STATE(NewState));
    691          
    692              if (NewState != DISABLE) {
    693                  /* Enable the selected ADC automatic injected group conversion */
    694                  ADCx->CR1 |= CR1_JAUTO_Set;
    695              } else {
    696                  /* Disable the selected ADC automatic injected group conversion */
    697                  ADCx->CR1 &= CR1_JAUTO_Reset;
    698              }
    699          }
    700          
    701          /**
    702            * @brief  Enables or disables the discontinuous mode for injected group
    703            *         channel for the specified ADC
    704            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    705            * @param  NewState: new state of the selected ADC discontinuous mode
    706            *         on injected group channel.
    707            *   This parameter can be: ENABLE or DISABLE.
    708            * @retval None
    709            */
    710          void ADC_InjectedDiscModeCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    711              /* Check the parameters */
    712              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    713              assert_param(IS_FUNCTIONAL_STATE(NewState));
    714          
    715              if (NewState != DISABLE) {
    716                  /* Enable the selected ADC injected discontinuous mode */
    717                  ADCx->CR1 |= CR1_JDISCEN_Set;
    718              } else {
    719                  /* Disable the selected ADC injected discontinuous mode */
    720                  ADCx->CR1 &= CR1_JDISCEN_Reset;
    721              }
    722          }
    723          
    724          /**
    725            * @brief  Configures the ADCx external trigger for injected channels conversion.
    726            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    727            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion. 
    728            *   This parameter can be one of the following values:
    729            *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
    730            *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
    731            *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
    732            *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
    733            *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
    734            *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
    735            *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
    736            *                                                       capture compare4 event selected (for ADC1 and ADC2)                       
    737            *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
    738            *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)                         
    739            *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
    740            *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)                         
    741            *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)                        
    742            *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
    743            *                                          by external trigger (for ADC1, ADC2 and ADC3)
    744            * @retval None
    745            */
    746          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef *ADCx, uint32_t ADC_ExternalTrigInjecConv) {
    747              uint32_t tmpreg = 0;
    748              /* Check the parameters */
    749              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    750              assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
    751              /* Get the old register value */
    752              tmpreg = ADCx->CR2;
    753              /* Clear the old external event selection for injected group */
    754              tmpreg &= CR2_JEXTSEL_Reset;
    755              /* Set the external event selection for injected group */
    756              tmpreg |= ADC_ExternalTrigInjecConv;
    757              /* Store the new register value */
    758              ADCx->CR2 = tmpreg;
    759          }
    760          
    761          /**
    762            * @brief  Enables or disables the ADCx injected channels conversion through
    763            *         external trigger
    764            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    765            * @param  NewState: new state of the selected ADC external trigger start of
    766            *         injected conversion.
    767            *   This parameter can be: ENABLE or DISABLE.
    768            * @retval None
    769            */
    770          void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    771              /* Check the parameters */
    772              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    773              assert_param(IS_FUNCTIONAL_STATE(NewState));
    774          
    775              if (NewState != DISABLE) {
    776                  /* Enable the selected ADC external event selection for injected group */
    777                  ADCx->CR2 |= CR2_JEXTTRIG_Set;
    778              } else {
    779                  /* Disable the selected ADC external event selection for injected group */
    780                  ADCx->CR2 &= CR2_JEXTTRIG_Reset;
    781              }
    782          }
    783          
    784          /**
    785            * @brief  Enables or disables the selected ADC start of the injected 
    786            *         channels conversion.
    787            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    788            * @param  NewState: new state of the selected ADC software start injected conversion.
    789            *   This parameter can be: ENABLE or DISABLE.
    790            * @retval None
    791            */
    792          void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef *ADCx, FunctionalState NewState) {
    793              /* Check the parameters */
    794              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    795              assert_param(IS_FUNCTIONAL_STATE(NewState));
    796          
    797              if (NewState != DISABLE) {
    798          /* Enable the selected ADC conversion for injected group on external event and start the selected
    799             ADC injected conversion */
    800                  ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
    801              } else {
    802          /* Disable the selected ADC conversion on external event for injected group and stop the selected
    803             ADC injected conversion */
    804                  ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
    805              }
    806          }
    807          
    808          /**
    809            * @brief  Gets the selected ADC Software start injected conversion Status.
    810            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    811            * @retval The new state of ADC software start injected conversion (SET or RESET).
    812            */
    813          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef *ADCx) {
    814              FlagStatus bitstatus = RESET;
    815              /* Check the parameters */
    816              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    817              /* Check the status of JSWSTART bit */
    818              if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET) {
    819                  /* JSWSTART bit is set */
    820                  bitstatus = SET;
    821              } else {
    822                  /* JSWSTART bit is reset */
    823                  bitstatus = RESET;
    824              }
    825              /* Return the JSWSTART bit status */
    826              return bitstatus;
    827          }
    828          
    829          /**
    830            * @brief  Configures for the selected ADC injected channel its corresponding
    831            *         rank in the sequencer and its sample time.
    832            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    833            * @param  ADC_Channel: the ADC channel to configure. 
    834            *   This parameter can be one of the following values:
    835            *     @arg ADC_Channel_0: ADC Channel0 selected
    836            *     @arg ADC_Channel_1: ADC Channel1 selected
    837            *     @arg ADC_Channel_2: ADC Channel2 selected
    838            *     @arg ADC_Channel_3: ADC Channel3 selected
    839            *     @arg ADC_Channel_4: ADC Channel4 selected
    840            *     @arg ADC_Channel_5: ADC Channel5 selected
    841            *     @arg ADC_Channel_6: ADC Channel6 selected
    842            *     @arg ADC_Channel_7: ADC Channel7 selected
    843            *     @arg ADC_Channel_8: ADC Channel8 selected
    844            *     @arg ADC_Channel_9: ADC Channel9 selected
    845            *     @arg ADC_Channel_10: ADC Channel10 selected
    846            *     @arg ADC_Channel_11: ADC Channel11 selected
    847            *     @arg ADC_Channel_12: ADC Channel12 selected
    848            *     @arg ADC_Channel_13: ADC Channel13 selected
    849            *     @arg ADC_Channel_14: ADC Channel14 selected
    850            *     @arg ADC_Channel_15: ADC Channel15 selected
    851            *     @arg ADC_Channel_16: ADC Channel16 selected
    852            *     @arg ADC_Channel_17: ADC Channel17 selected
    853            * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
    854            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    855            *   This parameter can be one of the following values:
    856            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    857            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    858            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    859            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    860            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    861            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    862            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    863            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    864            * @retval None
    865            */
    866          void ADC_InjectedChannelConfig(ADC_TypeDef *ADCx, uint8_t ADC_Channel, uint8_t Rank,
    867              uint8_t ADC_SampleTime) {
    868              uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
    869              /* Check the parameters */
    870              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    871              assert_param(IS_ADC_CHANNEL(ADC_Channel));
    872              assert_param(IS_ADC_INJECTED_RANK(Rank));
    873              assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    874              /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    875              if (ADC_Channel > ADC_Channel_9) {
    876                  /* Get the old register value */
    877                  tmpreg1 = ADCx->SMPR1;
    878                  /* Calculate the mask to clear */
    879                  tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    880                  /* Clear the old channel sample time */
    881                  tmpreg1 &= ~tmpreg2;
    882                  /* Calculate the mask to set */
    883                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    884                  /* Set the new channel sample time */
    885                  tmpreg1 |= tmpreg2;
    886                  /* Store the new register value */
    887                  ADCx->SMPR1 = tmpreg1;
    888              } else /* ADC_Channel include in ADC_Channel_[0..9] */
    889              {
    890                  /* Get the old register value */
    891                  tmpreg1 = ADCx->SMPR2;
    892                  /* Calculate the mask to clear */
    893                  tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    894                  /* Clear the old channel sample time */
    895                  tmpreg1 &= ~tmpreg2;
    896                  /* Calculate the mask to set */
    897                  tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    898                  /* Set the new channel sample time */
    899                  tmpreg1 |= tmpreg2;
    900                  /* Store the new register value */
    901                  ADCx->SMPR2 = tmpreg1;
    902              }
    903              /* Rank configuration */
    904              /* Get the old register value */
    905              tmpreg1 = ADCx->JSQR;
    906              /* Get JL value: Number = JL+1 */
    907              tmpreg3 = (tmpreg1 & JSQR_JL_Set) >> 20;
    908              /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
    909              tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
    910              /* Clear the old JSQx bits for the selected rank */
    911              tmpreg1 &= ~tmpreg2;
    912              /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
    913              tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
    914              /* Set the JSQx bits for the selected rank */
    915              tmpreg1 |= tmpreg2;
    916              /* Store the new register value */
    917              ADCx->JSQR = tmpreg1;
    918          }
    919          
    920          /**
    921            * @brief  Configures the sequencer length for injected channels
    922            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    923            * @param  Length: The sequencer length. 
    924            *   This parameter must be a number between 1 to 4.
    925            * @retval None
    926            */
    927          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef *ADCx, uint8_t Length) {
    928              uint32_t tmpreg1 = 0;
    929              uint32_t tmpreg2 = 0;
    930              /* Check the parameters */
    931              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    932              assert_param(IS_ADC_INJECTED_LENGTH(Length));
    933          
    934              /* Get the old register value */
    935              tmpreg1 = ADCx->JSQR;
    936              /* Clear the old injected sequnence lenght JL bits */
    937              tmpreg1 &= JSQR_JL_Reset;
    938              /* Set the injected sequnence lenght JL bits */
    939              tmpreg2 = Length - 1;
    940              tmpreg1 |= tmpreg2 << 20;
    941              /* Store the new register value */
    942              ADCx->JSQR = tmpreg1;
    943          }
    944          
    945          /**
    946            * @brief  Set the injected channels conversion value offset
    947            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    948            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
    949            *   This parameter can be one of the following values:
    950            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
    951            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
    952            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
    953            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
    954            * @param  Offset: the offset value for the selected ADC injected channel
    955            *   This parameter must be a 12bit value.
    956            * @retval None
    957            */
    958          void ADC_SetInjectedOffset(ADC_TypeDef *ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset) {
    959              __IO uint32_t tmp = 0;
    960          
    961              /* Check the parameters */
    962              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    963              assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
    964              assert_param(IS_ADC_OFFSET(Offset));
    965          
    966              tmp = (uint32_t)ADCx;
    967              tmp += ADC_InjectedChannel;
    968          
    969              /* Set the selected injected channel data offset */
    970              *(__IO uint32_t *)tmp = (uint32_t)Offset;
    971          }
    972          
    973          /**
    974            * @brief  Returns the ADC injected channel conversion result
    975            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    976            * @param  ADC_InjectedChannel: the converted ADC injected channel.
    977            *   This parameter can be one of the following values:
    978            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
    979            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
    980            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
    981            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
    982            * @retval The Data conversion value.
    983            */
    984          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef *ADCx, uint8_t ADC_InjectedChannel) {
    985              __IO uint32_t tmp = 0;
    986          
    987              /* Check the parameters */
    988              assert_param(IS_ADC_ALL_PERIPH(ADCx));
    989              assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
    990          
    991              tmp = (uint32_t)ADCx;
    992              tmp += ADC_InjectedChannel + JDR_Offset;
    993          
    994              /* Returns the selected injected channel conversion data value */
    995              return (uint16_t)(*(__IO uint32_t *)tmp);
    996          }
    997          
    998          /**
    999            * @brief  Enables or disables the analog watchdog on single/all regular
   1000            *         or injected channels
   1001            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1002            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
   1003            *   This parameter can be one of the following values:
   1004            *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
   1005            *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
   1006            *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
   1007            *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
   1008            *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
   1009            *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
   1010            *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
   1011            * @retval None	  
   1012            */
   1013          void ADC_AnalogWatchdogCmd(ADC_TypeDef *ADCx, uint32_t ADC_AnalogWatchdog) {
   1014              uint32_t tmpreg = 0;
   1015              /* Check the parameters */
   1016              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1017              assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   1018              /* Get the old register value */
   1019              tmpreg = ADCx->CR1;
   1020              /* Clear AWDEN, AWDENJ and AWDSGL bits */
   1021              tmpreg &= CR1_AWDMode_Reset;
   1022              /* Set the analog watchdog enable mode */
   1023              tmpreg |= ADC_AnalogWatchdog;
   1024              /* Store the new register value */
   1025              ADCx->CR1 = tmpreg;
   1026          }
   1027          
   1028          /**
   1029            * @brief  Configures the high and low thresholds of the analog watchdog.
   1030            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1031            * @param  HighThreshold: the ADC analog watchdog High threshold value.
   1032            *   This parameter must be a 12bit value.
   1033            * @param  LowThreshold: the ADC analog watchdog Low threshold value.
   1034            *   This parameter must be a 12bit value.
   1035            * @retval None
   1036            */
   1037          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef *ADCx, uint16_t HighThreshold,
   1038              uint16_t LowThreshold) {
   1039              /* Check the parameters */
   1040              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1041              assert_param(IS_ADC_THRESHOLD(HighThreshold));
   1042              assert_param(IS_ADC_THRESHOLD(LowThreshold));
   1043              /* Set the ADCx high threshold */
   1044              ADCx->HTR = HighThreshold;
   1045              /* Set the ADCx low threshold */
   1046              ADCx->LTR = LowThreshold;
   1047          }
   1048          
   1049          /**
   1050            * @brief  Configures the analog watchdog guarded single channel
   1051            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1052            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
   1053            *   This parameter can be one of the following values:
   1054            *     @arg ADC_Channel_0: ADC Channel0 selected
   1055            *     @arg ADC_Channel_1: ADC Channel1 selected
   1056            *     @arg ADC_Channel_2: ADC Channel2 selected
   1057            *     @arg ADC_Channel_3: ADC Channel3 selected
   1058            *     @arg ADC_Channel_4: ADC Channel4 selected
   1059            *     @arg ADC_Channel_5: ADC Channel5 selected
   1060            *     @arg ADC_Channel_6: ADC Channel6 selected
   1061            *     @arg ADC_Channel_7: ADC Channel7 selected
   1062            *     @arg ADC_Channel_8: ADC Channel8 selected
   1063            *     @arg ADC_Channel_9: ADC Channel9 selected
   1064            *     @arg ADC_Channel_10: ADC Channel10 selected
   1065            *     @arg ADC_Channel_11: ADC Channel11 selected
   1066            *     @arg ADC_Channel_12: ADC Channel12 selected
   1067            *     @arg ADC_Channel_13: ADC Channel13 selected
   1068            *     @arg ADC_Channel_14: ADC Channel14 selected
   1069            *     @arg ADC_Channel_15: ADC Channel15 selected
   1070            *     @arg ADC_Channel_16: ADC Channel16 selected
   1071            *     @arg ADC_Channel_17: ADC Channel17 selected
   1072            * @retval None
   1073            */
   1074          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef *ADCx, uint8_t ADC_Channel) {
   1075              uint32_t tmpreg = 0;
   1076              /* Check the parameters */
   1077              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1078              assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1079              /* Get the old register value */
   1080              tmpreg = ADCx->CR1;
   1081              /* Clear the Analog watchdog channel select bits */
   1082              tmpreg &= CR1_AWDCH_Reset;
   1083              /* Set the Analog watchdog channel */
   1084              tmpreg |= ADC_Channel;
   1085              /* Store the new register value */
   1086              ADCx->CR1 = tmpreg;
   1087          }
   1088          
   1089          /**
   1090            * @brief  Enables or disables the temperature sensor and Vrefint channel.
   1091            * @param  NewState: new state of the temperature sensor.
   1092            *   This parameter can be: ENABLE or DISABLE.
   1093            * @retval None
   1094            */
   1095          void ADC_TempSensorVrefintCmd(FunctionalState NewState) {
   1096              /* Check the parameters */
   1097              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1098          
   1099              if (NewState != DISABLE) {
   1100                  /* Enable the temperature sensor and Vrefint channel*/
   1101                  ADC1->CR2 |= CR2_TSVREFE_Set;
   1102              } else {
   1103                  /* Disable the temperature sensor and Vrefint channel*/
   1104                  ADC1->CR2 &= CR2_TSVREFE_Reset;
   1105              }
   1106          }
   1107          
   1108          /**
   1109            * @brief  Checks whether the specified ADC flag is set or not.
   1110            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1111            * @param  ADC_FLAG: specifies the flag to check. 
   1112            *   This parameter can be one of the following values:
   1113            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1114            *     @arg ADC_FLAG_EOC: End of conversion flag
   1115            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1116            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1117            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1118            * @retval The new state of ADC_FLAG (SET or RESET).
   1119            */
   1120          FlagStatus ADC_GetFlagStatus(ADC_TypeDef *ADCx, uint8_t ADC_FLAG) {
   1121              FlagStatus bitstatus = RESET;
   1122              /* Check the parameters */
   1123              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1124              assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1125              /* Check the status of the specified ADC flag */
   1126              if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET) {
   1127                  /* ADC_FLAG is set */
   1128                  bitstatus = SET;
   1129              } else {
   1130                  /* ADC_FLAG is reset */
   1131                  bitstatus = RESET;
   1132              }
   1133              /* Return the ADC_FLAG status */
   1134              return bitstatus;
   1135          }
   1136          
   1137          /**
   1138            * @brief  Clears the ADCx's pending flags.
   1139            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1140            * @param  ADC_FLAG: specifies the flag to clear. 
   1141            *   This parameter can be any combination of the following values:
   1142            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1143            *     @arg ADC_FLAG_EOC: End of conversion flag
   1144            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1145            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1146            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1147            * @retval None
   1148            */
   1149          void ADC_ClearFlag(ADC_TypeDef *ADCx, uint8_t ADC_FLAG) {
   1150              /* Check the parameters */
   1151              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1152              assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1153              /* Clear the selected ADC flags */
   1154              ADCx->SR = ~(uint32_t)ADC_FLAG;
   1155          }
   1156          
   1157          /**
   1158            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1159            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1160            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1161            *   This parameter can be one of the following values:
   1162            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1163            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1164            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1165            * @retval The new state of ADC_IT (SET or RESET).
   1166            */
   1167          ITStatus ADC_GetITStatus(ADC_TypeDef *ADCx, uint16_t ADC_IT) {
   1168              ITStatus bitstatus = RESET;
   1169              uint32_t itmask = 0, enablestatus = 0;
   1170              /* Check the parameters */
   1171              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1172              assert_param(IS_ADC_GET_IT(ADC_IT));
   1173              /* Get the ADC IT index */
   1174              itmask = ADC_IT >> 8;
   1175              /* Get the ADC_IT enable bit status */
   1176              enablestatus = (ADCx->CR1 &(uint8_t)ADC_IT);
   1177              /* Check the status of the specified ADC interrupt */
   1178              if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus) {
   1179                  /* ADC_IT is set */
   1180                  bitstatus = SET;
   1181              } else {
   1182                  /* ADC_IT is reset */
   1183                  bitstatus = RESET;
   1184              }
   1185              /* Return the ADC_IT status */
   1186              return bitstatus;
   1187          }
   1188          
   1189          /**
   1190            * @brief  Clears the ADCx's interrupt pending bits.
   1191            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1192            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1193            *   This parameter can be any combination of the following values:
   1194            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1195            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1196            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1197            * @retval None
   1198            */
   1199          void ADC_ClearITPendingBit(ADC_TypeDef *ADCx, uint16_t ADC_IT) {
   1200              uint8_t itmask = 0;
   1201              /* Check the parameters */
   1202              assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1203              assert_param(IS_ADC_IT(ADC_IT));
   1204              /* Get the ADC IT index */
   1205              itmask = (uint8_t)(ADC_IT >> 8);
   1206              /* Clear the selected ADC interrupt pending bits */
   1207              ADCx->SR = ~(uint32_t)itmask;
   1208          }
   1209          
   1210          /**
   1211            * @}
   1212            */
   1213          
   1214          /**
   1215            * @}
   1216            */
   1217          
   1218          /**
   1219            * @}
   1220            */
   1221          
   1222          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC_AnalogWatchdogCmd
        0  ADC_AnalogWatchdogSingleChannelConfig
        0  ADC_AnalogWatchdogThresholdsConfig
        0  ADC_AutoInjectedConvCmd
        0  ADC_ClearFlag
        0  ADC_ClearITPendingBit
        0  ADC_Cmd
        0  ADC_DMACmd
        8  ADC_DeInit
             8 -> RCC_APB2PeriphResetCmd
        4  ADC_DiscModeChannelCountConfig
        0  ADC_DiscModeCmd
        0  ADC_ExternalTrigConvCmd
        0  ADC_ExternalTrigInjectedConvCmd
        0  ADC_ExternalTrigInjectedConvConfig
        0  ADC_GetCalibrationStatus
        0  ADC_GetConversionValue
        0  ADC_GetDualModeConversionValue
        0  ADC_GetFlagStatus
       12  ADC_GetITStatus
        4  ADC_GetInjectedConversionValue
        0  ADC_GetResetCalibrationStatus
        0  ADC_GetSoftwareStartConvStatus
        0  ADC_GetSoftwareStartInjectedConvCmdStatus
        4  ADC_ITConfig
        8  ADC_Init
       20  ADC_InjectedChannelConfig
        0  ADC_InjectedDiscModeCmd
        4  ADC_InjectedSequencerLengthConfig
       16  ADC_RegularChannelConfig
        0  ADC_ResetCalibration
        4  ADC_SetInjectedOffset
        0  ADC_SoftwareStartConvCmd
        0  ADC_SoftwareStartInjectedConvCmd
        0  ADC_StartCalibration
        0  ADC_StructInit
        0  ADC_TempSensorVrefintCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      16  ADC_AnalogWatchdogCmd
      18  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
       8  ADC_ClearFlag
      16  ADC_ClearITPendingBit
      26  ADC_Cmd
      26  ADC_DMACmd
      94  ADC_DeInit
      30  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_ExternalTrigConvCmd
      26  ADC_ExternalTrigInjectedConvCmd
      16  ADC_ExternalTrigInjectedConvConfig
      24  ADC_GetCalibrationStatus
       6  ADC_GetConversionValue
       6  ADC_GetDualModeConversionValue
      26  ADC_GetFlagStatus
      54  ADC_GetITStatus
      32  ADC_GetInjectedConversionValue
      24  ADC_GetResetCalibrationStatus
      24  ADC_GetSoftwareStartConvStatus
      24  ADC_GetSoftwareStartInjectedConvCmdStatus
      36  ADC_ITConfig
      80  ADC_Init
     178  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      30  ADC_InjectedSequencerLengthConfig
     238  ADC_RegularChannelConfig
      10  ADC_ResetCalibration
      26  ADC_SetInjectedOffset
      26  ADC_SoftwareStartConvCmd
      26  ADC_SoftwareStartInjectedConvCmd
      10  ADC_StartCalibration
      26  ADC_StructInit
      34  ADC_TempSensorVrefintCmd

 
 1 362 bytes in section .text
 
 1 362 bytes of CODE memory

Errors: none
Warnings: none
