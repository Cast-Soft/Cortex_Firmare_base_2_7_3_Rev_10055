###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     13/Nov/2019  10:52:17 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\App\tasks.c                                         #
#    Command line =  "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\App\tasks.c" -D BEACON_APP -D USE_STDPERIPH_DRIVER  #
#                    -D STM32F10X_CL -D COOS -D USE_MY_ASSERT -D _DEBUG -D    #
#                    BOOTLOADER -D EE_M24C02 -D TASKS_PROFILE -D              #
#                    BATTERY_CHECK -D CCA_EN_NO -D NEW_BEACON -D USE_TIM4 -D  #
#                    WDT_ENABLE -D OLD_CONFIG -D CIRCULAR_LOG -D BC_HW_REVJ   #
#                    -lcN "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source  #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\" -o                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\App\" -I "C:\Users\kmak\Documents\Cortex_Git #
#                    \BLKT-01\Source Code\BLKT-01                             #
#                    Beacon\Source\firmware\beacon -                          #
#                    revJ\IAR\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F1 #
#                    0x\" -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Sour #
#                    ce Code\BLKT-01 Beacon\Source\firmware\beacon -          #
#                    revJ\IAR\..\..\common\STM32F10x_StdPeriph_Driver\inc\"   #
#                    -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\kernel\" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\portable\" -I                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\..\common\" -I                            #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\USB-Device-CDC\" -I                #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\" -I "C:\Users\kmak\Documents\Cort #
#                    ex_Git\BLKT-01\Source Code\BLKT-01                       #
#                    Beacon\Source\firmware\beacon - revJ\IAR\" -On           #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\tasks.lst            #
#    Object file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\tasks.o               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source Code\BLKT-01 Beacon\Source\firmware\beacon - revJ\App\tasks.c
      1          /********************  All title and rights are owned by  *********************
      2          *******  the CAST Group of Companies Inc. or licensors thereto. ***************
      3          *******************************************************************************
      4          * File Name          : tasks.c
      5          * Author             : ?
      6          * Version            : V1.0
      7          * Date               : 6/2/2011
      8          * Description        : All the various System Tasks
      9          *******************************************************************************/
     10          
     11          #include "VersionNo.h"
     12          
     13          /* INCLUDES ------------------------------------------------------------------*/
     14          
     15          #include "tasks.h"
     16          #include "CoOS.h"
     17          #include "hardware.h"
     18          #include "basic_rf.h"
     19          #include "radio.h"
     20          #include "stm32f10x_it.h"
     21          #include "stm32f10x_iwdg.h"
     22          #include "stm32f10x_flash.h"
     23          #include "stm32f10x_adc.h"
     24          #include "i2c_ee.h"
     25          #include <stdio.h>
     26          #include <string.h>
     27          #include <ctype.h>
     28          
     29          #include "radio.h"
     30          #include "radio_defs.h"
     31          #include "packets.h"
     32          #include "flash_map.h"
     33          #include "util.h"
     34          #include "config.h"
     35          #include "console_tail.h"
     36          
     37          #include "i2c_periph.h"
     38          #include "eink.h"
     39          #include "blkt_gfx.h"
     40          #include "bitmaps.h"
     41          /* PRIVATE TYPEDEF -----------------------------------------------------------*/
     42          
     43          typedef struct {
     44              uint16_t    dstAddr;
     45              uint8_t     payloadSize;
     46              uint8_t     payload[FRAME_LENGTH_MAX - MHR_SIZE - MFR_SIZE];
     47          } txPktRec_t;
     48          
     49          typedef enum{
     50            UI_POWERON_STATE        =0,
     51            UI_HOME_STATE           =1,
     52            UI_MENU_STATE           =2,
     53            UI_STATUS_RADIO_STATE   =3,
     54            UI_STATUS_BATTERY_STATE =4,
     55            UI_ID_STATE             =5,
     56            //UI_CHARGING_STATE       =6,
     57            UI_POWEROFF_STATE       =7,
     58          }UI_States;
     59          
     60          typedef enum{
     61            UI_MENU_HOME_SUBSTATE =0,
     62            UI_MENU_STATUS_SUBSTATE =1,
     63            UI_MENU_ID_SUBSTATE =2,
     64            UI_MENU_POWER_SUBSTATE =3,
     65          }UI_SubStates;
     66          /* PRIVATE DEFINES -----------------------------------------------------------*/
     67          
     68          #ifdef STDIO_TO_USART
     69          #define DISABLE_PWR_SW
     70          #endif
     71          
     72          #define PINGER_ADDR         0x1234
     73          #define TX_PKT_QUEUE_SIZE   8
     74          
     75          #define UPDATE_FLAG_PANID       0x01
     76          #define UPDATE_FLAG_DSTADDR     0x02
     77          #define UPDATE_FLAG_DAC         0x04
     78          #define UPDATE_FLAG_RFCHAN      0x08
     79          #define UPDATE_FLAG_TXLEVEL     0x10
     80          
     81          /*
     82           Beacon Pkt Duration = 0.70ms
     83           Max TX Pkt Duration = 3.5ms
     84           Inhibit Guard-Band Pre = 4.0ms
     85           Inhibit Guard-Band Post = 0.5ms
     86          */
     87          #define SOH 0x01
     88          #define EOT 0x04
     89          #define ACK 0x06
     90          
     91          #define NUM_TX_RETRIES 4
     92          
     93          #define DEBOUNCE_MIN    1
     94          #define DEBOUNCE_MAX    9
     95          #define DBLCLICK_MIN_TIME       1
     96          #define DBLCLICK_MAX_TIME       9
     97          
     98          #define BUTTON_DEBOUNCE 1
     99          
    100          #define UI_PWRBTNFLAG 0x01
    101          #define UI_BTNAFLAG   0x02
    102          #define UI_BTNBFLAG   0x04
    103          #define UI_IRLED0FLAG 0x01
    104          #define UI_IRLED1FLAG 0x02
    105          #define UI_IRLED2FLAG 0x04
    106          /* PRIVATE MACROS ------------------------------------------------------------*/
    107          
    108          /* EXTERN VARIABLES ----------------------------------------------------------*/
    109          
    110          
    111          /* Variables Defined in main.c */
    112          
    113          extern char firmwareVersion[];
    114          extern uint8_t radio_off;
    115          
    116          extern uint32_t txFrmDoneCount;
    117          extern uint32_t irq_spi_dma;
    118          //uint32_t task2Counter;
    119          extern StatusType task2StatusType;
    120          extern uint32_t task2enter;
    121          
    122          extern OS_TID task1Id;
    123          extern OS_TID taskRadioRxId;
    124          extern OS_TID task3Id;
    125          extern OS_TID taskConfigId;
    126          extern OS_TID taskRadioTxId;
    127          extern OS_TID task8Id;
    128          extern OS_TID taskIMUGId;
    129          extern OS_TID taskLEDId;
    130          extern OS_TID taskUIId;
    131          
    132          extern OS_FlagID flagIMUNewData;
    133          extern OS_FlagID flagIMU_G_DRDY;
    134          extern OS_FlagID flagRadioTxReq;
    135          extern OS_FlagID flagIMUTimeToSend;
    136          extern OS_FlagID flagRadioCCA;
    137          
    138          extern uint32_t drift;
    139          extern int32_t last_drift;
    140          
    141          extern OS_EventID semIMUAllow;
    142          extern OS_EventID semInkUI;
    143          extern OS_EventID semEinkBufferAllow;
    144          
    145          extern OS_FlagID flagIMUDataReady;
    146          extern OS_FlagID flagLEDSync;
    147          extern OS_FlagID flagEInk_RDY;
    148          extern OS_FlagID flagEInk_DMA_Done;
    149          extern OS_FlagID flagBtn_UI;
    150          extern OS_FlagID flagLED_UI;
    151          extern OS_FlagID flagTimeout_UI;
    152          extern OS_FlagID flagUSBdata_UI;
    153          extern volatile uint32_t IMUSampleTime;
    154          extern volatile uint16_t MsTimerAtSync;
    155          extern volatile uint8_t IMUPktNumAtSync;
    156          
    157          extern Batt_Union_t BattUnion, *pBattUnion;
    158          //extern SPI3_CS_TypeDef SPI3_CS;
    159          
    160          extern uint32_t rxErrors;
    161          extern uint32_t sec;
    162          extern struct realTime semTime2;
    163          extern struct realTime rxFIFOTime;
    164          
    165          extern volatile uint16_t tasksWDT;
    166          #if (defined USE_MY_ASSERT) || (defined USE_FULL_ASSERT)
    167          extern uint8_t  assert_loop;
    168          #endif
    169          extern uint16_t routerAddr;
    170          extern uint8_t asserted;
    171          extern uint8_t cc2520_flags0;
    172          extern uint8_t cc2520_flags1;
    173          extern uint8_t cc2520_flags2;
    174          extern uint16_t sampledCCA;
    175          
    176          #ifdef CIRCULAR_LOG
    177          tLogStruct log[LOG_SIZE/sizeof(tLogStruct)];
    178          uint16_t  log_index_in;
    179          #endif
    180          
    181          uint8_t last_percents;
    182          uint32_t Valids;
    183          uint32_t notValids;
    184          uint32_t lostSync;
    185          uint32_t changeClocks;
    186          uint32_t newbcn;
    187          uint32_t frameIdCorrectionCount;
    188          //uint8_t TRACE_ADJUST = 0;
    189          uint32_t oldFrameIdAtSync, newFrameIdAtSync;
    190          
    191          //extern uint32_t rx_overflow;
    192          //extern uint32_t tx_overflow;
    193          //extern uint32_t syncPackets;
    194          
    195          extern uint16_t adjusted;
    196          extern uint8_t adjusted_changed;
    197          
    198          
    199          int TRACE(char* fmt, ...);
    200          size_t __writeIMU(const unsigned char *buffer, size_t size);
    201          
    202          size_t __writeCmdLineRespPacket(const unsigned char *buffer, size_t size, uint8_t contentType);
    203          uint16_t tim_at_sec;
    204          
    205          uint32_t rt_flags;
    206          
    207          uint32_t outidxcheck=0;
    208          uint32_t inidxcheck=0;
    209          uint32_t txradioaccess_cnt=0;
    210          uint32_t imuaccess=0;
    211          extern uint32_t imu_irq_cnt;
    212          /* PRIVATE VARIABLES ---------------------------------------------------------*/
    213          //static uint16_t tim4MovAvgMin = UINT16_MAX, tim4MovAvgMax = 0;
    214          static volatile uint16_t halted = 0;
    215          static uint8_t beaconInSync = 0;
    216          static uint8_t txTestStr[] = {0xAA, 0x55, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
    217          static uint8_t txBuf[FRAME_LENGTH_MAX - MHR_SIZE - MFR_SIZE];  // tx-payload buffer
    218          static uint8_t rfChan;
    219          static uint8_t beaconRSSI;
    220          static txPktRec_t txPktQueue[TX_PKT_QUEUE_SIZE];
    221          static uint16_t inIdx = 0;
    222          static uint16_t outIdx = 0;
    223          static struct realTime startRadioTx;
    224          static struct realTime endRadioTx;
    225          static uint8_t queue_full;
    226          //static uint8_t send_battery_info = 1;
    227          
    228          volatile int32_t remainOutOfSyncTime;
    229          
    230          extern volatile uint32_t frameId;
    231          extern uint16_t tim3PhaseAtSync;
    232          
    233          static struct Beacon_BatData lastBatStatus;
    234          static tButton ButtonA;
    235          static tButton ButtonB;
    236          IRled_status IRled_flags; 
    237          UI_States UI_StateMachine = UI_POWERON_STATE;
    238          static uint8_t beaconName[32];
    239          volatile uint8_t frameIdFlag = 1;       // for task2() and EXTI2_IRQHandler() synchronization
    240                                                  // frameIdFlag =0 1 means that task2() is not processing packets,  EXTI2_IRQHandler() is OK to accept now.
    241                                                  // if task2() is still processing then EXTI2_IRQHandler() has to give up and wait for next packet interrupt (multiple packets in FIFO). It is OK for beacon to ignore some sync packets
    242                                                  // frameIdFlag == 0 means that EXTI2_IRQHandler() detected packet arrival
    243          
    244          uint32_t         errorFrameId;
    245          
    246          //#define EIGHTSAMPLEOFFSET 48299   // 80.5mS / 1.666 uS
    247          #define EIGHTSAMPLEOFFSET 48089   // 80.0mS / 1.666 uS
    248          #define FIVESAMPLEOFFSET  0   // 3.5mS / 1.666 uS
    249          
    250          // Timeslots in uS
    251          //  0, 876, 5,532, 10,188, 14,844, 19,500, 24,156, 28,812, 33,468, 38,124, 42,780
    252          //  47,436, 52,092, 56,748, 61,404, 66,060, 70,716, 75,372, 80,028, 84,684, 89,340
    253          //  93,996
    254          // timeslot offset run from 1.666uS counter
    255          //
    256          /*uint16_t TimeSlotVals[] = {0, 525, 3319, 6112, 8906, 11700, 14493, 17287, 20080, 22874,
    257                    25667, 28461, 31254, 34048, 36841, 39635, 42429, 45222, 48016, 50809,
    258                  53603, 56396 };*/
    259          
    260          /* same as above but now using 3.0 ms time slots instead of 4.65ms
    261          1800 counts per 3.0ms*/
    262          
    263          //3.5ms slots
    264          /*uint16_t TimeSlotVals[] = {0,   525,  2625, 4725, 6825, 8925,11025,13125,15225,17325,
    265                                    19425,21525,23625,25725,};*/
    266          static uint16_t TimeSlotVals[] = {0,   0, 2100, 4200, 6300, 8400,10500,12600,14700,16800,
    267                                    18900,21000,23100,25200, 27300, 29400};
    268          
    269          #define MAX_NUMBER_OF_TIMESLOTS sizeof(TimeSlotVals) / sizeof(uint16_t)
    270          
    271          //static uint8_t durationstring[6]="1.25H";
    272          //static uint8_t powerstring[13]="loading. . .";
    273          //static uint8_t IDstring[6]= "ID120";
    274          /* PUBLIC VARIABLES ----------------------------------------------------------*/
    275          __no_init uint32_t random;
    276          
    277          config_t config;
    278          
    279          struct realTime oldFrameTime;
    280          struct realTime newFrameTime;
    281          
    282          uint32_t tkFrameId;             // received T.K. frame Id
    283          uint32_t lastTKFrameId = 0;
    284          uint32_t lastFrameIdCorrection;
    285          int8_t FRAME_DIFF_DELTA = 5;            // from T.K. sending out sync packet to beacon receiving it, there is a intrinsic latency. In frame pair format, it is Delta(FRAME_DIFF_DELTA, PHASE_DELTA)
    286                                                  // both FRAME_DIFF_DELTA, PHASE_DELTA are experimental values that we have to measure and find out
    287                                                  // PHASE_DELTA will be handled by Motive settings   
    288          uint32_t successBeacons;
    289          uint16_t routerAddr = 0;
    290          uint8_t use_sync = 1;
    291          uint16_t RfTxLevel;
    292          uint32_t IMUdbgPrt = 0;
    293          uint16_t frameOffset;
    294          uint8_t bat_slot_numbers;
    295          
    296          uint32_t last_bat_sent;
    297          
    298          uint8_t test_imu_pkt_ctr = 0; // IMU packet ctr from IMU interrupt
    299          
    300          uint16_t txTimeSlot = 40000;
    301          
    302          uint8_t firstTime = 1;  // first need to initialize timer of time slot
    303          uint16_t random_slot1 = 0xFFFF;
    304          uint16_t random_slot2 = 0xFFFF;
    305          
    306          volatile ledcheck led_select = select_none;
    307          
    308          //User Interface Variables
    309          uint8_t UI_IRLEDdata = 0;
    310          uint8_t UI_BUTTONdata = 0;
    311          /* EXTERNAL FUNCTION PROTOTYPES ---------------------------------------------*/
    312          #if 0
    313          uint8_t IMURegRd(uint8_t addr, HwSPI_TypeDef Sensor);
    314          void IMURegWr(uint8_t addr, HwSPI_TypeDef Sensor, uint8_t val);
    315          #endif
    316          /* PRIVATE FUNCTION PROTOTYPES -----------------------------------------------*/
    317          static void GetAverageImuData(uint16_t *pBuff);
    318          static void InputDataIntoBuffer(uint8_t volatile *pImuData);
    319          
    320          static void mygets(char *str);
    321          
    322          static void SetConfig(uint16_t idx, uint32_t val, uint32_t pattern, uint8_t ledBits, uint8_t ledId);
    323          static void PrintConfig(void);
    324          
    325          static uint8_t RadioTxPktQueue(uint16_t dstAddr, uint8_t payloadSize, uint8_t *payload);
    326          
    327          static void setHomeScreen(uint8_t stringname[],uint8_t addr[]);
    328          static void setStringerGraphics(uint8_t led_flags);
    329          static void resetUITimeout(void);
    330          static void disableUITimeout(void);
    331          /* PRIVATE FUNCTIONS ---------------------------------------------------------*/
    332          /*******************************************************************************
    333          * Description : Sets Outgoing Tx Timeslot
    334          * Input       :
    335          * Return      : -
    336          *******************************************************************************/
    337          void SetTimeSlot(void){
    338          
    339          uint16_t TimeSlotTemp = 40000;
    340          
    341            if((config.rfTimeSlot > 1) && (config.rfTimeSlot < MAX_NUMBER_OF_TIMESLOTS))
    342            {
    343              TimeSlotTemp = TimeSlotVals[config.rfTimeSlot];
    344              //TimeSlotTemp -= FIVESAMPLEOFFSET;
    345              /*if(TimeSlotTemp > FIVESAMPLEOFFSET)
    346              {
    347                  TimeSlotTemp -= FIVESAMPLEOFFSET;
    348              }
    349              else
    350              {
    351                TimeSlotTemp = FIVESAMPLEOFFSET -  (TimeSlotVals[config.rfTimeSlot]);
    352                TimeSlotTemp = 60000 - TimeSlotTemp;
    353              }*/
    354              txTimeSlot =TimeSlotTemp;
    355              firstTime = 1;           // reset timeslot
    356            }
    357            else
    358            {
    359              config.rfTimeSlot = 2;
    360              //recursive call
    361              SetTimeSlot();
    362            }
    363          }
    364          
    365          
    366          /*******************************************************************************
    367          * Description : Get a line from STDIN
    368          * Input       :
    369          * Return      : -
    370          *******************************************************************************/
    371          static void mygets(char *str) {
    372              char *tmp = str;
    373              int c;
    374              SAVE_POINT
    375              do {
    376                  while( (c = getchar()) == EOF ) {
    377                      SAVE_POINT
    378                      CoTickDelay(10);
    379                      SAVE_POINT
    380                      // reset tasksWDT
    381                      tasksWDT |= 0x0002;
    382                  }
    383                  putchar(c);
    384                  *tmp++ = (char) c;
    385              } while (c != '\r');
    386              SAVE_POINT
    387          
    388              putchar('\n');
    389              *(--tmp) = '\0';
    390          }
    391          
    392          #if 0
    393          /*******************************************************************************
    394          * Description : Write to an IMU Register
    395          * Input       :
    396          * Return      : -
    397          *******************************************************************************/
    398          void IMURegWr(uint8_t addr, HwSPI_TypeDef Sensor, uint8_t val) {
    399              SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI); // flush RXNE
    400          
    401              // write LSB
    402              HwSPISSAssert(Sensor);
    403              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, ((addr << 8) | val) );
    404              //TK_BK_SPI_WAIT_RXRDY();
    405              while (SPI_I2S_GetFlagStatus(SPI_RADIO_IMU_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    406              SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI); // flush RXNE
    407              HwSPISSDeAssert(Sensor);
    408          }
    409          #endif
    410          
    411          #define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
    412          
    413          /*******************************************************************************
    414          * Function Name  : NVIC_GenerateSystemReset
    415          * Description    : Generates a system reset.
    416          * Input          : None
    417          * Output         : None
    418          * Return         : None
    419          *******************************************************************************/
    420          void NVIC_GenerateSystemReset(void)
    421          {
    422            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
    423          }
    424          
    425          #if 0
    426          /*******************************************************************************
    427          * Description : Read from an IMU Register
    428          * Input       :
    429          * Return      : -
    430          *******************************************************************************/
    431          uint8_t IMURegRd(uint8_t addr, HwSPI_TypeDef Sensor) {
    432          
    433              uint16_t value;
    434          
    435              SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI); // flush RXNE
    436          
    437              // send register addr
    438              HwSPISSAssert(Sensor);
    439              // With Read Bit set 0x8000
    440              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, 0x8000 | (addr << 8));
    441              // TK_BK_SPI_WAIT_RXRDY();
    442              while (SPI_I2S_GetFlagStatus(SPI_RADIO_IMU_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    443              value = SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI);
    444              HwSPISSDeAssert(Sensor);
    445          
    446              return (uint8_t)value;
    447          }
    448          #endif
    449          /*******************************************************************************
    450          * Description : Reads all the IMU buffered data and averages it
    451          * Input       :
    452          * Return      : - Averaged and packed data according to old ADI format
    453          *                 BK_IMUData.
    454          *******************************************************************************/
    455          static void GetAverageImuData(uint16_t *pBuff)
    456          {
    457            // Get Data from Gyro Buffer
    458            //x__disable_interrupt();
    459            pBuff[0] = ImuGyroBuffer.xSum;
    460            pBuff[1] = ImuGyroBuffer.ySum;
    461            pBuff[2] = ImuGyroBuffer.zSum;
    462            pBuff[3] = ImuAccelBuffer.xSum;
    463            pBuff[4] = ImuAccelBuffer.ySum;
    464            pBuff[5] = ImuAccelBuffer.zSum;
    465            //x__enable_interrupt();
    466          }
    467          
    468          /*******************************************************************************
    469          * Description : Inputs the XYZ data into IMU Buffer
    470          * Input       :   Buffer of Data and Buffer
    471          * Return      : -
    472          *******************************************************************************/
    473          static void InputDataIntoBuffer(uint8_t volatile *pImuData)
    474          {
    475            //x__disable_interrupt();
    476            //data scaling done on blkt software.
    477          	ImuBuffer_t volatile *pImuBuff= &ImuGyroBuffer;
    478          	pImuBuff->xSum = (*(uint16_t*)&pImuData[6]);
    479          	pImuBuff->ySum = (*(uint16_t*)&pImuData[8]);
    480          	pImuBuff->zSum = (*(uint16_t*)&pImuData[10]);
    481          	pImuBuff->count = 1;
    482          	
    483          	pImuBuff = &ImuAccelBuffer;
    484          	pImuBuff->xSum = *((uint16_t*)&pImuData[0]);
    485          	pImuBuff->ySum = *((uint16_t*)&pImuData[2]);
    486          	pImuBuff->zSum = *((uint16_t*)&pImuData[4]);
    487          	pImuBuff->count = 1;
    488            //x__enable_interrupt();
    489          }
    490          
    491          /*******************************************************************************
    492          * Description : Inputs the XYZ data into IMU Buffer
    493          * Input       :   Buffer of Data and Buffer
    494          * Return      : -
    495          *******************************************************************************/
    496          static uint8_t getButtonState(tButton *Button){
    497            uint32_t x  =HwButtonPressed(Button->ButtonID);
    498            switch(Button->current_state){
    499              case BUTTON_OFF:
    500                Button->debounce_count = (x!=0)? Button->debounce_count +1 : 0;
    501                Button->current_state = (Button->debounce_count >= BUTTON_DEBOUNCE)? BUTTON_PRESSED:BUTTON_OFF;
    502              break;
    503              case BUTTON_PRESSED:
    504                if(x==0){
    505                  Button->debounce_count =0;
    506                  Button->current_state = BUTTON_OFF;
    507                  Button->event_flag = 1; 
    508                  return 1;
    509                }
    510              break;
    511              //other states not implemented. to be implemented
    512            }
    513            return 0;
    514          }
    515          /*******************************************************************************
    516          * Description : Set Configuration
    517          * Input       :
    518          * Return      : -
    519          *******************************************************************************/
    520          static void SetConfig(uint16_t idx, uint32_t val, uint32_t pattern, uint8_t ledBits, uint8_t ledId) {
    521              SAVE_POINT
    522              switch (idx) {
    523                  /*
    524                      0 : productID
    525                      1 : serialNum
    526                      2 : panId
    527                      3 : mySrcAddr
    528                      4 : tkDstAddr
    529                      5 : ledOnOffs
    530                      6 : ledOffOffs
    531                      7 : ledDAC
    532                      8 : rfChan
    533                      9 : led0Id
    534                      A : led1Id
    535                      B : led2Id
    536                      C : TestMode
    537                  */
    538                  case 0x0:
    539                      config.productID = val;
    540                      break;
    541                  case 0x1:
    542                      config.serialNum = val;
    543                      break;
    544                  case 0x2:
    545                      config.panId = val;
    546                      RadioSetPanIdShortAddr(config.panId, config.mySrcAddr);
    547                      break;
    548                  case 0x3:
    549                      config.mySrcAddr = val;
    550                      RadioSetPanIdShortAddr(config.panId, config.mySrcAddr);
    551                      CoSetFlag(flagUSBdata_UI);
    552                      SAVE_POINT
    553                      break;
    554                  case 0x4:
    555                      config.routerDstAddr = val;
    556                      break;
    557                  case 0x5:
    558                      config.ledOnOffs = val;
    559                      break;
    560                  case 0x6:
    561                      config.ledOffOffs = val;
    562                      break;
    563                  case 0x7:
    564                      config.ledDAC = val;
    565                      DAC_SetChannel2Data(DAC_Align_12b_R, val);
    566                      break;
    567                  case 0x8:
    568                      if(val >= OLD_RF_CHANNEL_MIN && val <= OLD_RF_CHANNEL_MAX)
    569                      {
    570                        config.rfChan = val;
    571                        SAVE_POINT
    572                        RadioSetRFChan(val);
    573                      }
    574                      break;
    575                  case 0x9:
    576                      config.led0Id = val;
    577                      break;
    578                  case 0xA:
    579                      config.led1Id = val;
    580                      break;
    581                  case 0xB:
    582                      config.led2Id = val;
    583                      break;
    584                  case 0xC:
    585                    config.TestMode = val;
    586                    break;
    587                  case 0xD:
    588                    config.rfTimeSlot = val;
    589                    SetTimeSlot();
    590                    break;
    591                 case 0xE:
    592                    config.TxLevel = val;
    593                    SAVE_POINT
    594                    RadioSetRFLevel(config.TxLevel);
    595                    SAVE_POINT
    596                    break;
    597              case 0x10:
    598                    config.radioPacketFlags = val;
    599                    break;
    600              case 0x13:
    601                    config.led0IdPattern = pattern;
    602                    config.led0Index = val;
    603                    config.frameBits = ledBits;
    604                    config.led0Id = ledId;
    605                   break;
    606              case 0x14:
    607                    config.led1IdPattern = pattern;
    608                    config.led1Index = val;
    609                    config.frameBits = ledBits;
    610                    config.led1Id = ledId;
    611                    break;
    612              case 0x15:
    613                    config.led2IdPattern = pattern;
    614                    config.led2Index = val;
    615                    config.frameBits = ledBits;
    616                    config.led2Id = ledId;
    617                    break;
    618              case 22:
    619                      if(val >= RF_CHANNEL_MIN && val <= RF_CHANNEL_MAX)
    620                      {
    621                        config.rfChan = val;
    622                        SAVE_POINT
    623                        RadioSetRFChan(val);
    624                      }
    625                      break;
    626          #ifndef OLD_CONFIG
    627              case 24:
    628                    if (val >= DEBOUNCE_MIN && val <= DEBOUNCE_MAX) {
    629                      config.debounce_time = val;
    630                    }
    631                    break;
    632              case 25:
    633                    if (val >= DBLCLICK_MIN_TIME && val <= DBLCLICK_MAX_TIME) {
    634                      config.doubleclick_time = val;
    635                    }
    636                    break;
    637          #endif
    638              default:
    639                      TRACE("**ERROR** Unrecognized Configuration Setting\n\r");
    640                      break;
    641          
    642              }
    643          }
    644          /*******************************************************************************
    645          * Description : Print Configuration
    646          * Input       : -
    647          * Return      : -
    648          *******************************************************************************/
    649          static void PrintConfig(void) {
    650              SAVE_POINT
    651          
    652          
    653          #ifdef _DEBUG
    654              TRACE("\n\r FIRMWARE VERSION: " STRINGIFY(THIS_MAJOR) "." STRINGIFY(THIS_MINOR) "." STRINGIFY(THIS_PATCH) "." STRINGIFY(THIS_REVISION) " BC DEBUG \n\r\n\r");
    655          #else
    656              TRACE("\n\r FIRMWARE VERSION: " STRINGIFY(THIS_MAJOR) "." STRINGIFY(THIS_MINOR) "." STRINGIFY(THIS_PATCH) "." STRINGIFY(THIS_REVISION) " BC RELEASE \n\r\n\r");
    657          #endif
    658              TRACE(" "__DATE__" : "__TIME__" \n\n\r");
    659              TRACE("ARM Serial Number 0x%X,0x%X,0x%X \n\n\r",ARM_proc_SN.a,ARM_proc_SN.b, ARM_proc_SN.c);
    660          
    661              if(IMUPresent){
    662                 TRACE("IMU Present\n\n\r");
    663              }else{
    664                TRACE(" No IMU Installed\n\n\r");
    665              }
    666          
    667          TRACE("[0] productID   : %X\n\r", config.productID);
    668          TRACE("[1] serialNum   : %X\n\r", config.serialNum);
    669          TRACE("[2] panId       : %04X\n\r", config.panId);
    670          TRACE("[3] mySrcAddr   : %04X\n\r", config.mySrcAddr);
    671          TRACE("[4] routerDstAddr   : %04X\n\r", config.routerDstAddr);
    672          TRACE("[5] ledOnOffs   : %X\n\r", config.ledOnOffs);
    673          TRACE("[6] ledOffOffs  : %X\n\r", config.ledOffOffs);
    674          TRACE("[7] ledDAC      : %X\n\r", config.ledDAC);
    675          TRACE("[8] rfChan      : %02X\n\r", config.rfChan);
    676          TRACE("[?] rfTimeSlot  : %02X\n\r", config.rfTimeSlot);
    677          TRACE("[9] led0Id      : %02X\n\r", config.led0Id);
    678          TRACE("[A] led1Id      : %02X\n\r", config.led1Id);
    679          TRACE("[B] led2Id      : %02X\n\r", config.led2Id);
    680          TRACE("[C] TestMode    : %d\n\r", config.TestMode);
    681          TRACE("[J] led0IdPattern : %08X\n\r", config.led0IdPattern);
    682          TRACE("[K] led1IdPattern : %08X\n\r", config.led1IdPattern);
    683          TRACE("[L] led2IdPattern : %08X\n\r", config.led2IdPattern);
    684          TRACE("[M] led0Index : %08X\n\r", config.led0Index);
    685          TRACE("[N] led1Index : %08X\n\r", config.led1Index);
    686          TRACE("[O] led2Index : %08X\n\r", config.led2Index);
    687          TRACE("[Y] frameBits   : %d\n\r", config.frameBits);
    688          TRACE("[Z] Tx RF Level : %X\n\r", TxAmpValues[config.TxLevel]);
    689          TRACE("[X] Radio: %s\n\r", radio_off == 0? "on":"off");
    690          
    691            TRACE("Built on "__DATE__" "__TIME__"\n\r");
    692            TRACE("Flags = 0x%08X \r\n", config.flags);
    693            TRACE("Timer adjust: %d\n\r", config.time_adjust);
    694            TRACE("Timekeeper sync: %s\n\r", use_sync?"yes":"no");
    695            TRACE("No sync timeout sec: %d\n\r", config.frameCountNoSync/10);
    696          #ifndef OLD_CONFIG
    697            TRACE("FrameId 24 bits wrap around: %s\n\r", (config.flags & FLAG_FRAMEID_24BITS)?"yes":"no");
    698            TRACE("Debounce value[1-9]: %u, doubleclick value[1-9]: %u\r\n", config.debounce_time,
    699                  config.doubleclick_time);
    700          #endif
    701          }
    702          
    703          
    704          uint32_t txCalls;
    705          uint32_t txCalls2;
    706          StatusType setRadioTx;
    707          
    708          /*******************************************************************************
    709          * Description : Add Packet to Radio Transmit Queue
    710          * Input       : -
    711          * Return      : 0 if buffer full otherwise just returns payloadSize back
    712          *******************************************************************************/
    713          static uint8_t RadioTxPktQueue(uint16_t dstAddr, uint8_t payloadSize, uint8_t *payload) {
    714              // critical section.
    715              SAVE_POINT
    716              __disable_interrupt();
    717              if ( ((inIdx + 1) % TX_PKT_QUEUE_SIZE) == outIdx )
    718              {
    719                  __enable_interrupt();
    720                    SAVE_POINT
    721                    return 0; // queue is full => ignore request
    722              }
    723              txCalls++;
    724              txPktQueue[inIdx].dstAddr = dstAddr;
    725              txPktQueue[inIdx].payloadSize = payloadSize;
    726              memcpy((void *)txPktQueue[inIdx].payload, (void *)payload, payloadSize);
    727              inIdx = (inIdx + 1) % TX_PKT_QUEUE_SIZE;
    728              inidxcheck++;
    729              __enable_interrupt();
    730          
    731              setRadioTx = CoSetFlag(flagRadioTxReq);  // Wake up TX task if it is waiting for sending
    732              txCalls2++;
    733              return payloadSize;
    734          }
    735          
    736          uint32_t calls;
    737          uint32_t pushed_times;
    738          
    739          StatusType semAllowPostTask;
    740          uint8_t semAllow = 0;
    741          
    742          /* PUBLIC FUNCTIONS ----------------------------------------------------------*/
    743          extern uint32_t secs;
    744          
    745          /*******************************************************************************
    746          * Description    : [Task] Process and Send each new IMU data sample
    747          * Input          :
    748          * Return         :
    749          *******************************************************************************/
    750          void Task1(void* pdata){
    751              static uint8_t seqNum = 0;
    752              static uint16_t *pBuf;
    753              static uint16_t i = 0;
    754              static struct Beacon_Data_pkt *pBeacon_Data_pkt;
    755              static uint8_t last_button_state = 0;
    756              static uint16_t battery_minutes = 0;
    757          
    758              while (1) {
    759                  RELOAD_WATCHDOG
    760                  SAVE_POINT
    761          
    762                  pBeacon_Data_pkt = (struct Beacon_Data_pkt*)txBuf;
    763          
    764                  pBeacon_Data_pkt->BK_Preamble.button_pr = (HwButtonPressed(BUTTON2) ? 0x01 : 0x00) |
    765                              (HwButtonPressed(BUTTON1) ? 0x02 : 0x00) ;
    766                  pBeacon_Data_pkt->BK_Preamble.Seq_Num=  seqNum++ ;
    767                  pBeacon_Data_pkt->BK_Preamble.BeaconRSSI= beaconRSSI;
    768                  pBeacon_Data_pkt->BK_Preamble.IRLed0= config.led0Id;
    769                  pBeacon_Data_pkt->BK_Preamble.IRLed1= config.led1Id;
    770                  pBeacon_Data_pkt->BK_Preamble.IRLed2= config.led2Id;
    771                  pBeacon_Data_pkt->BK_Preamble.Battery_lev = BattUnion.BatteryLevel[1];
    772                  pBeacon_Data_pkt->BK_Preamble.SyncFrameIMU=frameIdAtSync;
    773                  pBeacon_Data_pkt->BK_Preamble.MsTimerIMU=MsTimerAtSync;
    774                  pBeacon_Data_pkt->BK_Preamble.IMUPktNum=IMUPktNumAtSync;
    775          
    776                  SAVE_POINT
    777                  
    778                  static uint8_t last_test_imu_pkt_ctr = 255;     // to detect if a IMU packet was sent.  
    779                  // Five IMU samples per data Packet
    780                  i  = 0;
    781                  while (i < NUM_OF_IMU_PKTS_IN_RF_PKT)
    782                  {
    783                       SAVE_POINT
    784                       pBuf = (uint16_t*) &pBeacon_Data_pkt->BeaconIMUData[i].gyroscopeX;
    785                       CoAwakeTask(taskIMUGId);  
    786                       CoWaitForSingleFlag(flagIMUDataReady, 0);
    787                       CoSuspendTask(taskIMUGId);
    788                       SAVE_POINT
    789                       GetAverageImuData(pBuf);
    790          
    791                      last_test_imu_pkt_ctr = test_imu_pkt_ctr;
    792                      pBeacon_Data_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
    793          
    794                      ++i;      // next packet
    795                  }
    796          
    797                  SAVE_POINT  
    798                  CoPendSem(semIMUAllow, 0);
    799                  SAVE_POINT
    800                  calls++;
    801                  //HwGPOToggle(GPO_TP50);// test
    802                    uint8_t pushed = 0;
    803          
    804                  if (IMUdbgPrt) {         // It is for USB output now
    805                      __writeIMU((unsigned char*) pBeacon_Data_pkt, sizeof(struct Beacon_Data_pkt));
    806                  }
    807                  else {
    808          
    809                    // conditional send based on radio packets flags;
    810                    if ((config.radioPacketFlags & RADIOPACKET_IMU)
    811                      || ((config.radioPacketFlags & RADIOPACKET_BUTTONPRESS) && (last_button_state != pBeacon_Data_pkt->BK_Preamble.button_pr))
    812                      || ((config.radioPacketFlags & RADIOPACKET_BATTERY) && (battery_minutes != (secs/600)))
    813          			) {
    814                        if(!(pushed = RadioTxPktQueue(routerAddr, sizeof(struct Beacon_Data_pkt) , txBuf))) {
    815                          if (config.flags & FLAG_TRACE_IMU_QUEUE_FULL) {
    816                              TRACE("ERROR! Tx Buffer full\n\r");
    817                          }
    818                          SAVE_LINE
    819                        } else {
    820                          pushed_times++;
    821                          SAVE_LINE
    822                        }
    823                       SAVE_FUNC
    824                    }
    825                  }
    826                    if (!pushed || radio_off) {
    827                      semAllowPostTask = CoPostSem(semIMUAllow);
    828                      semAllow = 2;
    829                    }
    830          
    831                    last_button_state = pBeacon_Data_pkt->BK_Preamble.button_pr;
    832                    battery_minutes =  secs/600;
    833                    // reset tasksWDT
    834                    tasksWDT |= 0x0001;
    835              }
    836          }
    837          uint32_t now_sec;
    838          uint32_t tim;
    839          uint32_t old_sec;
    840          uint32_t old_tim;
    841          
    842          #ifndef STM3210C_EVAL
    843          extern OS_EventID semRFRxFrames;
    844          StatusType task2StatusType;
    845          uint32_t task2enter;
    846          uint8_t rx_reload;
    847          uint32_t rxReloaded;
    848          uint32_t task2_errors;
    849          extern uint8_t rxCount;
    850          
    851          struct realTime radioRxStart;
    852          struct realTime radioRxEnd;
    853          struct realTime radioRxWait;
    854          
    855          uint32_t rxTotalRcvd;
    856          uint32_t rxNotEmpty;
    857          extern uint32_t rxPackets;
    858          uint32_t lastTime;
    859          uint32_t span;
    860          uint16_t tim4_phase;
    861          
    862          int32_t acc_time_adjust;
    863          uint8_t  acc_adjust_count;
    864          uint8_t acc_done = 0;
    865          
    866          int16_t accs[32];
    867          struct realTime lastFrameTime;
    868          extern struct realTime frameTime;
    869          uint32_t savedFrameIdAtSync;
    870          uint16_t newTim3Phase, oldTim3Phase, lastTim3Phase;
    871          extern uint32_t trace_irq;
    872          
    873          extern int frameIdInced;
    874          
    875          /*******************************************************************************
    876          * Description    : [Task] Process Incoming Radio Packets
    877          * Input          :
    878          * Return         :
    879          *******************************************************************************/
    880          void TaskRadioRx(void* pdata) {
    881          
    882              static rxPkt_t *pRxPkt;
    883              static uint8_t lastFrameClock = 0;
    884          
    885              while (1) {
    886                RELOAD_WATCHDOG
    887                SAVE_POINT
    888                radioRxWait.sec = sec;
    889                radioRxWait.uSec = TIM1->CNT;
    890          
    891                __disable_interrupt();
    892                frameIdFlag = 1;
    893                __enable_interrupt();
    894                
    895                task2StatusType = CoPendSem(semRFRxFrames, 0);
    896                SAVE_POINT
    897                radioRxStart.sec = sec;
    898                radioRxStart.uSec = TIM1->CNT;
    899                assert(task2StatusType == E_OK);
    900          
    901                SAVE_POINT
    902                RadioIMU_WaitGrabSPI();
    903                SAVE_POINT
    904                if (rxFIFOError) {
    905                  rxFIFOError = 0;
    906                  ProcessRXError();
    907                  pRxPkt = NULL;
    908                } else {
    909                  pRxPkt = RadioRxPkt();
    910                  rxTotalRcvd++;
    911                }
    912                SAVE_POINT
    913          
    914                radioRxEnd.sec = sec;
    915                radioRxEnd.uSec = TIM1->CNT;
    916                RadioIMU_ReleaseSPI();
    917                if (pRxPkt == NULL) {
    918                  if (!radio_off) {
    919                    TRACE("bc=%d NULL packet, rxCount=%u @sec=%d\r\n", config.mySrcAddr, rxCount, sec);
    920                  }
    921                  continue;
    922                }
    923          
    924                SAVE_LINE
    925                rxNotEmpty++;
    926                // Check for Beacon frame types from the TimeKeeper.  Ignore other data packets
    927                // from beacons
    928                if (!((pRxPkt->fcf0 & 0x07) == 0 && pRxPkt->panId == config.panId
    929                    && (pRxPkt->destAddr == 0xFFFF))) { // FCF[2:0] = 802.15.4 Beacon Frame Type
    930                  continue;          
    931                }
    932                //additional check may be on source address
    933                /* RF Sync (Beacon) Packet */
    934          #ifdef NEW_BEACON
    935                /* RF Sync (Beacon) Packet */
    936                struct BeaconOldStruct *beacon = (struct BeaconOldStruct*) pRxPkt->payload;
    937                if (pRxPkt->payloadSize == sizeof(struct BeaconOldStruct)) {
    938                  //check for new structure
    939                  // uint32_t frameId
    940                  // uint8_t  0xA5 //magic for this packet version
    941                  // uint8_t sec;  // consecutive sec, increments every sec
    942                  // uint8_t frameClock; //100, 120, 180, 240 support
    943                  // uint8_t crc8
    944          
    945                  if (beacon->magic != 'BT') {
    946                    notValids++;
    947                    TRACE("Beacon received: unknown magic 0x%04X\n\r", beacon->magic);
    948                    continue;
    949                  }
    950                  uint8_t check = crc8(pRxPkt->payload, sizeof(struct BeaconOldStruct) - 1);
    951                  if (check != beacon->crc8) {
    952                    notValids++;
    953                    TRACE("Beacon received: CRC8 failed \r\n");
    954                    continue;
    955                  }
    956                  switch (beacon->frameClock) {
    957                  case FRAME_CLOCK_100:
    958                  case FRAME_CLOCK_120:
    959                  case FRAME_CLOCK_180:
    960                  case FRAME_CLOCK_240:
    961                    break;
    962                  default:
    963                    TRACE("Beacon received: Unsupported frame clock %d\n\r", beacon->frameClock);
    964                    notValids++;
    965                    continue;
    966                  }
    967                  static uint32_t lastFrameId = 0;
    968                  static uint8_t lastTick = 0;
    969                  static uint8_t changeFrameClock = 0;
    970                  uint8_t valid = 0;
    971          
    972                  if (lastFrameClock == beacon->frameClock ) {
    973                    if (beacon->tick > lastTick) {
    974                      uint32_t diff = beacon->tick - lastTick;
    975                      diff *= lastFrameClock;
    976                      if ((beacon->frameId - lastFrameId) == diff) {
    977                        valid = 1;
    978                        if (changeFrameClock) {
    979                          // TODO
    980                          TRACE("Beacon: changing frameClock to %u\r\n", lastFrameClock);
    981                        }
    982                        changeFrameClock = 0;
    983                      }
    984                    }
    985                  } else {
    986                    changeFrameClock = 1;
    987                    if (lastFrameId != 0) {
    988                      changeClocks++;
    989                    }
    990                  }
    991                  int32_t diffFrameId = beacon->frameId - lastFrameId;
    992                  uint16_t diffTick = (((uint16_t) beacon->tick + 256) - lastTick)%256;
    993                  /*Here seems is a problem:
    994                    When signal weak, it may catch lost sync, then before ticks
    995                    run off 256 (less then 256 sec later) it catches another sync,
    996                    by that time frameId may be already off by 1, if it receives consecutive sync
    997                    it may recover, but if not, it may stack with 1 frame offset.
    998                  Solution: limit valid span for consecutive syncs to 10 sec,
    999                   use diffSec*/
   1000                  uint32_t diffSec = diffFrameId/beacon->frameClock;
   1001                  if ((diffTick * beacon->frameClock) == diffFrameId && diffSec < 10) {
   1002                    valid = 1;
   1003                    Valids++;
   1004                  }
   1005                  if (!valid && lastFrameId != 0) {
   1006                    TRACE("New bcn id:%u>%u tick:%u>%u clk:%u>%u\r\n",
   1007                    lastFrameId, beacon->frameId, lastTick, beacon->tick,
   1008                    lastFrameClock, beacon->frameClock);
   1009                    newbcn++;
   1010                  }
   1011          
   1012                  if (lastFrameId != beacon->frameId ||
   1013                    lastFrameClock != beacon->frameClock ||
   1014                    lastTick != beacon->tick) {
   1015                    lastFrameId = beacon->frameId;
   1016                    lastFrameClock = beacon->frameClock;
   1017                    lastTick = beacon->tick;
   1018                  }
   1019                  if (!valid) {
   1020                    continue;
   1021                  }
   1022                } else /*if (pRxPkt->payloadSize != 4)*/{
   1023                  continue;
   1024                }
   1025          
   1026          #endif
   1027                if (use_sync) {
   1028                  trace_irq = 1;
   1029                  tim4_phase = TIM4->CCR1;
   1030                }
   1031          
   1032                if (firstTime == 1) {
   1033                  TIM_SetAutoreload(TIM3, TIM3_AUTORELOAD);
   1034                  TIM_SetAutoreload(TIM2, TIM_AUTORELOAD);
   1035                  TIM_SetCompare2(TIM3, TIM3_AUTORELOAD - (config.ledOnOffs >> 1));
   1036                  TIM_SetCompare3(TIM3, TIM3_AUTORELOAD - (config.ledOffOffs >> 1));
   1037                  // Instead of modulus maybe boundry check!
   1038                  TIM_SetCompare3(TIM2, ( (uint16_t)(txTimeSlot) ) );
   1039                  // Second 50ms (or half of a TK Tx Beacon interval later) - 3000 (5ms)
   1040                  // 5ms is the combination of the first two time slots which don't get a
   1041                  // Edit -- Can't subtract 5ms off second because it takes 47.5ms before
   1042                  // the next set of 5 IMU packets are ready.  This is a waste of BW.
   1043                  // maybe could use it some other way.
   1044                  // second transmission per frame.
   1045                  TIM_SetCompare4(TIM2, ( (uint16_t)((((TIM_AUTORELOAD + 1) >> 1) + txTimeSlot) - 0) ) );
   1046                  firstTime = 0;
   1047                }
   1048          
   1049                // synchronize local to remote FrameIDs
   1050                if (!(*(uint32_t*)pRxPkt->payload)) {
   1051                  continue;
   1052                }
   1053                
   1054                static uint32_t newTKFrameId = 0; newTKFrameId = *(uint32_t*)pRxPkt->payload;
   1055          
   1056                static int skipPackets = 0;    // TODO! this is a temporary solution. There must be an issue in T.K. that sends out frame sequency like this 100, 200, 200, 300, 500, 600 
   1057                if (skipPackets > 0) {
   1058                  TRACE("bc=%d skip TK frame %d detected tick=%d. AtSync(%d, %d)", config.mySrcAddr, newTKFrameId, beacon->tick, frameIdAtSync, tim3PhaseAtSync);
   1059                  --skipPackets;
   1060                  continue;
   1061                }
   1062                
   1063                if (newTKFrameId == tkFrameId) {
   1064                  TRACE("bc=%d stale TK frame %d detected tick=%d. AtSync(%d, %d)", config.mySrcAddr, newTKFrameId, beacon->tick, frameIdAtSync, tim3PhaseAtSync);
   1065                  skipPackets = 3;
   1066                  continue;       // ignore stale FrameIDs
   1067                } 
   1068                
   1069                tkFrameId = newTKFrameId;
   1070                    
   1071                // A frameId pair (frameId, phase) represents time: frameId * (TIM3_AUTORELOAD + 1) + (TIM3_AUTORELOAD - phase)
   1072                // Timekeeper sends out its frame Id at phase TIM3_AUTORELOAD --> (tkFrameId, TIM3_AUTORELOAD - 0)              // coundown perspective
   1073                // While beacon local frame is (frameIdAtSync, tim3PhaseAtSync)
   1074                // new time formula: (Fa - Fs + Fr) + Delta  ==> (Frame pair being adjusted - Frame pair at sync + Remote frame pair) + Delta
   1075                // or, formula: (frameId - frameIdAtSync + tkFrameId + frameAdjust) * (TIM_AUTORELOAD + 1) - tim3_phase + tim3PhaseAtSync;  
   1076                // enter critical section make sure that TIM3 is NOT processing frameId increment or TIM3 is about to underflow  
   1077                static uint32_t tim3_phase;      
   1078                while(1) {
   1079                  __disable_interrupt();
   1080                  
   1081                  if (TIM_GetITStatus(TIM3, TIM_IT_Update) == SET) {
   1082                    __enable_interrupt();
   1083                    HwWait(1);
   1084                    continue;
   1085                  }
   1086                  
   1087                  tim3_phase = TIM3->CNT;
   1088                  if (tim3_phase < 10) {  
   1089                    __enable_interrupt();   
   1090                    HwWait(1);
   1091                    continue;
   1092                  }
   1093                  
   1094                  break;
   1095                }
   1096                                    
   1097                static uint32_t frameIdAdjusting = 0;     
   1098                static int32_t frameDiff = 0; frameDiff = frameId - frameIdAdjusting; 
   1099                frameIdAdjusting = frameId;   
   1100                static uint16_t adjustedPhase = 0;
   1101                
   1102                frameId = frameIdAdjusting + ((int32_t)tkFrameId - frameIdAtSync) + FRAME_DIFF_DELTA;     // frameAdjust is a constant of this system, experimental value              
   1103                
   1104                if (tim3_phase > tim3PhaseAtSync) {
   1105                  --frameId;
   1106                  adjustedPhase = 0 - (tim3PhaseAtSync - tim3_phase);
   1107                } else {
   1108                  adjustedPhase = TIM3_AUTORELOAD - (tim3PhaseAtSync - tim3_phase);
   1109                } 
   1110                                
   1111                TIM_SetCounter(TIM3,(uint16_t)adjustedPhase);
   1112                TIM_SetCounter(TIM2,(uint16_t)adjustedPhase);
   1113          
   1114                // pair subtraction and turns to phase only for measurement 
   1115                static uint32_t adjustedFrameId = 0; adjustedFrameId = frameId;
   1116                static int32_t phaseDiff = 0; phaseDiff = ((int)frameId - frameIdAdjusting) * (TIM3_AUTORELOAD + 1) + (TIM3_AUTORELOAD - tim3_phase) - (TIM3_AUTORELOAD - adjustedPhase);             // could overflow but should get back to normal if beacon synced with T.K. 
   1117                static int32_t avgPhaseDiffPerFrame = 0xFFFFFF;
   1118                static uint32_t oldARR = 0; oldARR = TIM3->ARR;
   1119                if (frameDiff > 0) {
   1120                  avgPhaseDiffPerFrame = phaseDiff / frameDiff;
   1121                  uint16_t newARR = oldARR + avgPhaseDiffPerFrame;
   1122                  if (newARR!= 0 && abs(newARR - TIM3_AUTORELOAD) <= 10) {         // greater than 10 / frame, crystal of the beacon is not accurate enough and not suitable for this application
   1123                    TIM_SetAutoreload(TIM3, newARR);
   1124                    TIM_SetAutoreload(TIM2, newARR);
   1125                  } else {
   1126                    avgPhaseDiffPerFrame = 99;      // set to max
   1127                  }  
   1128                } else {
   1129                  avgPhaseDiffPerFrame = 99;      // set to max
   1130                }
   1131          
   1132          #ifdef CIRCULAR_LOG
   1133                W_LOG(CoGetOSTime(), LOG_TYPE_FRAMEADJUST, tkFrameId);
   1134                W_LOG(CoGetOSTime(), LOG_TYPE_CAPTURE, tim3_phase);
   1135                W_LOG(CoGetOSTime(), LOG_TYPE_FRAMEDIFF, phaseDiff);
   1136          #endif
   1137                // after inerrupt enabled, these value can be modified at once. So save a copy for this function call for tracing purpose
   1138                static int savedFrameIdInced = 0; savedFrameIdInced = frameIdInced;
   1139                static uint32_t saved_trace_irq = 0; saved_trace_irq = trace_irq;
   1140                __enable_interrupt();
   1141          
   1142                if (config.flags & FLAG_TRACE_SYNC) {
   1143                  //TRACE(" tim3_phase=%u inced=%u, phase diff=%d avg phase diff=%d\r\n", tim3_phase, savedFrameIdInced, phaseDiff, avgPhaseDiffPerFrame);
   1144                  TRACE("bc=%d tk(%d,,%3d) AtSync(%d, %d) Adjusting(%d, %d) adjusted(%d, %d) diff(%d, %d, arr%u)\r\n", config.mySrcAddr, tkFrameId, beacon->tick, frameIdAtSync, tim3PhaseAtSync, frameIdAdjusting, tim3_phase, adjustedFrameId, adjustedPhase, phaseDiff, avgPhaseDiffPerFrame, oldARR);
   1145                }
   1146                
   1147                if (config.flags & FLAG_DEBUG) {
   1148                  uint32_t tr = saved_trace_irq;
   1149                  TRACE("trace_irq=%d at tim3Phase=%d\r\n", tr, tim3_phase);
   1150                  TRACE("tkFrameId=%d frameIdAtSync=%d tim3PhaseAtSync=%d localFrameId=%d adjustedPhase=%d\r\n", tkFrameId, frameIdAtSync, tim3PhaseAtSync, frameId);
   1151                }
   1152                
   1153                if (config.flags & FLAG_TRACE_ADJUST) {
   1154                  TRACE("adjust=%d tim3_phase=%u tim4_phase=%u @%d.%d\r\n",
   1155                        config.time_adjust,
   1156                        tim3_phase, tim4_phase, sec, TIM1->CNT);
   1157                }
   1158                
   1159                if ((sec - lastTime) > span) {
   1160                  span = sec - lastTime;
   1161                  TRACE("No TK sync for %d sec @ %d\r\n", span, sec);
   1162                }
   1163                lastTime = sec;
   1164                frameOffset = TIM1->CNT;
   1165                successBeacons++;
   1166          
   1167                // record RSSI of Sync Packet to relay back to TK
   1168                beaconRSSI =  0x5A; // temp change to store signature. // pRxPkt->rssi;
   1169          
   1170                // allow up to 3 tx pkts per sync pkt
   1171                beaconInSync++;
   1172                if(beaconInSync > 3)
   1173                {
   1174                  beaconInSync = 3;
   1175                }
   1176                // Issue TODO - if Beacon out of syncronization,
   1177                // it keeps trying to send (Task 6), may not receive
   1178                // anything, as this task has lower priority
   1179                // CoAwakeTask(task1Id);
   1180                // CoAwakeTask(taskRadioTxId);
   1181              }   //of while
   1182          }
   1183          
   1184          
   1185          /*******************************************************************************
   1186          * Description    : [Task] RF Chan Scan, then Monitor GPO_PWRON Power Switch
   1187          * Input          :
   1188          * Return         :
   1189          *******************************************************************************/
   1190          void Task3(void* pdata){
   1191            static StatusType result;
   1192            static uint16_t holdCount = 0;
   1193            rfChan = config.rfChan;
   1194            static uint8_t pwrbtnflag=0;
   1195            static uint8_t task3event=0;
   1196          
   1197            //initialize routine, debounce pwr button. 
   1198            while(HwGPIState(GPI_SW_PWR)){
   1199              RELOAD_WATCHDOG
   1200              SAVE_POINT
   1201              if(holdCount++>=4) break;
   1202              CoTickDelay(50);
   1203            }
   1204            if((holdCount<4 || BattUnion.BatteryLevel[1]<0xBB)  //device not held or low battery
   1205               && (!HwGPIState(GPI_USB_VBUS))){                 //and if device not connected external source
   1206              CoSchedLock();                                    //shut down sequence
   1207              HwGPOLow(GPO_RF_EN);
   1208              HwGPOLow(GPO_VBATT_ADC_EN);
   1209              HwGPOInitOC(GPO_USB_VBUS); 
   1210              HwGPOLow(GPO_USB_VBUS);  
   1211              SAVE_POINT
   1212              HwGPOLow(GPO_PWRON); 
   1213              while (1);
   1214            }
   1215            UI_StateMachine = UI_POWERON_STATE; //make sure statemachine in correct state prior to initializing UI
   1216            CoAwakeTask(taskUIId);    
   1217          
   1218            // NO RF Scan => send IMU data to TK address stored in FLASH Config   
   1219            IMUInit();
   1220            halted = (IMUPresent==1)? 1:0;
   1221            routerAddr = config.routerDstAddr;
   1222            SetTimeSlot();
   1223            /* we're now in business */
   1224            TRACE("RF CHAN: %d\n\r", rfChan);
   1225          
   1226            ButtonA = (tButton) {.ButtonID = BUTTON1, .debounce_count = 0, .current_state = BUTTON_OFF, .event_flag = 0};
   1227            ButtonB = (tButton) {.ButtonID = BUTTON2, .debounce_count = 0, .current_state = BUTTON_OFF, .event_flag = 0};
   1228            
   1229            CoAwakeTask(task1Id);  // start imu process
   1230            CoAwakeTask(taskRadioRxId);
   1231          
   1232            CoPendSem(semInkUI,0);  //hack: wait till the home screen has been loaded.
   1233            CoPostSem(semInkUI);
   1234            while(HwGPIState(GPI_SW_PWR)){
   1235              CoTickDelay(50);  //wait for user to release pwr button before entering to main task3 loop. don't want to jump directly to menu screen.
   1236            }
   1237            holdCount=0;
   1238          	while (1) {
   1239          		SAVE_POINT
   1240          		CoTickDelay(100);
   1241          		SAVE_POINT
   1242          		RELOAD_WATCHDOG
   1243          #ifndef DISABLE_PWR_SW
   1244          if((holdCount<30 || BattUnion.BatteryLevel[1]<0xBB)  //device not held or low battery
   1245               && (!HwGPIState(GPI_USB_VBUS))){                 //and if device not connected external source
   1246                //holdCount = (holdCount+1>BUTTON_DEBOUNCE)? BUTTON_DEBOUNCE:holdCount+1;
   1247                if(holdCount++>30){                   //temporary method of shut down via holding.
   1248                  CoPendSem(semInkUI,0);
   1249                  GFX_FillBuffer(black);
   1250                  GFX_DrawBitMap(UI_LOGO_COORD, logo, logo_dimensions);
   1251                  setFont(smallfont);
   1252                  setCursor(UIPOWER_TEXT_COORD);
   1253                  GFX_Print("Turning Off", strlen("Turning Off"),centeralign, black, gray_l);
   1254                  WaitGrabEInk();
   1255                  update(fullrefresh);
   1256                  ReleaseEInk();
   1257                  GFX_FillBuffer(black);
   1258                  WaitGrabEInk();
   1259                  update(fullrefresh);
   1260                  ReleaseEInk();
   1261                  CoSchedLock();                      //shut down sequence
   1262                  HwGPOLow(GPO_RF_EN);
   1263                  HwGPOLow(GPO_VBATT_ADC_EN);
   1264                  HwGPOInitOC(GPO_USB_VBUS); 
   1265                  HwGPOLow(GPO_USB_VBUS);  
   1266                  HwGPOLow(GPO_PWRON) ; 
   1267                  while (1);
   1268                }
   1269              }
   1270              else{
   1271                //if(holdCount == BUTTON_DEBOUNCE){
   1272                if(holdCount>=BUTTON_DEBOUNCE){
   1273                  //X button was pressed
   1274                  task3event = 1;
   1275                  pwrbtnflag=1;
   1276                }
   1277                holdCount=0;
   1278              }
   1279          #endif // disable power switch
   1280          
   1281              task3event |= getButtonState(&ButtonA);
   1282              task3event |= getButtonState(&ButtonB);
   1283          
   1284              if(task3event){
   1285                if(UI_StateMachine==UI_HOME_STATE){
   1286                  //1. notify task1 if buttons A or B were pressed
   1287                  //2. if button X was pressed, notify UI
   1288                  if(pwrbtnflag && CoAcceptSem(semInkUI)==E_OK){
   1289                    task3event=0;
   1290                    pwrbtnflag=0;
   1291                    UI_BUTTONdata |= UI_PWRBTNFLAG;
   1292                    CoSetFlag(flagBtn_UI);
   1293                    CoPostSem(semInkUI);
   1294                  }
   1295                  if (config.flags & FLAG_TRACE_ASYNC) {
   1296                    if(ButtonA.event_flag){ButtonA.event_flag=0; TRACE("Btn A PRESS\r\n");}
   1297                    if(ButtonB.event_flag){ButtonB.event_flag=0; TRACE("Btn B PRESS\r\n");}
   1298                  }
   1299                }
   1300                else if(CoAcceptSem(semInkUI)==E_OK){   //any other state. 
   1301                  if(pwrbtnflag) UI_BUTTONdata |= UI_PWRBTNFLAG;
   1302                  if(ButtonA.event_flag) UI_BUTTONdata |= UI_BTNAFLAG;
   1303                  if(ButtonB.event_flag) UI_BUTTONdata |= UI_BTNBFLAG;
   1304                  pwrbtnflag=0; ButtonA.event_flag=0;  ButtonB.event_flag=0; task3event =0;
   1305                  CoSetFlag(flagBtn_UI);
   1306                  CoPostSem(semInkUI);
   1307                }
   1308                else{
   1309                  if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("semaphore blocked\r\n");
   1310                }
   1311              }
   1312            }
   1313          }
   1314          
   1315          #endif
   1316          
   1317          /*******************************************************************************
   1318          * Description : Write Configuration to FLASH
   1319          * Input       : -
   1320          * Return      : -
   1321          *******************************************************************************/
   1322          #define FLASH_NO_ADDRESS_CHECK
   1323          
   1324          uint32_t WritePage(tPage *page) {
   1325          
   1326            uint8_t *pointer = (uint8_t*) page->address;
   1327            uint32_t result = 0;
   1328            uint16_t cycles = (page->count + 3)/4;
   1329          
   1330            FLASH_Unlock();
   1331          
   1332            do {
   1333          #ifndef FLASH_NO_ADDRESS_CHECK
   1334              if (page->address < APP_UPLOAD_ADDRESS || page->address > 0x803FFFF) {
   1335                page->count = 0;
   1336                result = ERROR_FLASH_ADDRESS;
   1337                break;
   1338              }
   1339          #endif
   1340              if ((result = FLASH_ErasePage(page->address)) != FLASH_COMPLETE) {
   1341                page->count = 0;
   1342                break;
   1343              }
   1344          
   1345              result = 0;
   1346              for (uint16_t i = 0; i < cycles; i++) {
   1347                uint32_t offset = i << 2;
   1348                uint32_t word = page->data[offset + 3] << 24;
   1349                word |= page->data[offset + 2] << 16;
   1350                word |= page->data[offset + 1] << 8;
   1351                word |= page->data[offset];
   1352          
   1353                  if ((result = FLASH_ProgramWord(page->address + offset, word)) != FLASH_COMPLETE) {
   1354                      page->count = offset;
   1355                      break;
   1356                  }
   1357              }
   1358              result = 0;
   1359              // verification
   1360              for (uint16_t i = 0; i < page->count; i++) {
   1361                if (*(pointer) != page->data[i]) {
   1362                  result = ERROR_FLASH_VERIFICATION;
   1363                  page->count = i;
   1364                  break;
   1365                }
   1366                pointer++;
   1367              }
   1368          
   1369            } while (0);
   1370          
   1371            FLASH_Lock();
   1372          
   1373            return result;
   1374          }
   1375          
   1376          #if 1
   1377          
   1378          uint32_t ReadPage(tPage *page) {
   1379          
   1380            uint8_t *pointer = (uint8_t *) page->address;
   1381            uint32_t result = 0;
   1382          
   1383          
   1384            do {
   1385          #ifndef FLASH_NO_ADDRESS_CHECK
   1386              if (page->address < 0x8000000 || page->address > 0x803FFFF) {
   1387                page->count = 0;
   1388                result = ERROR_FLASH_ADDRESS;
   1389                break;
   1390              }
   1391          #endif
   1392              // verification
   1393              for (uint16_t i = 0; i < page->count; i++) {
   1394                page->data[i] = *pointer;
   1395                pointer++;
   1396              }
   1397          
   1398            } while (0);
   1399          
   1400            return result;
   1401          
   1402          }
   1403          #endif
   1404          
   1405          /**
   1406            * @brief  Download a file via serial port
   1407            * @param  None
   1408            * @retval None
   1409            */
   1410          uint8_t tab_1024[1024];
   1411          
   1412          static tPage page = {FLASH_PROD_AREA};
   1413          //static uint32_t CurrentUploadAddress = APP_UPLOAD_ADDRESS;
   1414          static uint16_t CurrentDataPointer = 0x00;
   1415          //static uint8_t mem_data[PAGE_SIZE];
   1416          static uint16_t packet = 0;
   1417          
   1418          static struct PacketHeader *header;
   1419          uint32_t SerialDownload(const char* decoded, uint16_t len, uint8_t type)
   1420          {
   1421            struct FirmwarePacketHeader *frmHeader;
   1422          
   1423            uint8_t copy_len = 0;
   1424          
   1425            uint32_t ret = 0;
   1426            // Data comes in format:
   1427            //U 0 0 DATA\r\n
   1428            // so, DATA starts from 6th index
   1429            do {
   1430              if (len < (sizeof(struct FirmwarePacketHeader))) {
   1431                ret = ERROR_WRONG_PACKET;
   1432                break;
   1433              }
   1434              frmHeader = (struct FirmwarePacketHeader *) (decoded);
   1435              copy_len = header->size - /*7*/ (sizeof(struct PacketHeader) + sizeof(struct FirmwarePacketHeader));
   1436              if (
   1437                  ((type == DEV_CMD_SET_PROD_AREA) &&
   1438                  (copy_len > 128 || (copy_len + CurrentDataPointer) > (FLASH_PROD_AREA + FLASH_PROD_AREA_SIZE)))
   1439                  ||
   1440                  frmHeader->index != packet) {
   1441                ret = ERROR_WRONG_PACKET;
   1442                break;
   1443              }
   1444              if (copy_len) {
   1445                memcpy(&page.data[CurrentDataPointer], (decoded + /*4*/ sizeof(struct FirmwarePacketHeader)), copy_len);
   1446                CurrentDataPointer += copy_len;
   1447                page.count += copy_len;
   1448                if ((frmHeader->index + 1) == frmHeader->count || CurrentDataPointer == sizeof(page.data)) {
   1449                  //time to write
   1450                  WritePage(&page);
   1451                  page.address = FLASH_PROD_AREA;
   1452                  CurrentDataPointer = 0;
   1453                  page.count = 0;
   1454                  if ((frmHeader->index + 1) == frmHeader->count) {
   1455                    // finished
   1456                    page.address = FLASH_PROD_AREA;
   1457                  }
   1458                }
   1459              }
   1460              ret = frmHeader->index << 16;
   1461            } while (0);
   1462            // reset for error
   1463            if (ret & 0xFFFF) {
   1464              CurrentDataPointer = 0;
   1465              page.address = FLASH_PROD_AREA;
   1466              page.count = 0;
   1467              packet = 0;
   1468            } else {
   1469              packet++;
   1470            }
   1471            return ret;
   1472          }
   1473          
   1474          tPage page;
   1475          uint16_t use_tim3_phase = 0;
   1476          
   1477          /*******************************************************************************
   1478          * Description    : [Task] Implements Simple Text Command Console
   1479          * Input          :
   1480          * Return         :
   1481          *******************************************************************************/
   1482          void TaskConfig(void* pdata) {
   1483            static char buff[512] = "";
   1484            char *s = buff;
   1485          //    static int i;
   1486            static char cmd;
   1487            static int addr;
   1488            static int32_t value;
   1489          
   1490            while (1) {
   1491              SAVE_POINT
   1492              // get a line of values from stdin
   1493              s = buff;
   1494              mygets(s); 	
   1495              if (ValidateCommandLine(s, strlen(s)) == 0) {
   1496                TRACE("Incorrect packet\r\n");
   1497                continue;
   1498              }
   1499                      
   1500              SAVE_POINT
   1501              RELOAD_WATCHDOG
   1502              // parse the line of hexadecimal values
   1503              //i = sscanf(s, "%c %d %d", &cmd, &addr, &value);
   1504              //if (i < 1) continue;
   1505              cmd = *s;
   1506              switch (cmd) {
   1507                case '2':
   1508                  RadioPrint2520Registers(addr);
   1509                  SAVE_POINT
   1510                  break;
   1511                case 'd': // Display configuration
   1512                  //if (i != 1) continue;
   1513                  PrintConfig();
   1514                  SAVE_POINT
   1515                  break;
   1516                case '1':
   1517                  // Test Reading IMU DMA frame   // TODO!!! IMU accessing must be critical section
   1518                  CoClearFlag(flagIMUNewData); 
   1519          				RadioIMU_WaitGrabSPI();
   1520          				IMUProcess();
   1521                  TRACE("%X, %X, %X\n\r",*(uint16_t*)&IMU_RawData[0], *(uint16_t*)&IMU_RawData[2], *(uint16_t*)&IMU_RawData[4]);
   1522                  TRACE("%X, %X, %X\n\r",*(uint16_t*)&IMU_RawData[6], *(uint16_t*)&IMU_RawData[8], *(uint16_t*)&IMU_RawData[10]);
   1523                  SAVE_POINT
   1524          				RadioIMU_ReleaseSPI();
   1525                  SAVE_POINT
   1526                  break;
   1527                case 's': // Set configuration
   1528                  {
   1529                  uint32_t      pattern = 0;
   1530                  uint8_t       ledBits = 0;
   1531                  uint8_t       ledId  = 0;
   1532                  // if (addr >= 19 && addr <= 21) {
   1533                  //need to do additional scanf - it has form of
   1534                  //s 19 8bit 32bit 8bit
   1535                  // all values are decimal
   1536                  //uint8_t       ledId = value;
   1537                  char *p = s;
   1538                  //skip s addr value
   1539                  while (*p != 0 &&!isspace(*p)) { p++;} p++;
   1540                  addr = strtoul(p, NULL, 10);
   1541                  while (*p != 0 &&!isspace(*p)) { p++;} p++;
   1542                  value = strtoul(p, NULL, 10);
   1543                  while (*p != 0 &&!isspace(*p)) { p++;} p++;
   1544                  pattern = strtoul(p, NULL, 10);
   1545                  while (*p != 0 &&!isspace(*p)) { p++;} p++;
   1546                  ledBits = strtoul(p, NULL, 10);
   1547                  while (*p != 0 &&!isspace(*p)) { p++;} p++;
   1548                  ledId = strtoul(p, NULL, 10);
   1549                  // }
   1550                  SetConfig(addr, value,  pattern, ledBits, ledId);
   1551                  }
   1552                  SAVE_POINT
   1553                  break;
   1554                case 'v': // saVe configuration
   1555                  //if (i != 1) continue;
   1556                  WaitGrabI2C();
   1557                  SaveConfig(&config);
   1558                  ReleaseI2C();
   1559                  break;
   1560                case 'h': // Halt IMU Tx
   1561                  //if (i != 1) continue;
   1562            			EXTI->IMR &= ~GPI_IMU_INT_EXTI_LINE;
   1563                  halted = 1;
   1564                  break;
   1565                case 'c': // Continue IMU Tx
   1566                  //if (i != 1) continue;
   1567                  EXTI->IMR |= GPI_IMU_INT_EXTI_LINE;
   1568          				halted = 0;
   1569                break;
   1570          #if 0
   1571                case 'w': // Write IMU_A-Reg
   1572                  //if (i != 3) continue;
   1573                  //CoTickDelay(2);
   1574                  IMURegWr(addr, SPI_A_IMU, value);
   1575                  break;
   1576                case 'r': // Read IMU_A-Reg
   1577                  //if (i != 2) continue;
   1578                  //CoTickDelay(2);
   1579                  TRACE("Accel Reg%02X = %04X\n\r", addr, (int)IMURegRd(addr, SPI_A_IMU));
   1580                  break;
   1581                case 'W': // Write IMU_G-Reg
   1582                  //if (i != 3) continue;
   1583                  //CoTickDelay(2);
   1584                  IMURegWr(addr, SPI_G_IMU, value);
   1585                  break;
   1586                case 'R': // Read IMU_G-Reg
   1587                  //if (i != 2) continue;
   1588                  //CoTickDelay(2);
   1589                  TRACE("Gyro Reg%02X = %04X\n\r", addr, (int)IMURegRd(addr, SPI_G_IMU));
   1590                  break;
   1591          #endif
   1592                case '-':  // dec Tx power
   1593                  if(config.TxLevel ==0 ||config.TxLevel > 8 ){
   1594                    config.TxLevel =8; // sizeof(uint8_t TxAmpValues);
   1595                  }else{
   1596                    config.TxLevel--;
   1597                  }
   1598                  RadioSetRFLevel(config.TxLevel);
   1599                  SAVE_POINT
   1600                  TRACE("RF Tx Level: %X\n\r", TxAmpValues[config.TxLevel]);
   1601                  break;
   1602                case '+':  // increment Tx power
   1603                  if(config.TxLevel >= 8){
   1604                    config.TxLevel = 0; // sizeof(uint8_t TxAmpValues);
   1605                  }else{
   1606                    config.TxLevel++;
   1607                  }
   1608                  RadioSetRFLevel(config.TxLevel);
   1609                  SAVE_POINT
   1610                  TRACE("RF Tx Level: %X\n\r", TxAmpValues[config.TxLevel]);
   1611                  break;
   1612                case '.': // IMU debug print
   1613                  //if (i != 1) continue;
   1614                  TRACE("IMU Debug print:\n\r");
   1615                  IMUdbgPrt = !IMUdbgPrt;
   1616                  break;
   1617                case 'y': // Serial Number printout
   1618                  //if (i != 1) continue;
   1619                  TRACE("CPU Serial #%04x:%04x:%04x \n\r",ARM_proc_SN.a,ARM_proc_SN.b,ARM_proc_SN.c );
   1620                  break;
   1621                case 'F':
   1622                  TRACE("Framebits: %d\r\n", config.frameBits);
   1623                  break;
   1624          #if 0
   1625                case '~':  // reset default settings
   1626                  TRACE("Restoring Default Settings \n\r");
   1627                  memcpy((void *)&config, (void *)&backup_config, sizeof(config));
   1628                  break;
   1629          #endif
   1630                case 't':   // trace / debug
   1631                  {
   1632                  char *p = NULL;
   1633                  while (*s && isspace(*(++s)));
   1634                  if (!*s) {
   1635                    break;
   1636                  }
   1637                  addr = strtoul(s, &p, 10);
   1638                  while (*p && isspace(*(++p)));
   1639                  if (*p) {
   1640                    value = strtoul(p, NULL, 10);
   1641                  } else {
   1642                    value = 0;
   1643                  }
   1644                  switch (addr) {
   1645                    case 0:
   1646                      {
   1647                        config.flags ^= FLAG_TRACE_ENABLE;
   1648                      }
   1649                      break;
   1650                    case 1:
   1651                      {
   1652                        config.flags ^= FLAG_TRACE_TIMESLOT;
   1653                      }
   1654                      break;
   1655                    case 2:
   1656                      {
   1657                        config.flags ^= FLAG_TRACE_SYNC;
   1658                      }
   1659                      break;
   1660                    case 3:
   1661                      {
   1662                        config.flags ^= FLAG_TRACE_IMU_QUEUE_FULL;
   1663                      }
   1664                      break;
   1665                    case 4:
   1666                      {
   1667                        config.flags ^= FLAG_TRACE_USE_TIMESLOT;
   1668                      }
   1669                      break;
   1670                    case 5:
   1671                      {
   1672                        config.flags ^= FLAG_TRACE_USE_PROTO_CMD_LINE_RESP;
   1673                      }
   1674                      break;
   1675                    case 6:
   1676                      {
   1677                        // radio off
   1678                        radio_off = 1;
   1679                      }
   1680                      break;
   1681                    case 7:
   1682                      {
   1683                        // radio on
   1684                        radio_off = 0;
   1685                      }
   1686                      break;
   1687                    case 8:
   1688                      {
   1689                        struct WhoAmI me;
   1690                        memcpy(me.id, (uint8_t *)(0x1FFFF7E8), 12);
   1691                        me.type = 3; // beacon
   1692                        me.module = 2;
   1693                        __writeCmdLineRespPacket((void *)&me,  sizeof(me), DEV_RESP_WHOAMI);
   1694                      }
   1695                      break;
   1696                    case 9:
   1697                      {
   1698                        config.flags ^= FLAG_TRACE_BEACON;
   1699                      }
   1700                      break;
   1701                    case 10:
   1702                      {
   1703                        config.flags ^= FLAG_TRACE_ASYNC;
   1704                      }
   1705                      break;
   1706                    case 11:
   1707                      {
   1708                        config.flags ^= FLAG_TRACE_CRC;
   1709                      }
   1710                      break;
   1711                    case 12:
   1712                      {
   1713                        //send_battery_info = 0;
   1714                        config.flags &= ~FLAG_SEND_BATTERY_INFO;
   1715                      }
   1716                      break;
   1717                    case 13:
   1718                      {
   1719                        //send_battery_info = 1;
   1720                        config.flags |= FLAG_SEND_BATTERY_INFO;
   1721                      }
   1722                      break;
   1723                    case 17: 
   1724                      {
   1725                        config.time_adjust = (int16_t) value;
   1726                        //I2C_EE_BufferWrite((uint8_t*) &time_adjust, 126, 2);
   1727                        WaitGrabI2C();
   1728                        SaveConfig(&config);
   1729                        whole_time_adjust = config.time_adjust/10;
   1730                        part_time_adjust = config.time_adjust%10;
   1731                        ReleaseI2C();
   1732                      } //no break comment? potential bug?
   1733                    case 18:
   1734                      {
   1735                        use_sync = 0;
   1736                      }
   1737                      break;
   1738                    case 19:
   1739                      {
   1740                        use_sync = 1;
   1741                      }
   1742                      break;
   1743                    case 20:
   1744                      {
   1745                        WaitGrabI2C();
   1746                        config.frameCountNoSync = value;
   1747                        SaveConfig(&config);
   1748                        ReleaseI2C();
   1749                      }
   1750                      break;
   1751                    case 41:
   1752                      {
   1753                        use_tim3_phase = value;
   1754                        break;
   1755                      }
   1756                    case 42:
   1757                      {
   1758                        config.flags ^= FLAG_DEBUG;
   1759                      }
   1760                      break;
   1761                    case 43:
   1762                      {
   1763                        TRACE("oldFrameTime @%d.%d frame=%u\n\r", oldFrameTime.sec, oldFrameTime.uSec, oldFrameIdAtSync);
   1764                        TRACE("newFrameTime @%d.%d frame=%u MsTimerAtSync=%u\n\r", newFrameTime.sec, newFrameTime.uSec, newFrameIdAtSync, MsTimerAtSync);
   1765                        TRACE("oldTim3Phase=%u newTim3Phase=%u tim_at_sec=%u\n\r", oldTim3Phase, newTim3Phase, tim_at_sec);
   1766                      }
   1767                      break;
   1768                    case 44:
   1769                      {
   1770                        config.flags |= FLAG_TRACE_ADJUST;
   1771                      }
   1772                    break;
   1773                    case 45:
   1774                      {
   1775                        config.flags &= ~FLAG_TRACE_ADJUST;
   1776                      }
   1777                    break;
   1778                    case 46:
   1779                      {
   1780                        TRACE("rxPkts=%u rxTotal=%u rxNotEmpty=%u sec=%u\r\n", rxPackets, rxTotalRcvd, rxNotEmpty, sec);
   1781                      }
   1782                      break;
   1783                    case 47:
   1784                      {
   1785                        FRAME_DIFF_DELTA = (int8_t) value;
   1786                      }
   1787                      break;
   1788                    case 48:
   1789                      {
   1790                        config.flags ^= FLAG_FRAMEID_24BITS;
   1791                        WaitGrabI2C();
   1792                        SaveConfig(&config);
   1793                        ReleaseI2C();
   1794                      }
   1795                      break;
   1796                    case 49:
   1797                      {
   1798                        TRACE(": rxWait @ %d.%d rxStart @ %d.%d\n\r", radioRxWait.sec, radioRxWait.uSec, radioRxStart.sec, radioRxStart.uSec);
   1799                        TRACE(": txStart @ %d.%d txEnd @ %d.%d queue_full=%d queue_size=%d\n\r", startRadioTx.sec, startRadioTx.uSec, endRadioTx.sec, endRadioTx.uSec, queue_full, inIdx);
   1800                        TRACE(": rxCount=%d rxFIFOError=%d rxErrors=%d\n\r", rxCount, rxFIFOError, rxErrors);
   1801                        CoTickDelay(10);
   1802                        TRACE(": rxFIFOTime %d.%d semTime2 %d.%d\n\r", rxFIFOTime.sec, rxFIFOTime.uSec, semTime2.sec, semTime2.uSec);
   1803                        TRACE(": excFlag0=0x%02X excFlag1=0x%02X excFlag2=0x%02X\n\r",cc2520_flags0, cc2520_flags1, cc2520_flags2);
   1804                        TRACE(": successBeacons=%d frameOffset=%d frameAdjust=%d\n\r", successBeacons, frameOffset, FRAME_DIFF_DELTA);
   1805                        TRACE(": remainOutOfSyncTime=%d frameIdCorrection=%d\n\r", remainOutOfSyncTime, lastFrameIdCorrection);
   1806                        CoTickDelay(10);
   1807                        TRACE(": tkFrameId=%d asserted=%d\r\n", tkFrameId, asserted);
   1808                        TRACE("errorFrameId=%u valids=%d notValids=%d lostSync=%d\r\n", errorFrameId, Valids, notValids, lostSync);
   1809                        TRACE("changeClocks=%d newbcn=%d corCount=%d drifts=%u last_drift=%d\r\n", changeClocks, newbcn, frameIdCorrectionCount, drift, last_drift);
   1810                        extern uint8_t led_blinking;
   1811                        TRACE("led blinking=%d\r\n", led_blinking);
   1812                      }
   1813                      break;
   1814                    case 52:
   1815                      {
   1816                        uint32_t ram = (uint32_t) value & 0xFFFFFFFE;
   1817                        if (ram >= 0x20000000 && ram <= 0x2000ffff) {
   1818                          uint32_t atRam = *((uint32_t*) (ram));
   1819                          TRACE("Mem at 0x%08X=0x%08X\n\r", ram, atRam);
   1820                        } else {
   1821                          TRACE("Mem addr error\n\r");
   1822                        }
   1823                      }
   1824                      break;
   1825                    case 54:
   1826                      {
   1827                        RadioPrint2520Registers(addr);
   1828                      }
   1829                      break;
   1830                    case 55:
   1831                      {
   1832                        if (value > 0 && value < 30000) {
   1833                          txTimeSlot = value;
   1834                          firstTime = 1;
   1835                          TRACE("New timeslot offset = %u\r\n", txTimeSlot);
   1836                        }
   1837                      }
   1838                      break;
   1839          #ifdef CIRCULAR_LOG
   1840                    case 56:
   1841                      {
   1842                        uint16_t indx = 0;
   1843                        uint16_t size = (LOG_SIZE/sizeof(tLogStruct));
   1844                        TRACE("Current SysTickCount: %d, size=%d\n\r", (uint32_t) CoGetOSTime(), LOG_SIZE/sizeof(tLogStruct));
   1845                        for (; (indx < size) && (log[indx].type); indx++) {
   1846                          if ((indx & 0x07 == 0)) {
   1847                            CoTickDelay(20);
   1848                          }
   1849                          TRACE(":%u @%u t:%d d:%u\n\r", indx, log[indx].timestamp, log[indx].type, log[indx].frameId);
   1850                          CoTickDelay(2);
   1851                        }
   1852                      }
   1853                      break;
   1854                    case 57:
   1855                      {
   1856                        if (value ==1313) {
   1857                          __disable_interrupt();
   1858                          memset((void*) log, 0, LOG_SIZE);
   1859                          log_index_in = 0;
   1860                          __enable_interrupt();
   1861                          TRACE("Erased\n\r");
   1862                        } else {
   1863                          TRACE("ooopss.. wrong value\n\r");
   1864                        }
   1865                      }
   1866                      break;
   1867          #endif
   1868                    case 58:
   1869                      {
   1870                        config.flags |= FLAG_TRACE_LEDSHUNTSYNC;    
   1871                        break;                  
   1872                      }
   1873                      break;
   1874                    case 59:
   1875                      {
   1876                        config.flags &= ~FLAG_TRACE_LEDSHUNTSYNC;
   1877                        break;
   1878                      }
   1879                      break;
   1880                    case 60:
   1881                      {
   1882                        config.flags |= FLAG_TRACE_UI_STATEMACHINE;
   1883                        break;
   1884                      }
   1885                      break;
   1886                    case 61:
   1887                      {
   1888                        config.flags &= ~FLAG_TRACE_UI_STATEMACHINE;
   1889                        break;
   1890                      }
   1891                      break;
   1892                    case 62:
   1893                      {
   1894                        config.chgstate_radio_en = 1; 
   1895                        break;
   1896                      }
   1897                    case 63:
   1898                      {
   1899                        config.chgstate_radio_en = 0;
   1900                        break;
   1901                      }
   1902                    case 94:
   1903                      {
   1904                        if (value == 16385) {
   1905                          TRACE("Generating hard fault\r\n");
   1906                          CoTickDelay(100);
   1907                          uint32_t *p = (uint32_t*) 0xDE002319;
   1908                          uint32_t j = *p;
   1909                        }
   1910                      }
   1911                      break;
   1912                    case 95:
   1913                      {
   1914                        watchdog_active = value;
   1915                        TRACE("Watchdog is %s\r\n", value?"active":"not active");
   1916                      }
   1917                      break;
   1918                    case 96:
   1919                      {
   1920                        extern uint32_t stacked_lr, stacked_pc, stacked_psr;
   1921                        uint32_t saved_lr, saved_pc, saved_psr;
   1922                        uint32_t fault_counter;
   1923                        WaitGrabI2C();
   1924                        I2C_EE_BufferRead((uint8_t*) &saved_lr, EEPROM_DEBUG_STACKED_LR, EEPROM_DEBUG_STACKED_LR_SIZE);
   1925                        I2C_EE_BufferRead((uint8_t*) &saved_pc, EEPROM_DEBUG_STACKED_PC, EEPROM_DEBUG_STACKED_PC_SIZE);
   1926                        I2C_EE_BufferRead((uint8_t*) &saved_psr, EEPROM_DEBUG_STACKED_PSR, EEPROM_DEBUG_STACKED_PSR_SIZE);
   1927                        I2C_EE_BufferRead((uint8_t*) &fault_counter, EEPROM_DEBUG_COUNTER, EEPROM_DEBUG_COUNTER_SIZE);
   1928                        ReleaseI2C();
   1929                        TRACE("stacked_lr=0x%08X stacked_pc=0x%08X\r\n",
   1930                              stacked_lr, stacked_pc);
   1931                        TRACE("stacked_psr=0x%08X saved_lr=0x%08X\r\n",
   1932                              stacked_psr, saved_lr);
   1933                        TRACE("saved_pc=0x%08X saved_psr=0x%08X\r\n", saved_pc, saved_psr);
   1934                        TRACE("fault_counter = %u\r\n", fault_counter);
   1935                      }
   1936                      break;
   1937                    case 97:
   1938                      {
   1939                        stacked_lr = stacked_pc = stacked_psr = 0;
   1940                      }
   1941                      break;
   1942          #ifdef TASKS_PROFILE
   1943                    case 98:
   1944                      {
   1945                          __disable_interrupt();
   1946                          uint32_t stack1              = CoGetStackDepth(task1Id);
   1947                          uint32_t perfTask1           = CoGetTaskScheduledCount(task1Id);
   1948                          uint16_t lineTask1           = CoGetTaskLine(task1Id);
   1949                          const char *funcTask1        = CoGetTaskFunc(task1Id);
   1950                          uint32_t stackRadioRx        = CoGetStackDepth(taskRadioRxId);
   1951                          uint32_t perfRadioRx         = CoGetTaskScheduledCount(taskRadioRxId);
   1952                          uint16_t lineRadioRx         = CoGetTaskLine(taskRadioRxId);
   1953                          const char *funcRadioRx      = CoGetTaskFunc(taskRadioRxId);
   1954                          uint32_t stack3              = CoGetStackDepth(task3Id);
   1955                          uint32_t perfTask3           = CoGetTaskScheduledCount(task3Id);
   1956                          uint16_t lineTask3           = CoGetTaskLine(task3Id);
   1957                          const char *funcTask3        = CoGetTaskFunc(task3Id);
   1958          
   1959                          uint32_t stackConfig         = CoGetStackDepth(taskConfigId);
   1960                          uint32_t perfTaskConfig      = CoGetTaskScheduledCount(taskConfigId);
   1961                          uint16_t lineTaskConfig      = CoGetTaskLine(taskConfigId);
   1962                          const char *funcTaskConfig   = CoGetTaskFunc(taskConfigId);
   1963                          uint32_t stackRadioTx        = CoGetStackDepth(taskRadioTxId);
   1964                          uint32_t perfRadioTx         = CoGetTaskScheduledCount(taskRadioTxId);
   1965                          uint16_t lineRadioTx         = CoGetTaskLine(taskRadioTxId);
   1966                          const char *funcRadioTx      = CoGetTaskFunc(taskRadioTxId);
   1967          
   1968                          uint32_t stack8              = CoGetStackDepth(task8Id);
   1969                          uint32_t perfTask8           = CoGetTaskScheduledCount(task8Id);
   1970                          uint16_t lineTask8           = CoGetTaskLine(task8Id);
   1971                          const char *funcTask8        = CoGetTaskFunc(task8Id);
   1972                          uint32_t stackIMU            = CoGetStackDepth(taskIMUGId);
   1973                          uint32_t perfTaskIMU         = CoGetTaskScheduledCount(taskIMUGId);
   1974                          uint16_t lineTaskIMU         = CoGetTaskLine(taskIMUGId);
   1975                          const char *funcTaskIMU      = CoGetTaskFunc(taskIMUGId);
   1976          
   1977                          __enable_interrupt();
   1978          
   1979          
   1980                          TRACE("Task1 [avail stack:%d]:%d @ %s():%d\n\r", stack1, perfTask1, funcTask1, lineTask1);
   1981                          TRACE("RadioRxTask [avail stack:%d]:%d @ %s():%d\n\r", stackRadioRx, perfRadioRx, funcRadioRx, lineRadioRx);
   1982                          TRACE("Task3 [avail stack:%d]:%d @ %s():%d\n\r", stack3, perfTask3, funcTask3, lineTask3);
   1983                          TRACE("TaskConfig [avail stack:%d]:%d @ %s():%d\n\r", stackConfig, perfTaskConfig, funcTaskConfig, lineTaskConfig);
   1984                          TRACE("RadioTxTask [avail stack:%d]:%d @ %s():%d\n\r", stackRadioTx, perfRadioTx, funcRadioTx, lineRadioTx);
   1985                          TRACE("Task8 [avail stack:%d]:%d @ %s():%d\n\r", stack8, perfTask8, funcTask8, lineTask8);
   1986                          TRACE("TaskIMU [avail stack:%d]:%d @ %s():%d\n\r", stackIMU, perfTaskIMU, funcTaskIMU, lineTaskIMU);
   1987          
   1988                    }
   1989                    break;
   1990                    case 99:
   1991                      {
   1992                      uint32_t scheduled_idle = CoGetTaskScheduledCount(0);
   1993                      uint32_t scheduled_task1 = CoGetTaskScheduledCount(task1Id);
   1994                      uint32_t scheduled_taskRadioRx = CoGetTaskScheduledCount(taskRadioRxId);
   1995                      uint32_t scheduled_task3 = CoGetTaskScheduledCount(task3Id);
   1996                      uint32_t scheduled_taskConfig = CoGetTaskScheduledCount(taskConfigId);
   1997                      uint32_t scheduled_taskRadioTx = CoGetTaskScheduledCount(taskRadioTxId);
   1998                      uint32_t scheduled_task8 = CoGetTaskScheduledCount(task8Id);
   1999                      uint32_t scheduled_taskIMU_G = CoGetTaskScheduledCount(taskIMUGId);
   2000                      TRACE("PERF: IdleTask: %u Task1: %u RxTask: %u Task3: %u\n\r",
   2001                            scheduled_idle, scheduled_task1, scheduled_taskRadioRx, scheduled_task3);
   2002                      TRACE("PERF: TaskConfig: %u TxTask: %u\n\r",
   2003                            scheduled_taskConfig, scheduled_taskRadioTx);
   2004                      TRACE("PERF: Task8: %u TaskIMU: %u\n\r", scheduled_task8, scheduled_taskIMU_G);
   2005                    }
   2006                    break;
   2007          #endif
   2008                    }
   2009                  }
   2010                  break;
   2011                case 'U':
   2012                  {       // Extended command line that use base64 encoded parameters
   2013                    static uint8_t encoded[512];
   2014                    static uint8_t decoded[512];
   2015                    //uint8_t *_decoded = &decoded[0];
   2016                    uint16_t update_flags = 0;
   2017                    char *p = NULL;
   2018                    while (*s && isspace(*(++s)));
   2019                    if (!*s) {
   2020                      break;
   2021                    }
   2022          
   2023                    addr = strtoul(s, &p, 10);
   2024                    s = p;
   2025                    while (*s && isspace(*(++s)));
   2026                      if (!*s) {
   2027                        break;
   2028                      }
   2029                    uint16_t value = strtoul(s, &p, 10);
   2030                      s = p;
   2031                      while (*s && isspace(*(++s)));
   2032                      if (!*s) {
   2033                        break;
   2034                      }
   2035                    strcpy((char*) encoded, s);
   2036                    int ret = b64_pton(encoded, decoded, sizeof(decoded));
   2037          
   2038                    if (ret < sizeof(struct PacketHeader)) {
   2039                      TRACE("Incorrect packet\r\n");
   2040                      continue;
   2041                    }
   2042                    struct PacketHeader *packetHeader = (struct PacketHeader *)decoded;
   2043                    if (packetHeader->size > ret) {
   2044                      TRACE("Incorrect packet size\r\n");
   2045                      continue;
   2046                    }
   2047                    if (ValidateCommandLine((char*)decoded, ret) == 0) {
   2048                      TRACE("Incorrect packet\r\n");
   2049                      continue;
   2050                    }                
   2051          
   2052                    if (packetHeader->type == DEV_CMD_BAT_STATUS) {
   2053                      __writeCmdLineRespPacket((void*) &lastBatStatus, sizeof(lastBatStatus), DEV_RESP_BAT_STATUS);
   2054                    } else if (packetHeader->type == DEV_CMD_CONFIG_REQ) {
   2055                      ex_config_t my_config;
   2056                      CopyConfigToExConfig(&config, &my_config);
   2057                      my_config.checksum = CalcConfigChecksum(&my_config.productID, my_config.size);
   2058                      __writeCmdLineRespPacket((void *)&my_config,  sizeof(my_config), DEV_RESP_CONFIG);
   2059                    } else if(packetHeader->type == DEV_CMD_GET_VERSION) {
   2060                      struct RespFirmwareVersion respFirm;
   2061                      respFirm.major = THIS_MAJOR;
   2062                      respFirm.minor = THIS_MINOR;
   2063                      respFirm.patch = THIS_PATCH;
   2064                      respFirm.reserved = 0;                       // For compatible reason
   2065                      respFirm.revision = THIS_REVISION;
   2066                      strcpy((char*) respFirm.dateString, __DATE__);
   2067                      strcpy((char*) respFirm.timeString, __TIME__);
   2068                      __writeCmdLineRespPacket((void *)&respFirm,  sizeof(respFirm), DEV_RESP_VERSION);
   2069                    }else if (packetHeader->type == DEV_CMD_RUNNING_STATUS_REQ) {
   2070                      struct BeaconRunningStatus bat;
   2071                      bat.errorCode = 0;
   2072                      bat.index = BattUnion.BatteryLevel[1];
   2073                      bat.radioOnOff = (radio_off == 0);
   2074                      __writeCmdLineRespPacket((void *)&bat,  sizeof(bat), DEV_RESP_RUNNING_STATUS);
   2075                    } else if (packetHeader->type == DEV_CMD_SET_CONFIG) {
   2076                      ex_config_t* newConfig;
   2077                      newConfig = (ex_config_t*)(decoded + sizeof(struct PacketHeader));
   2078                      if (newConfig->panId != config.panId ||
   2079                        newConfig->mySrcAddr != config.mySrcAddr) {
   2080                        update_flags |= UPDATE_FLAG_PANID;
   2081                      }
   2082                      if (newConfig->routerDstAddr != config.routerDstAddr) {
   2083                        update_flags |= UPDATE_FLAG_DSTADDR;
   2084                      }
   2085                      if (newConfig->ledDAC != config.ledDAC) {
   2086                        update_flags |= UPDATE_FLAG_DAC;
   2087                      }
   2088                      if (newConfig->rfChan != config.rfChan) {
   2089                        update_flags |= UPDATE_FLAG_RFCHAN;
   2090                      }
   2091                      if (newConfig->TxLevel != config.TxLevel) {
   2092                        update_flags |= UPDATE_FLAG_TXLEVEL;
   2093                      }
   2094                      CopyExConfigToConfig(newConfig, &config);
   2095                      // memcpy((void *)&config, (void *)newConfig, sizeof(beacon_config_t));
   2096                      WaitGrabI2C();
   2097                      SaveConfig(&config);
   2098                      ReleaseI2C();
   2099                      if (update_flags & UPDATE_FLAG_PANID) {
   2100                        RadioSetPanIdShortAddr(config.panId, config.mySrcAddr);
   2101                        CoSetFlag(flagUSBdata_UI);
   2102                      }
   2103                      if (update_flags & UPDATE_FLAG_DSTADDR) {
   2104                        routerAddr = config.routerDstAddr;
   2105                      }
   2106                      if (update_flags & UPDATE_FLAG_RFCHAN) {
   2107                        RadioSetRFChan(rfChan);
   2108                      }
   2109                      if (update_flags & UPDATE_FLAG_TXLEVEL) {
   2110                        RadioSetRFLevel(config.TxLevel);
   2111                      }
   2112                    } else if (packetHeader->type == DEV_CMD_SET_EEPROM_DATA) {
   2113                      struct RespUpdate up;
   2114                      up.index = 0;
   2115                      if (packetHeader->size < sizeof(struct PacketHeader) + 32) { // if data body greater than 32, only 32 bytes are written 
   2116                        up.errorCode = ERROR_WRONG_PACKET;
   2117                      } else {
   2118                        WaitGrabI2C();
   2119                        uint8_t *data = (uint8_t *) decoded + sizeof(struct PacketHeader);
   2120                        I2C_EE_BufferWrite(data, 128, 32);
   2121                        up.errorCode = 0;
   2122                        ReleaseI2C();
   2123                        CoSetFlag(flagUSBdata_UI);
   2124                      }
   2125                      uint8_t type = DEV_RESP_SET_EEPROM_DATA;
   2126                      __writeCmdLineRespPacket((unsigned char*) &up, 4, type);
   2127                    } else if (packetHeader->type == DEV_CMD_GET_EEPROM_DATA) {
   2128                      struct RespEepromData resp;
   2129                      WaitGrabI2C();
   2130                      I2C_EE_BufferRead(&resp.data[0], 128, 32);
   2131                      ReleaseI2C();
   2132                      resp.errorCode = 0;
   2133                      __writeCmdLineRespPacket((unsigned char*) &resp, sizeof(resp), DEV_RESP_GET_EEPROM_DATA);
   2134                    } else if (packetHeader->type == DEV_CMD_SET_PROD_AREA) {
   2135                      struct RespUpdate up;
   2136                      uint8_t type = DEV_RESP_SET_PROD_AREA;
   2137                      ret = SerialDownload((char*) decoded, ret, packetHeader->type);
   2138                      up.index = (ret & 0xFFFF0000) >> 16;
   2139                      up.errorCode = ret & 0xFFFF;
   2140                      __writeCmdLineRespPacket((unsigned char*) &up, 4, type);
   2141                    } else if (packetHeader->type == DEV_CMD_GET_PROD_AREA) {
   2142                      struct GetProdAreaPacketHeader *prodHeader = (struct GetProdAreaPacketHeader*) decoded;
   2143                      struct RespProdArea resp;
   2144                      page.address = FLASH_PROD_AREA;
   2145                      page.count = 2048;
   2146                      ret = ReadPage(&page);
   2147                      resp.errorCode = ret;
   2148                      resp.index = prodHeader->index;
   2149                      if (!ret) {
   2150                        memcpy(resp.data, &page.data[prodHeader->index*sizeof(resp.data)], sizeof(resp.data));
   2151                      }
   2152                      __writeCmdLineRespPacket((unsigned char*) &resp, sizeof(resp), DEV_RESP_GET_PROD_AREA);
   2153                    }
   2154                  }
   2155                  break;
   2156                case '!':
   2157                  {
   2158                    uint8_t jumpToMain = 0xFF;
   2159                    WaitGrabI2C();
   2160                    I2C_EE_BufferRead((uint8_t*) &jumpToMain, EEPROM_BEACON_FLAG_ADDRESS, 1);
   2161                    if (jumpToMain != 0xFF) {
   2162                      jumpToMain = 0xFF;
   2163                      I2C_EE_BufferWrite((uint8_t*) &jumpToMain, EEPROM_BEACON_FLAG_ADDRESS, 1);
   2164                    }
   2165                    ReleaseI2C();
   2166                    NVIC_GenerateSystemReset();
   2167                  }
   2168                  break;
   2169          #if (defined USE_MY_ASSERT) || (defined USE_FULL_ASSERT)
   2170                case 'a':
   2171                  {
   2172                      assert_loop = 0;
   2173                  }
   2174                  break;
   2175          #endif
   2176                default:
   2177                  TRACE("**ERROR** Unrecognized Command '%c'\n\r", cmd);
   2178                  break;
   2179              }
   2180          
   2181              if (cmd != 'U') {
   2182                  TRACE("> ");
   2183              }
   2184            }
   2185          }
   2186          
   2187          uint32_t mycalls;
   2188          uint32_t radioTxEntries;
   2189          StatusType lastRadioTx;
   2190          StatusType setTxDone;
   2191          
   2192          /*******************************************************************************
   2193          * Description    : [Task] Manage Outgoing (TX) Packet Queue
   2194          * Input          :
   2195          * Return         :
   2196          *******************************************************************************/
   2197          void TaskRadioTx(void* pdata){
   2198              SAVE_LINE
   2199              while (1) {
   2200                  // avoid busy waiting. sleep a tick or until wake up by other task
   2201                  SAVE_FUNC
   2202                  radioTxEntries++;
   2203                  lastRadioTx = CoWaitForSingleFlag(flagRadioTxReq, 1);
   2204                  SAVE_POINT
   2205                  while (1) {
   2206                      SAVE_FUNC
   2207                      RELOAD_WATCHDOG
   2208                      __disable_interrupt();
   2209          #ifndef NO_TK
   2210                      if (remainOutOfSyncTime <= 0) {         // out of synchronization. Need to stop sending so that T.K. can occupy timeslot to sync again
   2211                      //    CoSuspendTask(task1Id);
   2212                      //    CoSuspendTask(taskRadioTxId);
   2213          
   2214                        __enable_interrupt();
   2215                        SAVE_LINE
   2216                          break;
   2217                      }
   2218          #endif
   2219                      if (inIdx == outIdx) { // queue is NOT empty.       // TODO!!! Double check if producer can be run and modifies inIdx. If so it is a critical section.
   2220                          queue_full = 1;
   2221                          SAVE_LINE
   2222                          __enable_interrupt();
   2223                          break;
   2224                      } else {
   2225                        
   2226                        queue_full = 0;
   2227                      }
   2228                      __enable_interrupt();
   2229          
   2230                      SAVE_POINT
   2231                      RadioIMU_WaitGrabSPI();
   2232                      SAVE_POINT
   2233                      startRadioTx.sec = sec;
   2234                      startRadioTx.uSec = TIM1->CNT;
   2235                      // outIdx is modified by Tx task only. So no lock required
   2236                      RadioTxPkt(txPktQueue[outIdx].dstAddr,
   2237                                 0,   // not a beacon frame
   2238                                 txPktQueue[outIdx].payloadSize,
   2239                                 txPktQueue[outIdx].payload,
   2240                                 1);  // transmit immediately
   2241                      SAVE_POINT
   2242                      mycalls++;
   2243                      endRadioTx.sec = sec;
   2244                      endRadioTx.uSec = TIM1->CNT;
   2245          #ifndef CCA_EN
   2246                      RadioIMU_ReleaseSPI();      // TODO!!! verify if SPIIODone is correctly waiting
   2247          #endif
   2248          
   2249                      // ring buffer operation is in critical section
   2250                      __disable_interrupt();
   2251                      outIdx = (outIdx + 1) % TX_PKT_QUEUE_SIZE;
   2252                      outidxcheck++;
   2253                      __enable_interrupt();
   2254          
   2255                      numTxRetries = 0; // reset counter as we initiate tx
   2256                      txRetryState = 1; // indicate STXONCCA has been issued. TODO!!! verify the meaning
   2257          
   2258                      /* fire up TIM5 to ring check CCA after 1ms */
   2259          #ifdef CCA_EN
   2260                      uint8_t txRetryState = 1;
   2261                      uint8_t numTxRetries = NUM_TX_RETRIES;
   2262          
   2263                      do {
   2264                        TIM5->EGR |= TIM_EGR_UG;
   2265                        TIM5->CR1 |= TIM_CR1_CEN;
   2266                        CoWaitForSingleFlag(flagRadioCCA, 1, 0);
   2267                        SAVE_POINT
   2268          
   2269                        assert(txRetryState != 0); // [[DEBUG]]
   2270          
   2271                        if (txRetryState == 1) {            // read FMSTAT1
   2272                          /* check if CCA was asserted */
   2273                          if (!spiTxRxByteCount) {        // SPI not in use
   2274                            /* read FSMSTAT1 register */
   2275                            scratchBuf[0] = (CC2520_INS_REGRD | CC2520_FSMSTAT1);
   2276                            scratchBuf[1] = 0;          // pad byte to push out reg val
   2277                            spiTxRxByteCount = 0x02;  // indicate FMSTAT1 read
   2278                            spiTxRxByteState = RF_SPI_CCA_CMD_STATE;
   2279                            pSpiTxBuf = scratchBuf;
   2280                            pSpiRxBuf = scratchBuf;     // self-clobbering ... that's ok
   2281                            HwSPISSAssert(SPI_RADIO);
   2282                            SPI_I2S_ITConfig(SPI_RADIO_SPI, SPI_I2S_IT_RXNE, ENABLE);
   2283                            SPI_I2S_SendData(SPI_RADIO_SPI, *pSpiTxBuf++);
   2284                            txRetryState++;             // go to next state
   2285                          } else {
   2286                            break;
   2287                          }
   2288                      } else if (txRetryState == 2) {     // check SAMPLED_CCA bit, retry TX if necessary
   2289                        if (sampledCCA & CC2520_FSMSTAT1_SAMPLED_CCA_BM) {
   2290                          /* CCA asserted, packet is going (has gone) out */
   2291                          txRetryState = 0;
   2292                          break;
   2293                        }
   2294          
   2295                        /* CCA NOT asserted, packet isn't going out ... try STXONCCA again now */
   2296          
   2297                        if (numTxRetries < NUM_TX_RETRIES) {
   2298                          if (!spiTxRxByteCount) {        // SPI not in use
   2299                              spiTxRxByteCount = 0x01;  // indicate STXONCCA retry
   2300                              spiTxRxByteState = RF_SPI_STXONCCA_CMD_STATE;
   2301                              pSpiRxBuf = scratchBuf;     // don't care
   2302                              HwSPISSAssert(SPI_RADIO);
   2303                              SPI_I2S_ITConfig(SPI_RADIO_SPI, SPI_I2S_IT_RXNE, ENABLE);
   2304                              SPI_I2S_SendData(SPI_RADIO_SPI, CC2520_INS_STXONCCA);
   2305                              numTxRetries++;
   2306                              txRetryState = 1;
   2307                          }                               // else, remain in this state, retry later
   2308                      } else { // done retrying, no more
   2309                          txRetryState = 0;
   2310                          // fake TX_FRM_DONE
   2311                          setTxDone = CoSetFlag(flagRadioTxDone);
   2312                          break;
   2313                      }
   2314                      SAVE_POINT
   2315                  } else assert(0);
   2316          
   2317          
   2318                      } while (1);
   2319                      RadioIMU_ReleaseSPI();
   2320          #endif
   2321                  }
   2322              }
   2323          }
   2324          
   2325          float fVolt = 0.0f;
   2326          
   2327          /*******************************************************************************
   2328          * Description    : [Task]A to D conversion for battery voltage
   2329          * Input          :
   2330          * Return         :
   2331          * Calculation: resistive divider
   2332          *  4.99k + 4.3k
   2333          *  After divider have: 4.3/(4.3+4.99) = 0.462365 of original Vbat value
   2334          *  With 4.2V nominal value will have 4.2V*0.462365=1.941935V at ADC
   2335          *  With ADC Vref= V+ = 2.2V will have 1.941935V/2.2V = 0.8826979 of full scale
   2336          *  With full scale of 65536 will have 0.8826979*65536=57848
   2337          *  In hexadecimal 4.2V at battery will be reported as 0xE17F
   2338          *  Other values calculated using linear scale
   2339          *
   2340          * There is no chip to calculate battery level, so following is data measured
   2341          * with radio ON and no LED
   2342          * DISCHARGE - starting at 4.2V:
   2343          * after 1hr=4.12V 2hr = 4.07V 3hr = 4.03V 4hr = 3.99V, up to 9hr rate is 0.03V per hour
   2344          * after 9hr rate up to 16 hr rate 0.02V, then 0.03V 2 hours up to 3.65V, then
   2345          * during 1hr goes to 3.5V and turns off
   2346          * CHARGE - 15 minutes to get to 3.92V, then steady rate 0.06V/hour
   2347          * after reaching 4.21V 45 minutes to full charge
   2348          *Data for V#3 hardware.. 4.2v= E1, 4.0v=D7, 3.9v=D0, 3.8v=CA, 3.7v=C6, 3.6v=C1
   2349          *                         3.5v=BB, 3.4v=B6, 3.3v=B0,3.2v=AB, 3.1v= A5, 3.0v= A0
   2350          *                         2.9v= 9A, 2.8v= 96, 2.7v= 90, 2.6v= 8B
   2351          *******************************************************************************/
   2352          #define DEVICE_CHARGING 0x02  //change this after boardspin -> this only indicates usb connection, not 'charging'
   2353          float fLast[10];
   2354          
   2355          void Task8(void* pdata){
   2356            while (1) {
   2357                SAVE_POINT
   2358              RELOAD_WATCHDOG
   2359                  // enable a to d battery input
   2360              HwGPOHigh(GPO_VBATT_ADC_EN);
   2361                  // wait 1 for input to stabilise
   2362              CoTickDelay(1);
   2363              SAVE_POINT
   2364                  // trigger a to d
   2365              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   2366                  // wait 1 for data sample
   2367              CoTickDelay(2);
   2368              SAVE_POINT
   2369                  // get sample data, disable input
   2370              BattUnion.Battery_AtoD = (ADC_GetConversionValue(ADC1));
   2371              HwGPOHigh(GPO_VBATT_ADC_EN);
   2372                  // wait 100
   2373              CoTickDelay(100);
   2374              SAVE_POINT
   2375              //CoTickDelay(1000);
   2376              
   2377              static uint32_t iter = 0;
   2378              float fCurr = 4.2f * (float)BattUnion.Battery_AtoD;
   2379              fCurr /= (float) 0xE1F8;
   2380              fLast[iter%10] = fCurr;
   2381              iter++;
   2382              uint8_t cnt = (iter>10)?10:iter;
   2383              fVolt = 0.0;
   2384              for (uint8_t k = 0; k < cnt; k++) {
   2385                fVolt += fLast[k];
   2386              }
   2387              fVolt /= (float) cnt;
   2388             /* if (iter == 10)*/ {
   2389                SAVE_LINE
   2390            //    iter = 0;
   2391                lastBatStatus.type = 0xBA;
   2392                lastBatStatus.version = 0x01;
   2393                lastBatStatus.flags = HwGPIState(GPI_CHG_STAT)?0x00:0x01;
   2394                if (HwGPIState(GPI_USB_VBUS)) {
   2395                  lastBatStatus.flags |= 0x02;
   2396           //       if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)) {
   2397                  rt_flags |= RT_FLAG_USB_CONNECTED;
   2398           //     }
   2399                } else {
   2400                  rt_flags &= ~RT_FLAG_USB_CONNECTED;
   2401                }
   2402                lastBatStatus.minToRun = 0xFFFF;
   2403                //fVolt /= (float) 10.0;
   2404                float percents = 0;
   2405                if (lastBatStatus.flags == 0x03) { //charging
   2406                  if (fVolt > 4.20) {
   2407                    percents = 95.0;
   2408                  } else if (fVolt > 3.92) {
   2409                    percents = 4.0 + 91.0*(fVolt - 3.92)/0.28;
   2410                  } else {
   2411                    percents = 4.0;
   2412                  }
   2413                } else {
   2414                  if (fVolt > 4.1 && (lastBatStatus.flags & 0x01) == 0) {
   2415                    percents = 100.0;
   2416                  } else if (fVolt > 4.07) {
   2417                    percents = 90.0 + 10.0 *(fVolt - 4.07)/0.14;
   2418                    if (percents >= 100.0) {
   2419                      percents = 99.0;
   2420                    }
   2421                  } else if (fVolt > 4.03) {
   2422                    percents = 85.0 + 5.0*(fVolt - 4.03)/0.04;
   2423                  } else if (fVolt > 3.84) {
   2424                    percents = 55.0 + 30.0*(fVolt - 3.84)/0.19;
   2425                  } else if (fVolt > 3.71) {
   2426                    percents = 20.0 + 35.0*(fVolt -3.71)/0.13;
   2427                  } else if (fVolt > 3.65) {
   2428                    percents = 10.0 + (fVolt - 3.65)/0.006;
   2429                  } else {
   2430                    percents = (fVolt - 3.5)/10.0;
   2431                    if (percents < 0) {
   2432                      percents = 0.0;
   2433                    }
   2434                  }
   2435                }
   2436                lastBatStatus.voltiCents = (uint16_t) ((fVolt + 0.005)*100.0);
   2437                last_percents = lastBatStatus.percents = (uint8_t) percents;
   2438              }
   2439            }
   2440          }
   2441          
   2442          StatusType setIMUReady;
   2443          uint32_t counterIMU;
   2444          
   2445          extern uint16_t over1;
   2446          /*******************************************************************************
   2447          * Description    : [Task]9 Used for reading the IMU reg data and packing
   2448          * Input          :
   2449          * Return         :
   2450          *
   2451          *******************************************************************************/
   2452          void TaskIMU_G(void* pdata){
   2453            while(1)
   2454            {
   2455              SAVE_POINT
   2456              if (adjusted_changed) {
   2457                adjusted_changed = 0;
   2458                if (config.flags & FLAG_TRACE_ADJUST) {
   2459                  TRACE("adjusted=%u over=%d @%d.%d\r\n", adjusted, over1, sec, tim_at_sec);
   2460                }
   2461              }
   2462              RELOAD_WATCHDOG
   2463              CoWaitForSingleFlag(flagIMU_G_DRDY, 0);
   2464              counterIMU++;
   2465              SAVE_POINT
   2466              CoClearFlag(flagIMUNewData);        // DO NOT USE auto reset Flag as the DMA interrupt may take place before CoWaitForSingleFlag(flagIMUNewData, 0);  
   2467              RadioIMU_WaitGrabSPI();
   2468              imuaccess++;
   2469              IMUProcess();
   2470              RadioIMU_ReleaseSPI();
   2471              SAVE_POINT
   2472              InputDataIntoBuffer(&IMU_RawData[0]);
   2473              setIMUReady = CoSetFlag(flagIMUDataReady);
   2474              SAVE_POINT;
   2475            }
   2476          }
   2477          
   2478          
   2479          
   2480          /*******************************************************************************
   2481          * Description    : [Task] Used to determine the status of the infrared LEDs
   2482          * Input          :
   2483          * Return         :
   2484          *
   2485          *******************************************************************************/
   2486          void TaskLED(void* pdata){
   2487            static StatusType result;
   2488            static uint8_t i = 0;
   2489            static ledcheck checkled = select_IRLED0;
   2490            static float led_value;
   2491            static float value;
   2492            static uint8_t led_errorcheck = 0;
   2493            IRled_flags = (IRled_status) {.IRled0_DC=0, .IRled1_DC=0, .IRled2_DC=0};
   2494            while(1){
   2495              SAVE_POINT
   2496              RELOAD_WATCHDOG
   2497              CoTickDelay(1);
   2498              CoClearFlag(flagLEDSync);
   2499              led_select = checkled;
   2500              CoWaitForSingleFlag(flagLEDSync,0);
   2501              led_select = select_none;
   2502              SAVE_POINT
   2503              CoTickDelay(1);
   2504              WaitGrabI2C();
   2505              SAVE_POINT
   2506              switch(checkled){
   2507                  case select_IRLED0:
   2508                    if(!HwGPOstatus(GPO_IRLED0)){ //confirm led was not turned off in cc3
   2509                      if(config.flags & FLAG_TRACE_LEDSHUNTSYNC) TRACE("I2C irled%i not on\n\r", checkled);
   2510                      led_errorcheck=0;
   2511                    }
   2512                    else
   2513                      led_value = ledbuffer_set(shunt1_address, &led_errorcheck);
   2514                  break;
   2515                  case select_IRLED1:
   2516                    if(!HwGPOstatus(GPO_IRLED1)){ //confirm led was not turned off in cc3
   2517                      if(config.flags & FLAG_TRACE_LEDSHUNTSYNC) TRACE("I2C irled%i not on\n\r", checkled);
   2518                      led_errorcheck=0;
   2519                    }
   2520                    else
   2521                      led_value = ledbuffer_set(shunt2_address, &led_errorcheck);
   2522                  break;
   2523                  case select_IRLED2: 
   2524                    if(!HwGPOstatus(GPO_IRLED2)){ //confirm led was not turned off in cc3
   2525                      if(config.flags & FLAG_TRACE_LEDSHUNTSYNC) TRACE("I2C irled%i not on\n\r", checkled);
   2526                      led_errorcheck=0;
   2527                    }
   2528                    else
   2529                      led_value = ledbuffer_set(shunt3_address, &led_errorcheck);
   2530                  break;      
   2531              }
   2532              SAVE_POINT
   2533              ReleaseI2C();
   2534               SAVE_POINT
   2535              if(led_errorcheck){ //done outside of mutex to avoid unnecessary time within critical region for other potential threads
   2536                SAVE_POINT
   2537                value = (float) led_value / ina219_currentDivider_mA;
   2538                switch(checkled){
   2539                  case select_IRLED0:
   2540                  IRled_flags.IRled0_DC |= (value > 10.0)? 1:0;
   2541                  break;
   2542                  case select_IRLED1: 
   2543                  IRled_flags.IRled1_DC |= (value > 10.0)? 1:0;
   2544                  break;
   2545                  case select_IRLED2: 
   2546                  IRled_flags.IRled2_DC |= (value > 10.0)? 1:0;
   2547                  break;
   2548                }
   2549                checkled = (checkled+1 <= select_IRLED2)? checkled+1:select_IRLED0;
   2550                if(checkled == select_IRLED0){
   2551                  if(++i>=IRLED_SAMPLES){
   2552                    i=0;
   2553          
   2554                    if( IRled_flags.IRled0_DC != (UI_IRLEDdata & UI_IRLED0FLAG)>>0 ||
   2555                        IRled_flags.IRled1_DC != (UI_IRLEDdata & UI_IRLED1FLAG)>>1 ||
   2556                        IRled_flags.IRled2_DC != (UI_IRLEDdata & UI_IRLED2FLAG)>>2
   2557                      ){
   2558                        CoPendSem(semInkUI,0);
   2559                        UI_IRLEDdata = (IRled_flags.IRled0_DC<<0) |(IRled_flags.IRled1_DC<<1) | (IRled_flags.IRled2_DC<<2);
   2560                        CoSetFlag(flagLED_UI);
   2561                        CoPostSem(semInkUI);
   2562                      }
   2563                    if(config.flags & FLAG_TRACE_LEDSHUNTSYNC){
   2564                      TRACE("IRled0 = %i, IRled1 = %i, IRled2 = %i\r\n", IRled_flags.IRled0_DC, IRled_flags.IRled1_DC, IRled_flags.IRled2_DC);
   2565                    }
   2566                    IRled_flags.IRled0_DC = IRled_flags.IRled1_DC = IRled_flags.IRled2_DC = 0;
   2567                    CoTickDelay(1000);          
   2568                  }
   2569                }
   2570              }
   2571              else{
   2572                SAVE_POINT
   2573                if(config.flags & FLAG_TRACE_LEDSHUNTSYNC) TRACE("retry I2C irled%i\n\r", checkled);
   2574              }
   2575            }
   2576          }
   2577          
   2578          /*******************************************************************************
   2579          * Description    : [Task] Used to control the user interface statemachine
   2580          * Input          :
   2581          * Return         :
   2582          *
   2583          *******************************************************************************/
   2584          void TaskUI(void *pdata){
   2585            static uint16_t var = 0;     //used for a) check hold count until task3 takes on this functionality and b) checks if EPD requires update
   2586            static uint64_t timesequence;
   2587            static uint64_t currentTime;
   2588            static uint32_t getFlags;
   2589            static StatusType result;
   2590            static uint8_t led_flags=0;
   2591            static uint8_t refresh=0;
   2592            static UI_SubStates MenuSubState = UI_MENU_HOME_SUBSTATE;
   2593            static uint8_t addressfield[8];
   2594          
   2595            WaitGrabEInk();
   2596            EInk_Present = (Eink_Init())? 1:0;
   2597            if(EInk_Present == 0){ 
   2598              CoSchedLock();                      //shut down sequence
   2599              HwGPOLow(GPO_RF_EN);
   2600              HwGPOLow(GPO_VBATT_ADC_EN);
   2601              HwGPOInitOC(GPO_USB_VBUS); 
   2602              HwGPOLow(GPO_USB_VBUS);  
   2603              SAVE_POINT
   2604              HwGPOLow(GPO_PWRON); 
   2605              while (1);
   2606            }
   2607            GFX_FillBuffer(black);
   2608            GFX_DrawBitMap(UI_LOGO_COORD, logo, logo_dimensions);
   2609            setFont(smallfont);
   2610            setCursor(UIPOWER_TEXT_COORD);
   2611            GFX_Print("loading...", strlen("loading..."),centeralign, black, gray_l);
   2612            update(fullrefresh);
   2613            ReleaseEInk();
   2614          
   2615            WaitGrabI2C();
   2616            I2C_EE_BufferRead(&beaconName[0], 128, 12);
   2617            ReleaseI2C();
   2618            sprintf(addressfield, "ID%i", config.mySrcAddr);
   2619            CoTickDelay(1000);                    //allow time for loading screen to be lit
   2620            
   2621            WaitGrabEInk();
   2622            UI_StateMachine=UI_HOME_STATE;
   2623            setHomeScreen(beaconName,addressfield);
   2624            setStringerGraphics(led_flags);
   2625            update(fullrefresh);
   2626            ReleaseEInk();
   2627          
   2628            CoPostSem(semInkUI);                  //allow UI functionality from other threads when released.
   2629            CoAwakeTask(taskLEDId);
   2630            
   2631            while(1){
   2632              RELOAD_WATCHDOG
   2633              SAVE_POINT
   2634              //Wait for event that affects UI -> button presses (A,B,X), LED Stringers
   2635              getFlags = CoWaitForMultipleFlags(1<<flagBtn_UI | 
   2636                                                1<< flagLED_UI | 
   2637                                                1<< flagTimeout_UI |
   2638                                                1<< flagUSBdata_UI,
   2639                                                OPT_WAIT_ANY, 0, &result);   
   2640              SAVE_POINT
   2641              if(result == E_OK){  
   2642                if(getFlags == 1<<flagBtn_UI){
   2643                  CoClearFlag(flagBtn_UI);
   2644                  CoPendSem(semInkUI,0);
   2645                  switch(UI_StateMachine){
   2646                    case UI_HOME_STATE:
   2647                      if(UI_BUTTONdata&UI_PWRBTNFLAG){
   2648                        UI_StateMachine = UI_MENU_STATE;
   2649                        CoPostSem(semInkUI);
   2650                        MenuSubState = UI_MENU_HOME_SUBSTATE; 
   2651                        if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("X btn: Home -> Menu\r\n");
   2652                        GFX_FillBuffer(black);
   2653          						  setFont(smallfont);
   2654          						  setCursor(UIHOME_DURATION_COORD);
   2655                        GFX_Print("8.00H", strlen("8.00H"),leftalign, black, gray_l);
   2656          						  GFX_DrawBitMap(UI_BATTERY_TEXT_COORD, battery100, battery_text_dimensions);
   2657          						  GFX_DrawBitMap(UIMENU_HOME_COORD,button_homeenable, button_dimensions);
   2658          						  GFX_DrawBitMap(UIMENU_STATUS_COORD,button_statusdisable, button_dimensions);
   2659          						  GFX_DrawBitMap(UIMENU_POWER_COORD,button_powerdisable, button_dimensions);
   2660                        resetUITimeout();
   2661                        WaitGrabEInk();
   2662                        update(fullrefresh);
   2663                        ReleaseEInk();
   2664                      }else CoPostSem(semInkUI);  //sanity check
   2665                    break;
   2666                    case UI_MENU_STATE:
   2667                      if(UI_BUTTONdata&UI_BTNBFLAG){
   2668                        CoPostSem(semInkUI);
   2669                        resetUITimeout();
   2670                        switch(MenuSubState){
   2671                          case UI_MENU_HOME_SUBSTATE:
   2672                            MenuSubState = UI_MENU_STATUS_SUBSTATE;
   2673                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("A btn: in menu status substate\r\n");
   2674          						      GFX_DrawBitMap(UIMENU_HOME_COORD,button_homedisable, button_dimensions);
   2675          						      GFX_DrawBitMap(UIMENU_STATUS_COORD,button_statusenable, button_dimensions);
   2676                            WaitGrabEInk();
   2677                            update(partialrefresh);
   2678                            ReleaseEInk();
   2679                          break;
   2680                          case UI_MENU_STATUS_SUBSTATE:
   2681                            MenuSubState = UI_MENU_POWER_SUBSTATE;
   2682                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("A btn: in menu ID substate\r\n");
   2683          						      GFX_DrawBitMap(UIMENU_STATUS_COORD,button_statusdisable, button_dimensions);
   2684          						      GFX_DrawBitMap(UIMENU_POWER_COORD,button_powerenable, button_dimensions);
   2685                            WaitGrabEInk();
   2686                            update(partialrefresh);
   2687                            ReleaseEInk();
   2688                          break;
   2689          #if 0
   2690                          case UI_MENU_ID_SUBSTATE:
   2691                            MenuSubState = UI_MENU_POWER_SUBSTATE;
   2692                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("A btn: in menu power substate\r\n");
   2693                          break;
   2694          #endif
   2695                          case UI_MENU_POWER_SUBSTATE:
   2696                            MenuSubState = UI_MENU_HOME_SUBSTATE;
   2697                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("A btn: in menu home substate\r\n");
   2698                            GFX_DrawBitMap(UIMENU_HOME_COORD,button_homeenable, button_dimensions);
   2699          						      GFX_DrawBitMap(UIMENU_POWER_COORD,button_powerdisable, button_dimensions);
   2700                            WaitGrabEInk();
   2701                            update(partialrefresh);
   2702                            ReleaseEInk();
   2703                          break;
   2704                        }
   2705                      }
   2706                      else if(UI_BUTTONdata&UI_BTNAFLAG){
   2707                        disableUITimeout();
   2708                        switch(MenuSubState){
   2709                          case UI_MENU_HOME_SUBSTATE:
   2710                            UI_StateMachine = UI_HOME_STATE;
   2711                            CoPostSem(semInkUI);
   2712                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("B btn: menu->home state\r\n");
   2713                            setHomeScreen(beaconName,addressfield);
   2714                            setStringerGraphics(led_flags);
   2715                            WaitGrabEInk();
   2716                            update(fullrefresh);
   2717                            ReleaseEInk();
   2718                          break;
   2719                          case UI_MENU_STATUS_SUBSTATE:
   2720                            UI_StateMachine = UI_STATUS_RADIO_STATE;
   2721                            CoPostSem(semInkUI);
   2722                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("B btn: menu->status radio state\r\n");
   2723                            //GFX_FillBuffer(black);
   2724          						      GFX_DrawBitMap(UISTATUS_COORD,status_radio_static, statusscreen_dimensions);
   2725                            setFont(smallfont);
   2726                            setCursor(UIHOME_DURATION_COORD);
   2727                            GFX_Print("8.00H", strlen("8.00H"),leftalign, black, gray_l);
   2728                            WaitGrabEInk();
   2729                            update(fullrefresh);
   2730                            ReleaseEInk();
   2731                          break;
   2732          #if 0
   2733                          case UI_MENU_ID_SUBSTATE:
   2734                            UI_StateMachine = UI_ID_STATE;
   2735                            CoPostSem(semInkUI);
   2736                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("B btn: menu->ID state\r\n");
   2737                          break;
   2738          #endif
   2739                          case UI_MENU_POWER_SUBSTATE:
   2740                            //power down sequence
   2741                            if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("PWR DOWN SEQUENCE\r\n");
   2742                            GFX_FillBuffer(black);
   2743                            GFX_DrawBitMap(UI_LOGO_COORD, logo, logo_dimensions);
   2744                            setFont(smallfont);
   2745                            setCursor(UIPOWER_TEXT_COORD);
   2746                            GFX_Print("Turning Off", strlen("Turning Off"),centeralign, black, gray_l);
   2747                            WaitGrabEInk();
   2748                            update(fullrefresh);
   2749                            ReleaseEInk();
   2750                            GFX_FillBuffer(black);
   2751                            WaitGrabEInk();
   2752                            update(fullrefresh);
   2753                            ReleaseEInk();
   2754                            CoSchedLock();                      //shut down sequence
   2755                            HwGPOLow(GPO_RF_EN);
   2756                            HwGPOLow(GPO_VBATT_ADC_EN);
   2757                            HwGPOInitOC(GPO_USB_VBUS); 
   2758                            HwGPOLow(GPO_USB_VBUS);  
   2759                            HwGPOLow(GPO_PWRON) ; 
   2760                            while (1);
   2761                          break;
   2762                        }
   2763                      } else CoPostSem(semInkUI); //for sanity
   2764                    break;
   2765                    case UI_STATUS_RADIO_STATE:
   2766                      if(UI_BUTTONdata&UI_PWRBTNFLAG 
   2767                      //||UI_BUTTONdata&UI_BTNBFLAG
   2768                      ){
   2769                        UI_StateMachine = UI_HOME_STATE;
   2770                        CoPostSem(semInkUI);
   2771                        if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("X/B btn: status radio -> home\r\n");
   2772                        setHomeScreen(beaconName,addressfield);
   2773                        setStringerGraphics(led_flags);
   2774                        WaitGrabEInk();
   2775                        update(fullrefresh);
   2776                        ReleaseEInk();
   2777                      }
   2778                      else if(UI_BUTTONdata&UI_BTNBFLAG){
   2779                        UI_StateMachine = UI_STATUS_BATTERY_STATE;
   2780                        CoPostSem(semInkUI);
   2781                        if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("A btn: status radio -> status battery\r\n");
   2782                        //GFX_FillBuffer(black);
   2783          						  GFX_DrawBitMap(UISTATUS_COORD,status_battery_static, statusscreen_dimensions);
   2784                        setFont(smallfont);
   2785                        setCursor(UIHOME_DURATION_COORD);
   2786                        GFX_Print("8.00H", strlen("8.00H"),leftalign, black, gray_l);
   2787                        WaitGrabEInk();
   2788                        update(fullrefresh);
   2789                        ReleaseEInk();
   2790                      } 
   2791                      else CoPostSem(semInkUI);
   2792                    break;
   2793                    case UI_STATUS_BATTERY_STATE:
   2794                      if(UI_BUTTONdata&UI_PWRBTNFLAG){
   2795                        UI_StateMachine = UI_HOME_STATE;
   2796                        CoPostSem(semInkUI);
   2797                        if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("Battery -> Home\r\n");
   2798                        setHomeScreen(beaconName,addressfield);
   2799                        setStringerGraphics(led_flags);
   2800                        WaitGrabEInk();
   2801                        update(fullrefresh);
   2802                        ReleaseEInk();
   2803                      }
   2804                      else if(UI_BUTTONdata&UI_BTNBFLAG){
   2805                        UI_StateMachine = UI_STATUS_RADIO_STATE;
   2806                        CoPostSem(semInkUI);
   2807                        if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("A btn: status battery -> status radio\r\n");
   2808                        //GFX_FillBuffer(black);
   2809          						  GFX_DrawBitMap(UISTATUS_COORD,status_radio_static, statusscreen_dimensions);
   2810                        setFont(smallfont);
   2811                        setCursor(UIHOME_DURATION_COORD);
   2812                        GFX_Print("8.00H", strlen("8.00H"),leftalign, black, gray_l);
   2813                        WaitGrabEInk();
   2814                        update(fullrefresh);
   2815                        ReleaseEInk();              
   2816                      }CoPostSem(semInkUI);
   2817                    break;
   2818          #if 0
   2819                    case UI_ID_STATE:
   2820                      //tradeshow: still screen. Any button returns to Home state
   2821                      UI_StateMachine = UI_HOME_STATE;
   2822                      CoPostSem(semInkUI);
   2823                      if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("ID -> Home\r\n");
   2824                    break;
   2825          #endif
   2826                  }
   2827                  UI_BUTTONdata=0;
   2828                }
   2829                else if(getFlags == 1<<flagLED_UI){
   2830                  CoClearFlag(flagLED_UI);
   2831                  CoPendSem(semInkUI, 0);
   2832                  
   2833                  if((UI_IRLEDdata & UI_IRLED0FLAG)>>0 != (led_flags & UI_IRLED0FLAG) >>0){
   2834                    if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("update irled0\r\n");
   2835                  }
   2836                  if((UI_IRLEDdata & UI_IRLED1FLAG)>>1 != (led_flags & UI_IRLED1FLAG) >>1){
   2837                    if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("update irled1\r\n");
   2838                  }
   2839                  if((UI_IRLEDdata & UI_IRLED2FLAG)>>2 != (led_flags & UI_IRLED2FLAG) >>2){
   2840                    if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("update irled2\r\n");
   2841                  }
   2842                  led_flags = UI_IRLEDdata;
   2843                  CoPostSem(semInkUI);
   2844                  if(UI_StateMachine == UI_HOME_STATE){ //for sanity
   2845                    setHomeScreen(beaconName,addressfield);
   2846                    setStringerGraphics(led_flags);
   2847                    WaitGrabEInk();
   2848                    update(partialrefresh);
   2849                    ReleaseEInk();
   2850                  }
   2851                }
   2852                else if(getFlags == 1<<flagTimeout_UI){
   2853                  CoClearFlag(flagTimeout_UI);
   2854                  if(UI_StateMachine == UI_MENU_STATE){
   2855                    UI_StateMachine = UI_HOME_STATE;
   2856                    setHomeScreen(beaconName,addressfield);
   2857                    setStringerGraphics(led_flags);
   2858                    WaitGrabEInk();
   2859                    update(fullrefresh);
   2860                    ReleaseEInk();
   2861                  }
   2862                }
   2863                else{ //if(getFlags == 1<<flagUSBdata_UI){
   2864                  CoClearFlag(flagUSBdata_UI);
   2865                  WaitGrabI2C();
   2866                  I2C_EE_BufferRead(&beaconName[0], 128, 12);
   2867                  ReleaseI2C();
   2868                  CoPendSem(semInkUI,0);
   2869                  sprintf(addressfield, "ID%i", config.mySrcAddr);
   2870                  CoPostSem(semInkUI);
   2871                  if(UI_StateMachine == UI_HOME_STATE){ //for sanity
   2872                    setHomeScreen(beaconName,addressfield);
   2873                    setStringerGraphics(led_flags);
   2874                    WaitGrabEInk();
   2875                    update(fullrefresh);
   2876                    ReleaseEInk();
   2877                  }
   2878                }
   2879              }
   2880              else{
   2881                if(config.flags & FLAG_TRACE_UI_STATEMACHINE) TRACE("result was error\r\n");
   2882              }
   2883            }
   2884          }
   2885          
   2886          static void setHomeScreen(uint8_t stringname[], uint8_t addr[]){
   2887            uint8_t * pos;
   2888            uint8_t len;
   2889            GFX_FillBuffer(black);
   2890            GFX_DrawBitMap(UI_BATTERY_TEXT_COORD, battery100, battery_text_dimensions);
   2891            fillRoundRect(27, 136, button_dimensions, 5, gray_d);
   2892            setFont(smallfont);
   2893            setCursor(UIHOME_DURATION_COORD);
   2894            GFX_Print("8.00H", strlen("8.00H"),leftalign, black, gray_l);
   2895            setFont(largefont);
   2896            setCursor(UIHOME_NAMETOP_COORD);
   2897            pos=strchr(stringname, ' ');
   2898            if(pos==NULL){
   2899              GFX_Print(stringname, strlen(stringname),centeralign, black, gray_l);
   2900            }
   2901            else{
   2902              GFX_Print(stringname, pos-stringname, centeralign, black, gray_l);
   2903              setCursor(UIHOME_NAMEBOTTOM_COORD);
   2904              len=strlen(stringname)-(++pos-stringname);
   2905              GFX_Print(pos,len,centeralign,black,gray_l);
   2906            }
   2907            setCursor(UIHOME_ID_COORD);
   2908            GFX_Print(addr, strlen(addr),centeralign, gray_d, white);
   2909            
   2910          }
   2911          
   2912          static void setStringerGraphics(uint8_t led_flags){
   2913            if(led_flags & UI_IRLED0FLAG)
   2914              GFX_DrawBitMap(UIHOME_STRINGER1_COORD, stringer1enable, stringer_dimensions);
   2915            else
   2916              GFX_DrawBitMap(UIHOME_STRINGER1_COORD, stringer1disable, stringer_dimensions);
   2917            
   2918            if(led_flags & UI_IRLED1FLAG)
   2919              GFX_DrawBitMap(UIHOME_STRINGER2_COORD, stringer2enable, stringer_dimensions);
   2920            else  
   2921              GFX_DrawBitMap(UIHOME_STRINGER2_COORD, stringer2disable, stringer_dimensions);
   2922            
   2923            if(led_flags & UI_IRLED2FLAG)
   2924              GFX_DrawBitMap(UIHOME_STRINGER3_COORD, stringer3enable, stringer_dimensions);
   2925            else
   2926              GFX_DrawBitMap(UIHOME_STRINGER3_COORD, stringer3disable, stringer_dimensions);
   2927          }
   2928          
   2929          static void resetUITimeout(void){
   2930            TIM7->CNT=0;
   2931            TIM_Cmd(TIM7,ENABLE);
   2932          }
   2933          
   2934          static void disableUITimeout(void){
   2935            TIM_Cmd(TIM7,DISABLE);
   2936          }
   2937          /******************* (C) COPYRIGHT 2011 NaturalPoint, Inc. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  GetAverageImuData
        0  InputDataIntoBuffer
        0  NVIC_GenerateSystemReset
        8  PrintConfig
               8 -> TRACE
       24  RadioTxPktQueue
              24 -> CoSetFlag
              24 -> memcpy
        8  ReadPage
       32  SerialDownload
              32 -> WritePage
              32 -> memcpy
       24  SetConfig
              24 -> CoSetFlag
              24 -> DAC_SetChannel2Data
              24 -> RadioSetPanIdShortAddr
              24 -> RadioSetRFChan
              24 -> RadioSetRFLevel
              24 -> SetTimeSlot
              24 -> TRACE
        8  SetTimeSlot
               8 -> SetTimeSlot
        0  Task1
               0 -> CoAwakeTask
               0 -> CoPendSem
               0 -> CoPostSem
               0 -> CoSuspendTask
               0 -> CoWaitForSingleFlag
               0 -> GetAverageImuData
               0 -> HwButtonPressed
               0 -> IWDG_ReloadCounter
               0 -> RadioTxPktQueue
               0 -> TRACE
               0 -> __writeIMU
        8  Task3
               8 -> CoAcceptSem
               8 -> CoAwakeTask
               8 -> CoPendSem
               8 -> CoPostSem
               8 -> CoSchedLock
               8 -> CoSetFlag
               8 -> CoTickDelay
               8 -> GFX_DrawBitMap
               8 -> GFX_FillBuffer
               8 -> GFX_Print
               8 -> HwGPIState
               8 -> HwGPOInitOC
               8 -> HwGPOLow
               8 -> IMUInit
               8 -> IWDG_ReloadCounter
               8 -> ReleaseEInk
               8 -> SetTimeSlot
               8 -> TRACE
               8 -> WaitGrabEInk
               8 -> getButtonState
               8 -> setCursor
               8 -> setFont
               8 -> update
        0  Task8
               0 -> ADC_GetConversionValue
               0 -> ADC_SoftwareStartConvCmd
               0 -> CoTickDelay
               0 -> HwGPIState
               0 -> HwGPOHigh
               0 -> IWDG_ReloadCounter
               0 -> __aeabi_cfcmple
               0 -> __aeabi_cfrcmple
               0 -> __aeabi_d2f
               0 -> __aeabi_d2iz
               0 -> __aeabi_dadd
               0 -> __aeabi_ddiv
               0 -> __aeabi_dmul
               0 -> __aeabi_f2d
               0 -> __aeabi_f2iz
               0 -> __aeabi_fadd
               0 -> __aeabi_fdiv
               0 -> __aeabi_fmul
               0 -> __aeabi_ui2f
      440  TaskConfig
             440 -> CalcConfigChecksum
             440 -> CoClearFlag
             440 -> CoGetOSTime
             440 -> CoGetStackDepth
             440 -> CoGetTaskFunc
             440 -> CoGetTaskLine
             440 -> CoGetTaskScheduledCount
             440 -> CoSetFlag
             440 -> CoTickDelay
             440 -> CopyConfigToExConfig
             440 -> CopyExConfigToConfig
             440 -> I2C_EE_BufferRead
             440 -> I2C_EE_BufferWrite
             440 -> IMUProcess
             440 -> IWDG_ReloadCounter
             440 -> NVIC_GenerateSystemReset
             440 -> PrintConfig
             440 -> RadioIMU_ReleaseSPI
             440 -> RadioIMU_WaitGrabSPI
             440 -> RadioPrint2520Registers
             440 -> RadioSetPanIdShortAddr
             440 -> RadioSetRFChan
             440 -> RadioSetRFLevel
             440 -> ReadPage
             440 -> ReleaseI2C
             440 -> SaveConfig
             440 -> SerialDownload
             440 -> SetConfig
             440 -> TRACE
             440 -> ValidateCommandLine
             440 -> WaitGrabI2C
             440 -> __writeCmdLineRespPacket
             440 -> b64_pton
             440 -> isspace
             440 -> memcpy
             440 -> memset
             440 -> mygets
             440 -> strcpy
             440 -> strlen
             440 -> strtoul
        8  TaskIMU_G
               8 -> CoClearFlag
               8 -> CoSetFlag
               8 -> CoWaitForSingleFlag
               8 -> IMUProcess
               8 -> IWDG_ReloadCounter
               8 -> InputDataIntoBuffer
               8 -> RadioIMU_ReleaseSPI
               8 -> RadioIMU_WaitGrabSPI
               8 -> TRACE
        0  TaskLED
               0 -> CoClearFlag
               0 -> CoPendSem
               0 -> CoPostSem
               0 -> CoSetFlag
               0 -> CoTickDelay
               0 -> CoWaitForSingleFlag
               0 -> HwGPOstatus
               0 -> IWDG_ReloadCounter
               0 -> ReleaseI2C
               0 -> TRACE
               0 -> WaitGrabI2C
               0 -> __aeabi_cfrcmple
               0 -> __aeabi_fdiv
               0 -> __aeabi_i2f
               0 -> ledbuffer_set
       40  TaskRadioRx
              40 -> CoGetOSTime
              40 -> CoPendSem
              40 -> HwWait
              40 -> IWDG_ReloadCounter
              40 -> ProcessRXError
              40 -> RadioIMU_ReleaseSPI
              40 -> RadioIMU_WaitGrabSPI
              40 -> RadioRxPkt
              40 -> TIM_GetITStatus
              40 -> TIM_SetAutoreload
              40 -> TIM_SetCompare2
              40 -> TIM_SetCompare3
              40 -> TIM_SetCompare4
              40 -> TIM_SetCounter
              40 -> TRACE
              40 -> abs
              40 -> assert_failed
              40 -> crc8
        8  TaskRadioTx
               8 -> CoWaitForSingleFlag
               8 -> IWDG_ReloadCounter
               8 -> RadioIMU_ReleaseSPI
               8 -> RadioIMU_WaitGrabSPI
               8 -> RadioTxPkt
        8  TaskUI
               8 -> CoAwakeTask
               8 -> CoClearFlag
               8 -> CoPendSem
               8 -> CoPostSem
               8 -> CoSchedLock
               8 -> CoTickDelay
               8 -> CoWaitForMultipleFlags
               8 -> Eink_Init
               8 -> GFX_DrawBitMap
               8 -> GFX_FillBuffer
               8 -> GFX_Print
               8 -> HwGPOInitOC
               8 -> HwGPOLow
               8 -> I2C_EE_BufferRead
               8 -> IWDG_ReloadCounter
               8 -> ReleaseEInk
               8 -> ReleaseI2C
               8 -> TRACE
               8 -> WaitGrabEInk
               8 -> WaitGrabI2C
               8 -> disableUITimeout
               8 -> resetUITimeout
               8 -> setCursor
               8 -> setFont
               8 -> setHomeScreen
               8 -> setStringerGraphics
               8 -> sprintf
               8 -> update
       32  WritePage
              32 -> FLASH_ErasePage
              32 -> FLASH_Lock
              32 -> FLASH_ProgramWord
              32 -> FLASH_Unlock
        0  _LocaleC_isspace
        8  disableUITimeout
               8 -> TIM_Cmd
        8  getButtonState
               8 -> HwButtonPressed
        8  isspace
               8 -> _LocaleC_isspace
       16  memcpy
              16 -> __aeabi_memcpy
       16  memset
              16 -> __aeabi_memset
       16  mygets
              16 -> CoTickDelay
              16 -> getchar
              16 -> putchar
        8  resetUITimeout
               8 -> TIM_Cmd
       32  setHomeScreen
              32 -> GFX_DrawBitMap
              32 -> GFX_FillBuffer
              32 -> GFX_Print
              32 -> fillRoundRect
              32 -> setCursor
              32 -> setFont
              32 -> strchr
              32 -> strlen
       16  setStringerGraphics
              16 -> GFX_DrawBitMap
       16  strchr
              16 -> __iar_Strchr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant " No IMU Installed\n\n\r">
      28  ?<Constant " Nov 13 2019 : 10:52:...">
      16  ?<Constant "%X, %X, %X\n\r">
      48  ?<Constant "**ERROR** Unrecognize...">
      40  ?<Constant "**ERROR** Unrecognize...">_1
      12  ?<Constant "10:52:16">
       8  ?<Constant "8.00H">
      52  ?<Constant ": excFlag0=0x%02X exc...">
      48  ?<Constant ": remainOutOfSyncTime...">
      44  ?<Constant ": rxCount=%d rxFIFOEr...">
      36  ?<Constant ": rxFIFOTime %d.%d se...">
      36  ?<Constant ": rxWait @ %d.%d rxSt...">
      52  ?<Constant ": successBeacons=%d f...">
      32  ?<Constant ": tkFrameId=%d assert...">
      64  ?<Constant ": txStart @ %d.%d txE...">
      20  ?<Constant ":%u @%u t:%d d:%u\n\r">
       4  ?<Constant "> ">
      32  ?<Constant "A btn: in menu ID sub...">
      32  ?<Constant "A btn: in menu home s...">
      36  ?<Constant "A btn: in menu status...">
      40  ?<Constant "A btn: status battery...">
      40  ?<Constant "A btn: status radio -...">
      40  ?<Constant "ARM Serial Number 0x%...">
      28  ?<Constant "B btn: menu->home sta...">
      36  ?<Constant "B btn: menu->status r...">
      20  ?<Constant "Battery -> Home\r\n">
      32  ?<Constant "Beacon received: CRC8...">
      48  ?<Constant "Beacon received: Unsu...">
      40  ?<Constant "Beacon received: unkn...">
      36  ?<Constant "Beacon: changing fram...">
      16  ?<Constant "Btn A PRESS\r\n">
      16  ?<Constant "Btn B PRESS\r\n">
      32  ?<Constant "Built on Nov 13 2019 ...">
     112  ?<Constant "C:\\Users\\kmak\\Documen...">
      32  ?<Constant "CPU Serial #%04x:%04x...">
      36  ?<Constant "Current SysTickCount:...">
      24  ?<Constant "ERROR! Tx Buffer full\n\r">
      12  ?<Constant "Erased\n\r">
      20  ?<Constant "Flags = 0x%08X \r\n">
      16  ?<Constant "Framebits: %d\r\n">
      24  ?<Constant "Generating hard fault\r\n">
      24  ?<Constant "I2C irled%i not on\n\r">
       8  ?<Constant "ID%i">
      20  ?<Constant "IMU Debug print:\n\r">
      16  ?<Constant "IMU Present\n\n\r">
      40  ?<Constant "IRled0 = %i, IRled1 =...">
      24  ?<Constant "Incorrect packet size\r\n">
      20  ?<Constant "Incorrect packet\r\n">
      20  ?<Constant "Mem addr error\n\r">
      24  ?<Constant "Mem at 0x%08X=0x%08X\n\r">
      40  ?<Constant "New bcn id:%u>%u tick...">
      28  ?<Constant "New timeslot offset =...">
      32  ?<Constant "No TK sync for %d sec...">
      28  ?<Constant "No sync timeout sec: ...">
      12  ?<Constant "Nov 13 2019">
      52  ?<Constant "PERF: IdleTask: %u Ta...">
      32  ?<Constant "PERF: Task8: %u TaskI...">
      36  ?<Constant "PERF: TaskConfig: %u ...">
      20  ?<Constant "PWR DOWN SEQUENCE\r\n">
      16  ?<Constant "RF CHAN: %d\n\r">
      20  ?<Constant "RF Tx Level: %X\n\r">
      44  ?<Constant "RadioRxTask [avail st...">
      44  ?<Constant "RadioTxTask [avail st...">
      40  ?<Constant "Task1 [avail stack:%d...">
      40  ?<Constant "Task3 [avail stack:%d...">
      40  ?<Constant "Task8 [avail stack:%d...">
      44  ?<Constant "TaskConfig [avail sta...">
      40  ?<Constant "TaskIMU [avail stack:...">
      24  ?<Constant "Timekeeper sync: %s\n\r">
      20  ?<Constant "Timer adjust: %d\n\r">
      12  ?<Constant "Turning Off">
      20  ?<Constant "Watchdog is %s\r\n">
      24  ?<Constant "X btn: Home -> Menu\r\n">
      32  ?<Constant "X/B btn: status radio...">
      24  ?<Constant "[0] productID   : %X\n\r">
      24  ?<Constant "[1] serialNum   : %X\n\r">
      28  ?<Constant "[2] panId       : %04X\n\r">
      28  ?<Constant "[3] mySrcAddr   : %04X\n\r">
      32  ?<Constant "[4] routerDstAddr   :...">
      24  ?<Constant "[5] ledOnOffs   : %X\n\r">
      24  ?<Constant "[6] ledOffOffs  : %X\n\r">
      24  ?<Constant "[7] ledDAC      : %X\n\r">
      28  ?<Constant "[8] rfChan      : %02X\n\r">
      28  ?<Constant "[9] led0Id      : %02X\n\r">
      28  ?<Constant "[?] rfTimeSlot  : %02X\n\r">
      28  ?<Constant "[A] led1Id      : %02X\n\r">
      28  ?<Constant "[B] led2Id      : %02X\n\r">
      24  ?<Constant "[C] TestMode    : %d\n\r">
      28  ?<Constant "[J] led0IdPattern : %...">
      28  ?<Constant "[K] led1IdPattern : %...">
      28  ?<Constant "[L] led2IdPattern : %...">
      24  ?<Constant "[M] led0Index : %08X\n\r">
      24  ?<Constant "[N] led1Index : %08X\n\r">
      24  ?<Constant "[O] led2Index : %08X\n\r">
      16  ?<Constant "[X] Radio: %s\n\r">
      24  ?<Constant "[Y] frameBits   : %d\n\r">
      24  ?<Constant "[Z] Tx RF Level : %X\n\r">
      48  ?<Constant "\n\r FIRMWARE VERSION: ...">
       8  ?<Constant "active">
      48  ?<Constant "adjust=%d tim3_phase=...">
      32  ?<Constant "adjusted=%u over=%d @...">
      40  ?<Constant "bc=%d NULL packet, rx...">
      56  ?<Constant "bc=%d skip TK frame %...">
      60  ?<Constant "bc=%d stale TK frame ...">
      92  ?<Constant "bc=%d tk(%d,,%3d) AtS...">
      64  ?<Constant "changeClocks=%d newbc...">
      56  ?<Constant "errorFrameId=%u valid...">
      24  ?<Constant "fault_counter = %u\r\n">
      20  ?<Constant "led blinking=%d\r\n">
      12  ?<Constant "loading...">
      48  ?<Constant "newFrameTime @%d.%d f...">
       4  ?<Constant "no">
      12  ?<Constant "not active">
       4  ?<Constant "off">
      32  ?<Constant "oldFrameTime @%d.%d f...">
      48  ?<Constant "oldTim3Phase=%u newTi...">
       4  ?<Constant "on">
      24  ?<Constant "ooopss.. wrong value\n\r">
      20  ?<Constant "result was error\r\n">
      20  ?<Constant "retry I2C irled%i\n\r">
      44  ?<Constant "rxPkts=%u rxTotal=%u ...">
      36  ?<Constant "saved_pc=0x%08X saved...">
      20  ?<Constant "semaphore blocked\r\n">
      40  ?<Constant "stacked_lr=0x%08X sta...">
      40  ?<Constant "stacked_psr=0x%08X sa...">
      84  ?<Constant "tkFrameId=%d frameIdA...">
      32  ?<Constant "trace_irq=%d at tim3P...">
      16  ?<Constant "update irled0\r\n">
      16  ?<Constant "update irled1\r\n">
      16  ?<Constant "update irled2\r\n">
       4  ?<Constant "yes">
       4  ?<Constant (IRled_status){0, 0, 0}>
       4  ?<Constant (tButton){0, 0, 0, 0}>
       4  ?<Constant (tButton){1, 0, 0, 0}>
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_33
       4  ??DataTable11_34
       4  ??DataTable11_35
       4  ??DataTable11_36
       4  ??DataTable11_37
       4  ??DataTable11_38
       4  ??DataTable11_39
       4  ??DataTable11_4
       4  ??DataTable11_40
       4  ??DataTable11_41
       4  ??DataTable11_42
       4  ??DataTable11_43
       4  ??DataTable11_44
       4  ??DataTable11_45
       4  ??DataTable11_46
       4  ??DataTable11_47
       4  ??DataTable11_48
       4  ??DataTable11_49
       4  ??DataTable11_5
       4  ??DataTable11_50
       4  ??DataTable11_51
       4  ??DataTable11_52
       4  ??DataTable11_53
       4  ??DataTable11_54
       4  ??DataTable11_55
       4  ??DataTable11_56
       4  ??DataTable11_57
       4  ??DataTable11_58
       4  ??DataTable11_59
       4  ??DataTable11_6
       4  ??DataTable11_60
       4  ??DataTable11_61
       4  ??DataTable11_62
       4  ??DataTable11_63
       4  ??DataTable11_64
       4  ??DataTable11_65
       4  ??DataTable11_66
       4  ??DataTable11_67
       4  ??DataTable11_68
       4  ??DataTable11_69
       4  ??DataTable11_7
       4  ??DataTable11_70
       4  ??DataTable11_71
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_27
       4  ??DataTable12_28
       4  ??DataTable12_29
       4  ??DataTable12_3
       4  ??DataTable12_30
       4  ??DataTable12_31
       4  ??DataTable12_32
       4  ??DataTable12_33
       4  ??DataTable12_34
       4  ??DataTable12_35
       4  ??DataTable12_36
       4  ??DataTable12_37
       4  ??DataTable12_38
       4  ??DataTable12_39
       4  ??DataTable12_4
       4  ??DataTable12_40
       4  ??DataTable12_41
       4  ??DataTable12_42
       4  ??DataTable12_43
       4  ??DataTable12_44
       4  ??DataTable12_45
       4  ??DataTable12_46
       4  ??DataTable12_47
       4  ??DataTable12_48
       4  ??DataTable12_49
       4  ??DataTable12_5
       4  ??DataTable12_50
       4  ??DataTable12_51
       4  ??DataTable12_52
       4  ??DataTable12_53
       4  ??DataTable12_54
       4  ??DataTable12_55
       4  ??DataTable12_56
       4  ??DataTable12_57
       4  ??DataTable12_58
       4  ??DataTable12_59
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_34
       4  ??DataTable16_35
       4  ??DataTable16_36
       4  ??DataTable16_37
       4  ??DataTable16_38
       4  ??DataTable16_39
       4  ??DataTable16_4
       4  ??DataTable16_40
       4  ??DataTable16_41
       4  ??DataTable16_42
       4  ??DataTable16_43
       4  ??DataTable16_44
       4  ??DataTable16_45
       4  ??DataTable16_46
       4  ??DataTable16_47
       4  ??DataTable16_48
       4  ??DataTable16_49
       4  ??DataTable16_5
       4  ??DataTable16_50
       4  ??DataTable16_51
       4  ??DataTable16_52
       4  ??DataTable16_53
       4  ??DataTable16_54
       4  ??DataTable16_55
       4  ??DataTable16_56
       4  ??DataTable16_57
       4  ??DataTable16_58
       4  ??DataTable16_59
       4  ??DataTable16_6
       4  ??DataTable16_60
       4  ??DataTable16_61
       4  ??DataTable16_62
       4  ??DataTable16_63
       4  ??DataTable16_64
       4  ??DataTable16_65
       4  ??DataTable16_66
       4  ??DataTable16_67
       4  ??DataTable16_68
       4  ??DataTable16_69
       4  ??DataTable16_7
       4  ??DataTable16_70
       4  ??DataTable16_71
       4  ??DataTable16_72
       4  ??DataTable16_73
       4  ??DataTable16_74
       4  ??DataTable16_75
       4  ??DataTable16_76
       4  ??DataTable16_77
       4  ??DataTable16_78
       4  ??DataTable16_79
       4  ??DataTable16_8
       4  ??DataTable16_80
       4  ??DataTable16_81
       4  ??DataTable16_82
       4  ??DataTable16_83
       4  ??DataTable16_84
       4  ??DataTable16_85
       4  ??DataTable16_86
       4  ??DataTable16_87
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_27
       4  ??DataTable21_28
       4  ??DataTable21_29
       4  ??DataTable21_3
       4  ??DataTable21_30
       4  ??DataTable21_31
       4  ??DataTable21_32
       4  ??DataTable21_33
       4  ??DataTable21_34
       4  ??DataTable21_35
       4  ??DataTable21_36
       4  ??DataTable21_37
       4  ??DataTable21_38
       4  ??DataTable21_39
       4  ??DataTable21_4
       4  ??DataTable21_40
       4  ??DataTable21_41
       4  ??DataTable21_42
       4  ??DataTable21_43
       4  ??DataTable21_44
       4  ??DataTable21_45
       4  ??DataTable21_46
       4  ??DataTable21_47
       4  ??DataTable21_48
       4  ??DataTable21_49
       4  ??DataTable21_5
       4  ??DataTable21_50
       4  ??DataTable21_51
       4  ??DataTable21_52
       4  ??DataTable21_53
       4  ??DataTable21_54
       4  ??DataTable21_55
       4  ??DataTable21_56
       4  ??DataTable21_57
       4  ??DataTable21_58
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_24
       4  ??DataTable8_25
       4  ??DataTable8_26
       4  ??DataTable8_27
       4  ??DataTable8_28
       4  ??DataTable8_29
       4  ??DataTable8_3
       4  ??DataTable8_30
       4  ??DataTable8_31
       4  ??DataTable8_32
       4  ??DataTable8_33
       4  ??DataTable8_34
       4  ??DataTable8_35
       4  ??DataTable8_36
       4  ??DataTable8_37
       4  ??DataTable8_38
       4  ??DataTable8_39
       4  ??DataTable8_4
       4  ??DataTable8_40
       4  ??DataTable8_41
       4  ??DataTable8_42
       4  ??DataTable8_43
       4  ??DataTable8_44
       4  ??DataTable8_45
       4  ??DataTable8_46
       4  ??DataTable8_47
       4  ??DataTable8_48
       4  ??DataTable8_49
       4  ??DataTable8_5
       4  ??DataTable8_50
       4  ??DataTable8_51
       4  ??DataTable8_52
       4  ??DataTable8_53
       4  ??DataTable8_54
       4  ??DataTable8_55
       4  ??DataTable8_56
       4  ??DataTable8_57
       4  ??DataTable8_58
       4  ??DataTable8_59
       4  ??DataTable8_6
       4  ??DataTable8_60
       4  ??DataTable8_61
       4  ??DataTable8_62
       4  ??DataTable8_63
       4  ??DataTable8_64
       4  ??DataTable8_65
       4  ??DataTable8_66
       4  ??DataTable8_67
       4  ??DataTable8_68
       4  ??DataTable8_69
       4  ??DataTable8_7
       4  ??DataTable8_70
       4  ??DataTable8_71
       4  ??DataTable8_72
       4  ??DataTable8_73
       4  ??DataTable8_74
       4  ??DataTable8_75
       4  ??DataTable8_76
       4  ??DataTable8_77
       4  ??DataTable8_78
       4  ??DataTable8_79
       4  ??DataTable8_8
       4  ??DataTable8_80
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_29
       4  ??DataTable9_3
       4  ??DataTable9_30
       4  ??DataTable9_31
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       4  ButtonA
       4  ButtonB
       2  CurrentDataPointer
       1  FRAME_DIFF_DELTA
      50  GetAverageImuData
       4  IMUdbgPrt
       4  IRled_flags
      44  InputDataIntoBuffer
       1  MenuSubState
      12  NVIC_GenerateSystemReset
     530  PrintConfig
     238  RadioTxPktQueue
      36  ReadPage
       2  RfTxLevel
     276  SerialDownload
     574  SetConfig
      72  SetTimeSlot
     628  Task1
     976  Task3
    1084  Task8
    4684  TaskConfig
     236  TaskIMU_G
     818  TaskLED
    2398  TaskRadioRx
     428  TaskRadioTx
    2148  TaskUI
      32  TimeSlotVals
       1  UI_BUTTONdata
       1  UI_IRLEDdata
       1  UI_StateMachine
       4  Valids
     190  WritePage
      22  _LocaleC_isspace
       1  acc_adjust_count
       1  acc_done
       4  acc_time_adjust
      64  accs
       4  addr
       8  addressfield
       4  adjustedFrameId
       2  adjustedPhase
       4  avgPhaseDiffPerFrame
       1  bat_slot_numbers
       2  battery_minutes
       1  beaconInSync
      32  beaconName
       1  beaconRSSI
     512  buff
       4  calls
       4  changeClocks
       1  changeFrameClock
       1  checkled
       1  cmd
      68  config
       4  counterIMU
     512  decoded
      12  disableUITimeout
     512  encoded
       8  endRadioTx
       4  errorFrameId
      40  fLast
       4  fVolt
       1  firstTime
       4  frameDiff
       4  frameIdAdjusting
       4  frameIdCorrectionCount
       1  frameIdFlag
       2  frameOffset
      78  getButtonState
       4  getFlags
       2  halted
       4  header
       2  holdCount
       1  i
       2  i
       4  imuaccess
       2  inIdx
       4  inidxcheck
      12  isspace
       4  iter
      12  lastBatStatus
       1  lastFrameClock
       4  lastFrameId
       4  lastFrameIdCorrection
       8  lastFrameTime
       1  lastRadioTx
       4  lastTKFrameId
       1  lastTick
       2  lastTim3Phase
       4  lastTime
       4  last_bat_sent
       1  last_button_state
       1  last_percents
       1  last_test_imu_pkt_ctr
       1  led_errorcheck
       1  led_flags
       1  led_select
       4  led_value
   16380  log
       2  log_index_in
       4  lostSync
      22  memcpy
      22  memset
       4  mycalls
     150  mygets
       4  newFrameIdAtSync
       8  newFrameTime
       4  newTKFrameId
       2  newTim3Phase
       4  newbcn
       4  notValids
       4  now_sec
       4  oldARR
       4  oldFrameIdAtSync
       8  oldFrameTime
       2  oldTim3Phase
       4  old_sec
       4  old_tim
       2  outIdx
       4  outidxcheck
       4  pBeacon_Data_pkt
       4  pBuf
       4  pRxPkt
       2  packet
    2056  page
       4  phaseDiff
       4  pushed_times
       1  pwrbtnflag
       1  queue_full
       8  radioRxEnd
       8  radioRxStart
       8  radioRxWait
       4  radioTxEntries
       4  random
       2  random_slot1
       2  random_slot2
       4  remainOutOfSyncTime
      18  resetUITimeout
       1  result
       1  rfChan
       2  routerAddr
       4  rt_flags
       4  rxNotEmpty
       4  rxReloaded
       4  rxTotalRcvd
       1  rx_reload
       4  savedFrameIdAtSync
       4  savedFrameIdInced
       4  saved_trace_irq
       1  semAllow
       1  semAllowPostTask
       1  seqNum
     226  setHomeScreen
       1  setIMUReady
       1  setRadioTx
     122  setStringerGraphics
       1  setTxDone
       4  skipPackets
       4  span
       8  startRadioTx
      16  strchr
       4  successBeacons
    1024  tab_1024
       1  task2StatusType
       4  task2_errors
       4  task2enter
       1  task3event
       1  test_imu_pkt_ctr
       4  tim
       4  tim3_phase
       2  tim4_phase
       2  tim_at_sec
       4  tkFrameId
     116  txBuf
       4  txCalls
       4  txCalls2
     960  txPktQueue
       2  txTimeSlot
       4  txradioaccess_cnt
       1  use_sync
       2  use_tim3_phase
       4  value
       4  value
     136  -- Other

 
 20 640 bytes in section .bss
  2 104 bytes in section .data
      4 bytes in section .noinit
  4 164 bytes in section .rodata
 18 110 bytes in section .text
 
 18 016 bytes of CODE  memory (+ 94 bytes shared)
  4 164 bytes of CONST memory
 22 748 bytes of DATA  memory

Errors: none
Warnings: 26
