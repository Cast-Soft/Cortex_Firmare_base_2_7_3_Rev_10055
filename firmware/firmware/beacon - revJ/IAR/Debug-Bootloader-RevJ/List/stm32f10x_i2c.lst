###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     29/Oct/2019  16:43:13 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_i2c.c                        #
#    Command line =  "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_i2c.c" -D BEACON_APP -D      #
#                    USE_STDPERIPH_DRIVER -D STM32F10X_CL -D COOS -D          #
#                    USE_MY_ASSERT -D _DEBUG -D BOOTLOADER -D EE_M24C02 -D    #
#                    TASKS_PROFILE -D BATTERY_CHECK -D CCA_EN_NO -D           #
#                    NEW_BEACON -D USE_TIM4 -D WDT_ENABLE -D OLD_CONFIG -D    #
#                    CIRCULAR_LOG -D BC_HW_REVJ -lcN                          #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\" -o                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\App\" -I "C:\Users\kmak\Documents\Cortex_Git #
#                    \BLKT-01\Source Code\BLKT-01                             #
#                    Beacon\Source\firmware\beacon -                          #
#                    revJ\IAR\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F1 #
#                    0x\" -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Sour #
#                    ce Code\BLKT-01 Beacon\Source\firmware\beacon -          #
#                    revJ\IAR\..\..\common\STM32F10x_StdPeriph_Driver\inc\"   #
#                    -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\kernel\" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\portable\" -I                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\..\common\" -I                            #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\USB-Device-CDC\" -I                #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\" -I "C:\Users\kmak\Documents\Cort #
#                    ex_Git\BLKT-01\Source Code\BLKT-01                       #
#                    Beacon\Source\firmware\beacon - revJ\IAR\" -On           #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\stm32f10x_i2c.lst    #
#    Object file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\stm32f10x_i2c.o       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_StdPeriph_Driver\src\stm32f10x_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_i2c.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the I2C firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_i2c.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup I2C 
     31            * @brief I2C driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup I2C_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup I2C_Private_Defines
     44            * @{
     45            */
     46          
     47          /* I2C SPE mask */
     48          #define CR1_PE_Set              ((uint16_t)0x0001)
     49          #define CR1_PE_Reset            ((uint16_t)0xFFFE)
     50          
     51          /* I2C START mask */
     52          #define CR1_START_Set           ((uint16_t)0x0100)
     53          #define CR1_START_Reset         ((uint16_t)0xFEFF)
     54          
     55          /* I2C STOP mask */
     56          #define CR1_STOP_Set            ((uint16_t)0x0200)
     57          #define CR1_STOP_Reset          ((uint16_t)0xFDFF)
     58          
     59          /* I2C ACK mask */
     60          #define CR1_ACK_Set             ((uint16_t)0x0400)
     61          #define CR1_ACK_Reset           ((uint16_t)0xFBFF)
     62          
     63          /* I2C ENGC mask */
     64          #define CR1_ENGC_Set            ((uint16_t)0x0040)
     65          #define CR1_ENGC_Reset          ((uint16_t)0xFFBF)
     66          
     67          /* I2C SWRST mask */
     68          #define CR1_SWRST_Set           ((uint16_t)0x8000)
     69          #define CR1_SWRST_Reset         ((uint16_t)0x7FFF)
     70          
     71          /* I2C PEC mask */
     72          #define CR1_PEC_Set             ((uint16_t)0x1000)
     73          #define CR1_PEC_Reset           ((uint16_t)0xEFFF)
     74          
     75          /* I2C ENPEC mask */
     76          #define CR1_ENPEC_Set           ((uint16_t)0x0020)
     77          #define CR1_ENPEC_Reset         ((uint16_t)0xFFDF)
     78          
     79          /* I2C ENARP mask */
     80          #define CR1_ENARP_Set           ((uint16_t)0x0010)
     81          #define CR1_ENARP_Reset         ((uint16_t)0xFFEF)
     82          
     83          /* I2C NOSTRETCH mask */
     84          #define CR1_NOSTRETCH_Set       ((uint16_t)0x0080)
     85          #define CR1_NOSTRETCH_Reset     ((uint16_t)0xFF7F)
     86          
     87          /* I2C registers Masks */
     88          #define CR1_CLEAR_Mask          ((uint16_t)0xFBF5)
     89          
     90          /* I2C DMAEN mask */
     91          #define CR2_DMAEN_Set           ((uint16_t)0x0800)
     92          #define CR2_DMAEN_Reset         ((uint16_t)0xF7FF)
     93          
     94          /* I2C LAST mask */
     95          #define CR2_LAST_Set            ((uint16_t)0x1000)
     96          #define CR2_LAST_Reset          ((uint16_t)0xEFFF)
     97          
     98          /* I2C FREQ mask */
     99          #define CR2_FREQ_Reset          ((uint16_t)0xFFC0)
    100          
    101          /* I2C ADD0 mask */
    102          #define OAR1_ADD0_Set           ((uint16_t)0x0001)
    103          #define OAR1_ADD0_Reset         ((uint16_t)0xFFFE)
    104          
    105          /* I2C ENDUAL mask */
    106          #define OAR2_ENDUAL_Set         ((uint16_t)0x0001)
    107          #define OAR2_ENDUAL_Reset       ((uint16_t)0xFFFE)
    108          
    109          /* I2C ADD2 mask */
    110          #define OAR2_ADD2_Reset         ((uint16_t)0xFF01)
    111          
    112          /* I2C F/S mask */
    113          #define CCR_FS_Set              ((uint16_t)0x8000)
    114          
    115          /* I2C CCR mask */
    116          #define CCR_CCR_Set             ((uint16_t)0x0FFF)
    117          
    118          /* I2C FLAG mask */
    119          #define FLAG_Mask               ((uint32_t)0x00FFFFFF)
    120          
    121          /* I2C Interrupt Enable mask */
    122          #define ITEN_Mask               ((uint32_t)0x07000000)
    123          
    124          /**
    125            * @}
    126            */
    127          
    128          /** @defgroup I2C_Private_Macros
    129            * @{
    130            */
    131          
    132          /**
    133            * @}
    134            */
    135          
    136          /** @defgroup I2C_Private_Variables
    137            * @{
    138            */
    139          
    140          /**
    141            * @}
    142            */
    143          
    144          /** @defgroup I2C_Private_FunctionPrototypes
    145            * @{
    146            */
    147          
    148          /**
    149            * @}
    150            */
    151          
    152          /** @defgroup I2C_Private_Functions
    153            * @{
    154            */
    155          
    156          /**
    157            * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
    158            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    159            * @retval None
    160            */
    161          
    162          void I2C_DeInit(I2C_TypeDef *I2Cx) {
    163              /* Check the parameters */
    164              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    165          
    166              if (I2Cx == I2C1) {
    167                  /* Enable I2C1 reset state */
    168                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    169                  /* Release I2C1 from reset state */
    170                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
    171              } else {
    172                  /* Enable I2C2 reset state */
    173                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    174                  /* Release I2C2 from reset state */
    175                  RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
    176              }
    177          }
    178          
    179          /**
    180            * @brief  Initializes the I2Cx peripheral according to the specified 
    181            *   parameters in the I2C_InitStruct.
    182            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    183            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
    184            *   contains the configuration information for the specified I2C peripheral.
    185            * @retval None
    186            */
    187          void I2C_Init(I2C_TypeDef *I2Cx, I2C_InitTypeDef *I2C_InitStruct) {
    188              uint16_t tmpreg = 0, freqrange = 0;
    189              uint16_t result = 0x04;
    190              uint32_t pclk1 = 8000000;
    191              RCC_ClocksTypeDef rcc_clocks;
    192              /* Check the parameters */
    193              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    194              assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
    195              assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
    196              assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
    197              assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    198              assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
    199              assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
    200          
    201              /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    202              /* Get the I2Cx CR2 value */
    203              tmpreg = I2Cx->CR2;
    204              /* Clear frequency FREQ[5:0] bits */
    205              tmpreg &= CR2_FREQ_Reset;
    206              /* Get pclk1 frequency value */
    207              RCC_GetClocksFreq(&rcc_clocks);
    208              pclk1 = rcc_clocks.PCLK1_Frequency;
    209              /* Set frequency bits depending on pclk1 value */
    210              freqrange = (uint16_t)(pclk1 / 1000000);
    211              tmpreg |= freqrange;
    212              /* Write to I2Cx CR2 */
    213              I2Cx->CR2 = tmpreg;
    214          
    215              /*---------------------------- I2Cx CCR Configuration ------------------------*/
    216              /* Disable the selected I2C peripheral to configure TRISE */
    217              I2Cx->CR1 &= CR1_PE_Reset;
    218              /* Reset tmpreg value */
    219              /* Clear F/S, DUTY and CCR[11:0] bits */
    220              tmpreg = 0;
    221          
    222              /* Configure speed in standard mode */
    223              if (I2C_InitStruct->I2C_ClockSpeed <= 100000) {
    224                  /* Standard mode speed calculate */
    225                  result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
    226                  /* Test if CCR value is under 0x4*/
    227                  if (result < 0x04) {
    228                      /* Set minimum allowed value */
    229                      result = 0x04;
    230                  }
    231                  /* Set speed value for standard mode */
    232                  tmpreg |= result;
    233                  /* Set Maximum Rise Time for standard mode */
    234                  I2Cx->TRISE = freqrange + 1;
    235              }
    236              /* Configure speed in fast mode */
    237              else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    238              {
    239                  if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2) {
    240                      /* Fast mode speed calculate: Tlow/Thigh = 2 */
    241                      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
    242                  } else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    243                  {
    244                      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    245                      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
    246                      /* Set DUTY bit */
    247                      result |= I2C_DutyCycle_16_9;
    248                  }
    249          
    250                  /* Test if CCR value is under 0x1*/
    251                  if ((result & CCR_CCR_Set) == 0) {
    252                      /* Set minimum allowed value */
    253                      result |= (uint16_t)0x0001;
    254                  }
    255                  /* Set speed value and set F/S bit for fast mode */
    256                  tmpreg |= (uint16_t)(result | CCR_FS_Set);
    257                  /* Set Maximum Rise Time for fast mode */
    258                  I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);
    259              }
    260          
    261              /* Write to I2Cx CCR */
    262              I2Cx->CCR = tmpreg;
    263              /* Enable the selected I2C peripheral */
    264              I2Cx->CR1 |= CR1_PE_Set;
    265          
    266              /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    267              /* Get the I2Cx CR1 value */
    268              tmpreg = I2Cx->CR1;
    269              /* Clear ACK, SMBTYPE and  SMBUS bits */
    270              tmpreg &= CR1_CLEAR_Mask;
    271              /* Configure I2Cx: mode and acknowledgement */
    272              /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    273              /* Set ACK bit according to I2C_Ack value */
    274              tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
    275              /* Write to I2Cx CR1 */
    276              I2Cx->CR1 = tmpreg;
    277          
    278              /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    279              /* Set I2Cx Own Address1 and acknowledged address */
    280              I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
    281          }
    282          
    283          /**
    284            * @brief  Fills each I2C_InitStruct member with its default value.
    285            * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
    286            * @retval None
    287            */
    288          void I2C_StructInit(I2C_InitTypeDef *I2C_InitStruct) {
    289              /*---------------- Reset I2C init structure parameters values ----------------*/
    290              /* initialize the I2C_ClockSpeed member */
    291              I2C_InitStruct->I2C_ClockSpeed = 5000;
    292              /* Initialize the I2C_Mode member */
    293              I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    294              /* Initialize the I2C_DutyCycle member */
    295              I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
    296              /* Initialize the I2C_OwnAddress1 member */
    297              I2C_InitStruct->I2C_OwnAddress1 = 0;
    298              /* Initialize the I2C_Ack member */
    299              I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
    300              /* Initialize the I2C_AcknowledgedAddress member */
    301              I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    302          }
    303          
    304          /**
    305            * @brief  Enables or disables the specified I2C peripheral.
    306            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    307            * @param  NewState: new state of the I2Cx peripheral. 
    308            *   This parameter can be: ENABLE or DISABLE.
    309            * @retval None
    310            */
    311          void I2C_Cmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    312              /* Check the parameters */
    313              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    314              assert_param(IS_FUNCTIONAL_STATE(NewState));
    315          
    316              if (NewState != DISABLE) {
    317                  /* Enable the selected I2C peripheral */
    318                  I2Cx->CR1 |= CR1_PE_Set;
    319              } else {
    320                  /* Disable the selected I2C peripheral */
    321                  I2Cx->CR1 &= CR1_PE_Reset;
    322              }
    323          }
    324          
    325          /**
    326            * @brief  Enables or disables the specified I2C DMA requests.
    327            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    328            * @param  NewState: new state of the I2C DMA transfer.
    329            *   This parameter can be: ENABLE or DISABLE.
    330            * @retval None
    331            */
    332          void I2C_DMACmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    333              /* Check the parameters */
    334              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    335              assert_param(IS_FUNCTIONAL_STATE(NewState));
    336          
    337              if (NewState != DISABLE) {
    338                  /* Enable the selected I2C DMA requests */
    339                  I2Cx->CR2 |= CR2_DMAEN_Set;
    340              } else {
    341                  /* Disable the selected I2C DMA requests */
    342                  I2Cx->CR2 &= CR2_DMAEN_Reset;
    343              }
    344          }
    345          
    346          /**
    347            * @brief  Specifies if the next DMA transfer will be the last one.
    348            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    349            * @param  NewState: new state of the I2C DMA last transfer.
    350            *   This parameter can be: ENABLE or DISABLE.
    351            * @retval None
    352            */
    353          void I2C_DMALastTransferCmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    354              /* Check the parameters */
    355              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    356              assert_param(IS_FUNCTIONAL_STATE(NewState));
    357          
    358              if (NewState != DISABLE) {
    359                  /* Next DMA transfer is the last transfer */
    360                  I2Cx->CR2 |= CR2_LAST_Set;
    361              } else {
    362                  /* Next DMA transfer is not the last transfer */
    363                  I2Cx->CR2 &= CR2_LAST_Reset;
    364              }
    365          }
    366          
    367          /**
    368            * @brief  Generates I2Cx communication START condition.
    369            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    370            * @param  NewState: new state of the I2C START condition generation.
    371            *   This parameter can be: ENABLE or DISABLE.
    372            * @retval None.
    373            */
    374          void I2C_GenerateSTART(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    375              /* Check the parameters */
    376              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    377              assert_param(IS_FUNCTIONAL_STATE(NewState));
    378          
    379              if (NewState != DISABLE) {
    380                  /* Generate a START condition */
    381                  I2Cx->CR1 |= CR1_START_Set;
    382              } else {
    383                  /* Disable the START condition generation */
    384                  I2Cx->CR1 &= CR1_START_Reset;
    385              }
    386          }
    387          
    388          /**
    389            * @brief  Generates I2Cx communication STOP condition.
    390            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    391            * @param  NewState: new state of the I2C STOP condition generation.
    392            *   This parameter can be: ENABLE or DISABLE.
    393            * @retval None.
    394            */
    395          void I2C_GenerateSTOP(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    396              /* Check the parameters */
    397              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    398              assert_param(IS_FUNCTIONAL_STATE(NewState));
    399          
    400              if (NewState != DISABLE) {
    401                  /* Generate a STOP condition */
    402                  I2Cx->CR1 |= CR1_STOP_Set;
    403              } else {
    404                  /* Disable the STOP condition generation */
    405                  I2Cx->CR1 &= CR1_STOP_Reset;
    406              }
    407          }
    408          
    409          /**
    410            * @brief  Enables or disables the specified I2C acknowledge feature.
    411            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    412            * @param  NewState: new state of the I2C Acknowledgement.
    413            *   This parameter can be: ENABLE or DISABLE.
    414            * @retval None.
    415            */
    416          void I2C_AcknowledgeConfig(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    417              /* Check the parameters */
    418              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    419              assert_param(IS_FUNCTIONAL_STATE(NewState));
    420          
    421              if (NewState != DISABLE) {
    422                  /* Enable the acknowledgement */
    423                  I2Cx->CR1 |= CR1_ACK_Set;
    424              } else {
    425                  /* Disable the acknowledgement */
    426                  I2Cx->CR1 &= CR1_ACK_Reset;
    427              }
    428          }
    429          
    430          /**
    431            * @brief  Configures the specified I2C own address2.
    432            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    433            * @param  Address: specifies the 7bit I2C own address2.
    434            * @retval None.
    435            */
    436          void I2C_OwnAddress2Config(I2C_TypeDef *I2Cx, uint8_t Address) {
    437              uint16_t tmpreg = 0;
    438          
    439              /* Check the parameters */
    440              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    441          
    442              /* Get the old register value */
    443              tmpreg = I2Cx->OAR2;
    444          
    445              /* Reset I2Cx Own address2 bit [7:1] */
    446              tmpreg &= OAR2_ADD2_Reset;
    447          
    448              /* Set I2Cx Own address2 */
    449              tmpreg |= (uint16_t)((uint16_t)Address &(uint16_t)0x00FE);
    450          
    451              /* Store the new register value */
    452              I2Cx->OAR2 = tmpreg;
    453          }
    454          
    455          /**
    456            * @brief  Enables or disables the specified I2C dual addressing mode.
    457            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    458            * @param  NewState: new state of the I2C dual addressing mode.
    459            *   This parameter can be: ENABLE or DISABLE.
    460            * @retval None
    461            */
    462          void I2C_DualAddressCmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    463              /* Check the parameters */
    464              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    465              assert_param(IS_FUNCTIONAL_STATE(NewState));
    466          
    467              if (NewState != DISABLE) {
    468                  /* Enable dual addressing mode */
    469                  I2Cx->OAR2 |= OAR2_ENDUAL_Set;
    470              } else {
    471                  /* Disable dual addressing mode */
    472                  I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
    473              }
    474          }
    475          
    476          /**
    477            * @brief  Enables or disables the specified I2C general call feature.
    478            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    479            * @param  NewState: new state of the I2C General call.
    480            *   This parameter can be: ENABLE or DISABLE.
    481            * @retval None
    482            */
    483          void I2C_GeneralCallCmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    484              /* Check the parameters */
    485              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    486              assert_param(IS_FUNCTIONAL_STATE(NewState));
    487          
    488              if (NewState != DISABLE) {
    489                  /* Enable generall call */
    490                  I2Cx->CR1 |= CR1_ENGC_Set;
    491              } else {
    492                  /* Disable generall call */
    493                  I2Cx->CR1 &= CR1_ENGC_Reset;
    494              }
    495          }
    496          
    497          /**
    498            * @brief  Enables or disables the specified I2C interrupts.
    499            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    500            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
    501            *   This parameter can be any combination of the following values:
    502            *     @arg I2C_IT_BUF: Buffer interrupt mask
    503            *     @arg I2C_IT_EVT: Event interrupt mask
    504            *     @arg I2C_IT_ERR: Error interrupt mask
    505            * @param  NewState: new state of the specified I2C interrupts.
    506            *   This parameter can be: ENABLE or DISABLE.
    507            * @retval None
    508            */
    509          void I2C_ITConfig(I2C_TypeDef *I2Cx, uint16_t I2C_IT, FunctionalState NewState) {
    510              /* Check the parameters */
    511              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    512              assert_param(IS_FUNCTIONAL_STATE(NewState));
    513              assert_param(IS_I2C_CONFIG_IT(I2C_IT));
    514          
    515              if (NewState != DISABLE) {
    516                  /* Enable the selected I2C interrupts */
    517                  I2Cx->CR2 |= I2C_IT;
    518              } else {
    519                  /* Disable the selected I2C interrupts */
    520                  I2Cx->CR2 &= (uint16_t)~I2C_IT;
    521              }
    522          }
    523          
    524          /**
    525            * @brief  Sends a data byte through the I2Cx peripheral.
    526            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    527            * @param  Data: Byte to be transmitted..
    528            * @retval None
    529            */
    530          void I2C_SendData(I2C_TypeDef *I2Cx, uint8_t Data) {
    531              /* Check the parameters */
    532              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    533              /* Write in the DR register the data to be sent */
    534              I2Cx->DR = Data;
    535          }
    536          
    537          /**
    538            * @brief  Returns the most recent received data by the I2Cx peripheral.
    539            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    540            * @retval The value of the received data.
    541            */
    542          uint8_t I2C_ReceiveData(I2C_TypeDef *I2Cx) {
    543              /* Check the parameters */
    544              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    545              /* Return the data in the DR register */
    546              return (uint8_t)I2Cx->DR;
    547          }
    548          
    549          /**
    550            * @brief  Transmits the address byte to select the slave device.
    551            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    552            * @param  Address: specifies the slave address which will be transmitted
    553            * @param  I2C_Direction: specifies whether the I2C device will be a
    554            *   Transmitter or a Receiver. This parameter can be one of the following values
    555            *     @arg I2C_Direction_Transmitter: Transmitter mode
    556            *     @arg I2C_Direction_Receiver: Receiver mode
    557            * @retval None.
    558            */
    559          void I2C_Send7bitAddress(I2C_TypeDef *I2Cx, uint8_t Address, uint8_t I2C_Direction) {
    560              /* Check the parameters */
    561              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    562              assert_param(IS_I2C_DIRECTION(I2C_Direction));
    563              /* Test on the direction to set/reset the read/write bit */
    564              if (I2C_Direction != I2C_Direction_Transmitter) {
    565                  /* Set the address bit0 for read */
    566                  Address |= OAR1_ADD0_Set;
    567              } else {
    568                  /* Reset the address bit0 for write */
    569                  Address &= OAR1_ADD0_Reset;
    570              }
    571              /* Send the address */
    572              I2Cx->DR = Address;
    573          }
    574          
    575          /**
    576            * @brief  Reads the specified I2C register and returns its value.
    577            * @param  I2C_Register: specifies the register to read.
    578            *   This parameter can be one of the following values:
    579            *     @arg I2C_Register_CR1:  CR1 register.
    580            *     @arg I2C_Register_CR2:   CR2 register.
    581            *     @arg I2C_Register_OAR1:  OAR1 register.
    582            *     @arg I2C_Register_OAR2:  OAR2 register.
    583            *     @arg I2C_Register_DR:    DR register.
    584            *     @arg I2C_Register_SR1:   SR1 register.
    585            *     @arg I2C_Register_SR2:   SR2 register.
    586            *     @arg I2C_Register_CCR:   CCR register.
    587            *     @arg I2C_Register_TRISE: TRISE register.
    588            * @retval The value of the read register.
    589            */
    590          uint16_t I2C_ReadRegister(I2C_TypeDef *I2Cx, uint8_t I2C_Register) {
    591              __IO uint32_t tmp = 0;
    592          
    593              /* Check the parameters */
    594              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    595              assert_param(IS_I2C_REGISTER(I2C_Register));
    596          
    597              tmp = (uint32_t)I2Cx;
    598              tmp += I2C_Register;
    599          
    600              /* Return the selected register value */
    601              return (*(__IO uint16_t *)tmp);
    602          }
    603          
    604          /**
    605            * @brief  Enables or disables the specified I2C software reset.
    606            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    607            * @param  NewState: new state of the I2C software reset.
    608            *   This parameter can be: ENABLE or DISABLE.
    609            * @retval None
    610            */
    611          void I2C_SoftwareResetCmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    612              /* Check the parameters */
    613              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    614              assert_param(IS_FUNCTIONAL_STATE(NewState));
    615          
    616              if (NewState != DISABLE) {
    617                  /* Peripheral under reset */
    618                  I2Cx->CR1 |= CR1_SWRST_Set;
    619              } else {
    620                  /* Peripheral not under reset */
    621                  I2Cx->CR1 &= CR1_SWRST_Reset;
    622              }
    623          }
    624          
    625          /**
    626            * @brief  Selects the specified I2C NACK position in master receiver mode.
    627            *         This function is useful in I2C Master Receiver mode when the number
    628            *         of data to be received is equal to 2. In this case, this function 
    629            *         should be called (with parameter I2C_NACKPosition_Next) before data 
    630            *         reception starts,as described in the 2-byte reception procedure 
    631            *         recommended in Reference Manual in Section: Master receiver.                
    632            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    633            * @param  I2C_NACKPosition: specifies the NACK position. 
    634            *   This parameter can be one of the following values:
    635            *     @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
    636            *          received byte.  
    637            *     @arg I2C_NACKPosition_Current: indicates that current byte is the last 
    638            *          received byte.
    639            *            
    640            * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
    641            *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
    642            *          is intended to used in SMBUS mode. 
    643            *            
    644            * @retval None
    645            */
    646          void I2C_NACKPositionConfig(I2C_TypeDef *I2Cx, uint16_t I2C_NACKPosition) {
    647              /* Check the parameters */
    648              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    649              assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
    650          
    651              /* Check the input parameter */
    652              if (I2C_NACKPosition == I2C_NACKPosition_Next) {
    653                  /* Next byte in shift register is the last received byte */
    654                  I2Cx->CR1 |= I2C_NACKPosition_Next;
    655              } else {
    656                  /* Current byte in shift register is the last received byte */
    657                  I2Cx->CR1 &= I2C_NACKPosition_Current;
    658              }
    659          }
    660          
    661          /**
    662            * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
    663            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    664            * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
    665            *   This parameter can be one of the following values:
    666            *     @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
    667            *     @arg I2C_SMBusAlert_High: SMBAlert pin driven high
    668            * @retval None
    669            */
    670          void I2C_SMBusAlertConfig(I2C_TypeDef *I2Cx, uint16_t I2C_SMBusAlert) {
    671              /* Check the parameters */
    672              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    673              assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    674          
    675              if (I2C_SMBusAlert == I2C_SMBusAlert_Low) {
    676                  /* Drive the SMBusAlert pin Low */
    677                  I2Cx->CR1 |= I2C_SMBusAlert_Low;
    678              } else {
    679                  /* Drive the SMBusAlert pin High  */
    680                  I2Cx->CR1 &= I2C_SMBusAlert_High;
    681              }
    682          }
    683          
    684          /**
    685            * @brief  Enables or disables the specified I2C PEC transfer.
    686            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    687            * @param  NewState: new state of the I2C PEC transmission.
    688            *   This parameter can be: ENABLE or DISABLE.
    689            * @retval None
    690            */
    691          void I2C_TransmitPEC(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    692              /* Check the parameters */
    693              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    694              assert_param(IS_FUNCTIONAL_STATE(NewState));
    695          
    696              if (NewState != DISABLE) {
    697                  /* Enable the selected I2C PEC transmission */
    698                  I2Cx->CR1 |= CR1_PEC_Set;
    699              } else {
    700                  /* Disable the selected I2C PEC transmission */
    701                  I2Cx->CR1 &= CR1_PEC_Reset;
    702              }
    703          }
    704          
    705          /**
    706            * @brief  Selects the specified I2C PEC position.
    707            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    708            * @param  I2C_PECPosition: specifies the PEC position. 
    709            *   This parameter can be one of the following values:
    710            *     @arg I2C_PECPosition_Next: indicates that the next byte is PEC
    711            *     @arg I2C_PECPosition_Current: indicates that current byte is PEC
    712            *       
    713            * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
    714            *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
    715            *          is intended to used in I2C mode.
    716            *               
    717            * @retval None
    718            */
    719          void I2C_PECPositionConfig(I2C_TypeDef *I2Cx, uint16_t I2C_PECPosition) {
    720              /* Check the parameters */
    721              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    722              assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    723          
    724              if (I2C_PECPosition == I2C_PECPosition_Next) {
    725                  /* Next byte in shift register is PEC */
    726                  I2Cx->CR1 |= I2C_PECPosition_Next;
    727              } else {
    728                  /* Current byte in shift register is PEC */
    729                  I2Cx->CR1 &= I2C_PECPosition_Current;
    730              }
    731          }
    732          
    733          /**
    734            * @brief  Enables or disables the PEC value calculation of the transferred bytes.
    735            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    736            * @param  NewState: new state of the I2Cx PEC value calculation.
    737            *   This parameter can be: ENABLE or DISABLE.
    738            * @retval None
    739            */
    740          void I2C_CalculatePEC(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    741              /* Check the parameters */
    742              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    743              assert_param(IS_FUNCTIONAL_STATE(NewState));
    744          
    745              if (NewState != DISABLE) {
    746                  /* Enable the selected I2C PEC calculation */
    747                  I2Cx->CR1 |= CR1_ENPEC_Set;
    748              } else {
    749                  /* Disable the selected I2C PEC calculation */
    750                  I2Cx->CR1 &= CR1_ENPEC_Reset;
    751              }
    752          }
    753          
    754          /**
    755            * @brief  Returns the PEC value for the specified I2C.
    756            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    757            * @retval The PEC value.
    758            */
    759          uint8_t I2C_GetPEC(I2C_TypeDef *I2Cx) {
    760              /* Check the parameters */
    761              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    762              /* Return the selected I2C PEC value */
    763              return ((I2Cx->SR2) >> 8);
    764          }
    765          
    766          /**
    767            * @brief  Enables or disables the specified I2C ARP.
    768            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    769            * @param  NewState: new state of the I2Cx ARP. 
    770            *   This parameter can be: ENABLE or DISABLE.
    771            * @retval None
    772            */
    773          void I2C_ARPCmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    774              /* Check the parameters */
    775              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    776              assert_param(IS_FUNCTIONAL_STATE(NewState));
    777          
    778              if (NewState != DISABLE) {
    779                  /* Enable the selected I2C ARP */
    780                  I2Cx->CR1 |= CR1_ENARP_Set;
    781              } else {
    782                  /* Disable the selected I2C ARP */
    783                  I2Cx->CR1 &= CR1_ENARP_Reset;
    784              }
    785          }
    786          
    787          /**
    788            * @brief  Enables or disables the specified I2C Clock stretching.
    789            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    790            * @param  NewState: new state of the I2Cx Clock stretching.
    791            *   This parameter can be: ENABLE or DISABLE.
    792            * @retval None
    793            */
    794          void I2C_StretchClockCmd(I2C_TypeDef *I2Cx, FunctionalState NewState) {
    795              /* Check the parameters */
    796              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    797              assert_param(IS_FUNCTIONAL_STATE(NewState));
    798          
    799              if (NewState == DISABLE) {
    800                  /* Enable the selected I2C Clock stretching */
    801                  I2Cx->CR1 |= CR1_NOSTRETCH_Set;
    802              } else {
    803                  /* Disable the selected I2C Clock stretching */
    804                  I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
    805              }
    806          }
    807          
    808          /**
    809            * @brief  Selects the specified I2C fast mode duty cycle.
    810            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    811            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    812            *   This parameter can be one of the following values:
    813            *     @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    814            *     @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    815            * @retval None
    816            */
    817          void I2C_FastModeDutyCycleConfig(I2C_TypeDef *I2Cx, uint16_t I2C_DutyCycle) {
    818              /* Check the parameters */
    819              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    820              assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    821          
    822              if (I2C_DutyCycle != I2C_DutyCycle_16_9) {
    823                  /* I2C fast mode Tlow/Thigh=2 */
    824                  I2Cx->CCR &= I2C_DutyCycle_2;
    825              } else {
    826                  /* I2C fast mode Tlow/Thigh=16/9 */
    827                  I2Cx->CCR |= I2C_DutyCycle_16_9;
    828              }
    829          }
    830          
    831          /**
    832           * @brief
    833           ****************************************************************************************
    834           *
    835           *                         I2C State Monitoring Functions
    836           *                       
    837           ****************************************************************************************   
    838           * This I2C driver provides three different ways for I2C state monitoring
    839           *  depending on the application requirements and constraints:
    840           *        
    841           *  
    842           * 1) Basic state monitoring:
    843           *    Using I2C_CheckEvent() function:
    844           *    It compares the status registers (SR1 and SR2) content to a given event
    845           *    (can be the combination of one or more flags).
    846           *    It returns SUCCESS if the current status includes the given flags 
    847           *    and returns ERROR if one or more flags are missing in the current status.
    848           *    - When to use:
    849           *      - This function is suitable for most applications as well as for startup 
    850           *      activity since the events are fully described in the product reference manual 
    851           *      (RM0008).
    852           *      - It is also suitable for users who need to define their own events.
    853           *    - Limitations:
    854           *      - If an error occurs (ie. error flags are set besides to the monitored flags),
    855           *        the I2C_CheckEvent() function may return SUCCESS despite the communication
    856           *        hold or corrupted real state. 
    857           *        In this case, it is advised to use error interrupts to monitor the error
    858           *        events and handle them in the interrupt IRQ handler.
    859           *        
    860           *        @note 
    861           *        For error management, it is advised to use the following functions:
    862           *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    863           *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
    864           *            Where x is the peripheral instance (I2C1, I2C2 ...)
    865           *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler() 
    866           *            in order to determine which error occured.
    867           *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
    868           *            and/or I2C_GenerateStop() in order to clear the error flag and source,
    869           *            and return to correct communication status.
    870           *            
    871           *
    872           *  2) Advanced state monitoring:
    873           *     Using the function I2C_GetLastEvent() which returns the image of both status 
    874           *     registers in a single word (uint32_t) (Status Register 2 value is shifted left 
    875           *     by 16 bits and concatenated to Status Register 1).
    876           *     - When to use:
    877           *       - This function is suitable for the same applications above but it allows to
    878           *         overcome the mentioned limitation of I2C_GetFlagStatus() function.
    879           *         The returned value could be compared to events already defined in the 
    880           *         library (stm32f10x_i2c.h) or to custom values defined by user.
    881           *       - This function is suitable when multiple flags are monitored at the same time.
    882           *       - At the opposite of I2C_CheckEvent() function, this function allows user to
    883           *         choose when an event is accepted (when all events flags are set and no 
    884           *         other flags are set or just when the needed flags are set like 
    885           *         I2C_CheckEvent() function).
    886           *     - Limitations:
    887           *       - User may need to define his own events.
    888           *       - Same remark concerning the error management is applicable for this 
    889           *         function if user decides to check only regular communication flags (and 
    890           *         ignores error flags).
    891           *     
    892           *
    893           *  3) Flag-based state monitoring:
    894           *     Using the function I2C_GetFlagStatus() which simply returns the status of 
    895           *     one single flag (ie. I2C_FLAG_RXNE ...). 
    896           *     - When to use:
    897           *        - This function could be used for specific applications or in debug phase.
    898           *        - It is suitable when only one flag checking is needed (most I2C events 
    899           *          are monitored through multiple flags).
    900           *     - Limitations: 
    901           *        - When calling this function, the Status register is accessed. Some flags are
    902           *          cleared when the status register is accessed. So checking the status
    903           *          of one Flag, may clear other ones.
    904           *        - Function may need to be called twice or more in order to monitor one 
    905           *          single event.
    906           *
    907           *  For detailed description of Events, please refer to section I2C_Events in 
    908           *  stm32f10x_i2c.h file.
    909           *  
    910           */
    911          
    912          /**
    913           * 
    914           *  1) Basic state monitoring
    915           *******************************************************************************
    916           */
    917          
    918          /**
    919            * @brief  Checks whether the last I2Cx Event is equal to the one passed
    920            *   as parameter.
    921            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    922            * @param  I2C_EVENT: specifies the event to be checked. 
    923            *   This parameter can be one of the following values:
    924            *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
    925            *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
    926            *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1
    927            *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1
    928            *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
    929            *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
    930            *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2
    931            *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
    932            *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
    933            *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3
    934            *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
    935            *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
    936            *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
    937            *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
    938            *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     
    939            *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
    940            *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
    941            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
    942            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
    943            *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
    944            *     
    945            * @note: For detailed description of Events, please refer to section 
    946            *    I2C_Events in stm32f10x_i2c.h file.
    947            *    
    948            * @retval An ErrorStatus enumeration value:
    949            * - SUCCESS: Last event is equal to the I2C_EVENT
    950            * - ERROR: Last event is different from the I2C_EVENT
    951            */
    952          ErrorStatus I2C_CheckEvent(I2C_TypeDef *I2Cx, uint32_t I2C_EVENT) {
    953              uint32_t lastevent = 0;
    954              uint32_t flag1 = 0, flag2 = 0;
    955              ErrorStatus status = ERROR;
    956          
    957              /* Check the parameters */
    958              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    959              assert_param(IS_I2C_EVENT(I2C_EVENT));
    960          
    961              /* Read the I2Cx status register */
    962              flag1 = I2Cx->SR1;
    963              flag2 = I2Cx->SR2;
    964              flag2 = flag2 << 16;
    965          
    966              
    967              /* Get the last event value from I2C status register */
    968              lastevent = (flag1 | flag2) & FLAG_Mask;
    969              
    970          
    971              /* Check whether the last event contains the I2C_EVENT */
    972              if ((lastevent & I2C_EVENT) == I2C_EVENT) {
    973                  /* SUCCESS: last event is equal to I2C_EVENT */
    974                  status = SUCCESS;
    975              } else {
    976                  /* ERROR: last event is different from I2C_EVENT */
    977                  status = ERROR;
    978              }
    979              /* Return status */
    980              return status;
    981          }
    982          
    983          /**
    984           * 
    985           *  2) Advanced state monitoring
    986           *******************************************************************************
    987           */
    988          
    989          /**
    990            * @brief  Returns the last I2Cx Event.
    991            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    992            *     
    993            * @note: For detailed description of Events, please refer to section 
    994            *    I2C_Events in stm32f10x_i2c.h file.
    995            *    
    996            * @retval The last event
    997            */
    998          uint32_t I2C_GetLastEvent(I2C_TypeDef *I2Cx) {
    999              uint32_t lastevent = 0;
   1000              uint32_t flag1 = 0, flag2 = 0;
   1001          
   1002              /* Check the parameters */
   1003              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1004          
   1005              /* Read the I2Cx status register */
   1006              flag1 = I2Cx->SR1;
   1007              flag2 = I2Cx->SR2;
   1008              flag2 = flag2 << 16;
   1009          
   1010              /* Get the last event value from I2C status register */
   1011              lastevent = (flag1 | flag2) & FLAG_Mask;
   1012          
   1013              /* Return status */
   1014              return lastevent;
   1015          }
   1016          
   1017          /**
   1018           * 
   1019           *  3) Flag-based state monitoring
   1020           *******************************************************************************
   1021           */
   1022          
   1023          /**
   1024            * @brief  Checks whether the specified I2C flag is set or not.
   1025            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1026            * @param  I2C_FLAG: specifies the flag to check. 
   1027            *   This parameter can be one of the following values:
   1028            *     @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1029            *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1030            *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1031            *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1032            *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1033            *     @arg I2C_FLAG_BUSY: Bus busy flag
   1034            *     @arg I2C_FLAG_MSL: Master/Slave flag
   1035            *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1036            *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1037            *     @arg I2C_FLAG_PECERR: PEC error in reception flag
   1038            *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1039            *     @arg I2C_FLAG_AF: Acknowledge failure flag
   1040            *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1041            *     @arg I2C_FLAG_BERR: Bus error flag
   1042            *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1043            *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1044            *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1045            *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1046            *     @arg I2C_FLAG_BTF: Byte transfer finished flag
   1047            *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1048            *   Address matched flag (Slave mode)"ENDA"
   1049            *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1050            * @retval The new state of I2C_FLAG (SET or RESET).
   1051            */
   1052          FlagStatus I2C_GetFlagStatus(I2C_TypeDef *I2Cx, uint32_t I2C_FLAG) {
   1053              FlagStatus bitstatus = RESET;
   1054              __IO uint32_t i2creg = 0, i2cxbase = 0;
   1055          
   1056              /* Check the parameters */
   1057              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1058              assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1059          
   1060              /* Get the I2Cx peripheral base address */
   1061              i2cxbase = (uint32_t)I2Cx;
   1062          
   1063              /* Read flag register index */
   1064              i2creg = I2C_FLAG >> 28;
   1065          
   1066              /* Get bit[23:0] of the flag */
   1067              I2C_FLAG &= FLAG_Mask;
   1068          
   1069              if (i2creg != 0) {
   1070                  /* Get the I2Cx SR1 register address */
   1071                  i2cxbase += 0x14;
   1072              } else {
   1073                  /* Flag in I2Cx SR2 Register */
   1074                  I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   1075                  /* Get the I2Cx SR2 register address */
   1076                  i2cxbase += 0x18;
   1077              }
   1078          
   1079              if (((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET) {
   1080                  /* I2C_FLAG is set */
   1081                  bitstatus = SET;
   1082              } else {
   1083                  /* I2C_FLAG is reset */
   1084                  bitstatus = RESET;
   1085              }
   1086          
   1087              /* Return the I2C_FLAG status */
   1088              return bitstatus;
   1089          }
   1090          
   1091          /**
   1092            * @brief  Clears the I2Cx's pending flags.
   1093            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1094            * @param  I2C_FLAG: specifies the flag to clear. 
   1095            *   This parameter can be any combination of the following values:
   1096            *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1097            *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1098            *     @arg I2C_FLAG_PECERR: PEC error in reception flag
   1099            *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1100            *     @arg I2C_FLAG_AF: Acknowledge failure flag
   1101            *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1102            *     @arg I2C_FLAG_BERR: Bus error flag
   1103            *   
   1104            * @note
   1105            *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
   1106            *     to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1107            *     to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1108            *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1109            *     operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1110            *     second byte of the address in DR register.
   1111            *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1112            *     operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1113            *     read/write to I2C_DR register (I2C_SendData()).
   1114            *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
   1115            *     I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1116            *     I2C_SR2 register ((void)(I2Cx->SR2)).
   1117            *   - SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1118            *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1119            *     register  (I2C_SendData()).
   1120            * @retval None
   1121            */
   1122          void I2C_ClearFlag(I2C_TypeDef *I2Cx, uint32_t I2C_FLAG) {
   1123              uint32_t flagpos = 0;
   1124              /* Check the parameters */
   1125              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1126              assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1127              /* Get the I2C flag position */
   1128              flagpos = I2C_FLAG & FLAG_Mask;
   1129              /* Clear the selected I2C flag */
   1130              I2Cx->SR1 = (uint16_t)~flagpos;
   1131          }
   1132          
   1133          /**
   1134            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1135            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1136            * @param  I2C_IT: specifies the interrupt source to check. 
   1137            *   This parameter can be one of the following values:
   1138            *     @arg I2C_IT_SMBALERT: SMBus Alert flag
   1139            *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1140            *     @arg I2C_IT_PECERR: PEC error in reception flag
   1141            *     @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1142            *     @arg I2C_IT_AF: Acknowledge failure flag
   1143            *     @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1144            *     @arg I2C_IT_BERR: Bus error flag
   1145            *     @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1146            *     @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1147            *     @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1148            *     @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1149            *     @arg I2C_IT_BTF: Byte transfer finished flag
   1150            *     @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
   1151            *                       Address matched flag (Slave mode)"ENDAD"
   1152            *     @arg I2C_IT_SB: Start bit flag (Master mode)
   1153            * @retval The new state of I2C_IT (SET or RESET).
   1154            */
   1155          ITStatus I2C_GetITStatus(I2C_TypeDef *I2Cx, uint32_t I2C_IT) {
   1156              ITStatus bitstatus = RESET;
   1157              uint32_t enablestatus = 0;
   1158          
   1159              /* Check the parameters */
   1160              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1161              assert_param(IS_I2C_GET_IT(I2C_IT));
   1162          
   1163              /* Check if the interrupt source is enabled or not */
   1164              enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2));
   1165          
   1166              /* Get bit[23:0] of the flag */
   1167              I2C_IT &= FLAG_Mask;
   1168          
   1169              /* Check the status of the specified I2C flag */
   1170              if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus) {
   1171                  /* I2C_IT is set */
   1172                  bitstatus = SET;
   1173              } else {
   1174                  /* I2C_IT is reset */
   1175                  bitstatus = RESET;
   1176              }
   1177              /* Return the I2C_IT status */
   1178              return bitstatus;
   1179          }
   1180          
   1181          /**
   1182            * @brief  Clears the I2Cxs interrupt pending bits.
   1183            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1184            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
   1185            *   This parameter can be any combination of the following values:
   1186            *     @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1187            *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1188            *     @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1189            *     @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1190            *     @arg I2C_IT_AF: Acknowledge failure interrupt
   1191            *     @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1192            *     @arg I2C_IT_BERR: Bus error interrupt
   1193            *   
   1194            * @note
   1195            *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
   1196            *     to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1197            *     I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1198            *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1199            *     operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
   1200            *     byte of the address in I2C_DR register.
   1201            *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1202            *     operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
   1203            *     read/write to I2C_DR register (I2C_SendData()).
   1204            *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
   1205            *     I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
   1206            *     I2C_SR2 register ((void)(I2Cx->SR2)).
   1207            *   - SB (Start Bit) is cleared by software sequence: a read operation to 
   1208            *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1209            *     I2C_DR register (I2C_SendData()).
   1210            * @retval None
   1211            */
   1212          void I2C_ClearITPendingBit(I2C_TypeDef *I2Cx, uint32_t I2C_IT) {
   1213              uint32_t flagpos = 0;
   1214              /* Check the parameters */
   1215              assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1216              assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1217              /* Get the I2C flag position */
   1218              flagpos = I2C_IT & FLAG_Mask;
   1219              /* Clear the selected I2C flag */
   1220              I2Cx->SR1 = (uint16_t)~flagpos;
   1221          }
   1222          
   1223          /**
   1224            * @}
   1225            */
   1226          
   1227          /**
   1228            * @}
   1229            */
   1230          
   1231          /**
   1232            * @}
   1233            */
   1234          
   1235          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  I2C_ARPCmd
        0  I2C_AcknowledgeConfig
        0  I2C_CalculatePEC
       12  I2C_CheckEvent
        0  I2C_ClearFlag
        0  I2C_ClearITPendingBit
        0  I2C_Cmd
        0  I2C_DMACmd
        0  I2C_DMALastTransferCmd
        8  I2C_DeInit
              8 -> RCC_APB1PeriphResetCmd
        0  I2C_DualAddressCmd
        0  I2C_FastModeDutyCycleConfig
        0  I2C_GeneralCallCmd
        0  I2C_GenerateSTART
        0  I2C_GenerateSTOP
        8  I2C_GetFlagStatus
        4  I2C_GetITStatus
        4  I2C_GetLastEvent
        0  I2C_GetPEC
        0  I2C_ITConfig
       48  I2C_Init
             48 -> RCC_GetClocksFreq
        0  I2C_NACKPositionConfig
        0  I2C_OwnAddress2Config
        0  I2C_PECPositionConfig
        4  I2C_ReadRegister
        0  I2C_ReceiveData
        0  I2C_SMBusAlertConfig
        0  I2C_Send7bitAddress
        0  I2C_SendData
        0  I2C_SoftwareResetCmd
        0  I2C_StretchClockCmd
        0  I2C_StructInit
        0  I2C_TransmitPEC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
      28  I2C_ARPCmd
      28  I2C_AcknowledgeConfig
      28  I2C_CalculatePEC
      56  I2C_CheckEvent
      14  I2C_ClearFlag
      14  I2C_ClearITPendingBit
      28  I2C_Cmd
      28  I2C_DMACmd
      28  I2C_DMALastTransferCmd
      54  I2C_DeInit
      28  I2C_DualAddressCmd
      30  I2C_FastModeDutyCycleConfig
      28  I2C_GeneralCallCmd
      28  I2C_GenerateSTART
      28  I2C_GenerateSTOP
      70  I2C_GetFlagStatus
      50  I2C_GetITStatus
      34  I2C_GetLastEvent
      10  I2C_GetPEC
      22  I2C_ITConfig
     242  I2C_Init
      30  I2C_NACKPositionConfig
      24  I2C_OwnAddress2Config
      30  I2C_PECPositionConfig
      26  I2C_ReadRegister
       6  I2C_ReceiveData
      30  I2C_SMBusAlertConfig
      22  I2C_Send7bitAddress
       6  I2C_SendData
      26  I2C_SoftwareResetCmd
      28  I2C_StretchClockCmd
      32  I2C_StructInit
      28  I2C_TransmitPEC

 
 1 180 bytes in section .text
 
 1 180 bytes of CODE memory

Errors: none
Warnings: none
