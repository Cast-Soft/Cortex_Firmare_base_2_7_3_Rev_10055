###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     29/Oct/2019  16:43:14 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_rcc.c                        #
#    Command line =  "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_Std #
#                    Periph_Driver\src\stm32f10x_rcc.c" -D BEACON_APP -D      #
#                    USE_STDPERIPH_DRIVER -D STM32F10X_CL -D COOS -D          #
#                    USE_MY_ASSERT -D _DEBUG -D BOOTLOADER -D EE_M24C02 -D    #
#                    TASKS_PROFILE -D BATTERY_CHECK -D CCA_EN_NO -D           #
#                    NEW_BEACON -D USE_TIM4 -D WDT_ENABLE -D OLD_CONFIG -D    #
#                    CIRCULAR_LOG -D BC_HW_REVJ -lcN                          #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\" -o                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\" --no_cse            #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\App\" -I "C:\Users\kmak\Documents\Cortex_Git #
#                    \BLKT-01\Source Code\BLKT-01                             #
#                    Beacon\Source\firmware\beacon -                          #
#                    revJ\IAR\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F1 #
#                    0x\" -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Sour #
#                    ce Code\BLKT-01 Beacon\Source\firmware\beacon -          #
#                    revJ\IAR\..\..\common\STM32F10x_StdPeriph_Driver\inc\"   #
#                    -I "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\kernel\" -I                   #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\CoOS\portable\" -I                 #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\..\common\" -I                            #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\USB-Device-CDC\" -I                #
#                    "C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source       #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\..\..\common\" -I "C:\Users\kmak\Documents\Cort #
#                    ex_Git\BLKT-01\Source Code\BLKT-01                       #
#                    Beacon\Source\firmware\beacon - revJ\IAR\" -On           #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\List\stm32f10x_rcc.lst    #
#    Object file  =  C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source        #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    revJ\IAR\Debug-Bootloader-RevJ\Obj\stm32f10x_rcc.o       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\kmak\Documents\Cortex_Git\BLKT-01\Source Code\BLKT-01 Beacon\Source\firmware\common\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_rcc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the RCC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_rcc.h"
     24          
     25          /** @addtogroup STM32F10x_StdPeriph_Driver
     26            * @{
     27            */
     28          
     29          /** @defgroup RCC 
     30            * @brief RCC driver modules
     31            * @{
     32            */
     33          
     34          /** @defgroup RCC_Private_TypesDefinitions
     35            * @{
     36            */
     37          
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup RCC_Private_Defines
     43            * @{
     44            */
     45          
     46          /* ------------ RCC registers bit address in the alias region ----------- */
     47          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     48          
     49          /* --- CR Register ---*/
     50          
     51          /* Alias word address of HSION bit */
     52          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     53          #define HSION_BitNumber           0x00
     54          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     55          
     56          /* Alias word address of PLLON bit */
     57          #define PLLON_BitNumber           0x18
     58          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     59          
     60          #ifdef STM32F10X_CL
     61          /* Alias word address of PLL2ON bit */
     62          #define PLL2ON_BitNumber          0x1A
     63          #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))
     64          
     65          /* Alias word address of PLL3ON bit */
     66          #define PLL3ON_BitNumber          0x1C
     67          #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))
     68          
     69          #endif /* STM32F10X_CL */
     70          
     71          /* Alias word address of CSSON bit */
     72          #define CSSON_BitNumber           0x13
     73          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     74          
     75          /* --- CFGR Register ---*/
     76          
     77          /* Alias word address of USBPRE bit */
     78          #define CFGR_OFFSET               (RCC_OFFSET + 0x04)
     79          
     80          #ifndef STM32F10X_CL
     81          #define USBPRE_BitNumber          0x16
     82          #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
     83          #else
     84          #define OTGFSPRE_BitNumber        0x16
     85          #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))
     86          
     87          #endif /* STM32F10X_CL */
     88          
     89          /* --- BDCR Register ---*/
     90          
     91          /* Alias word address of RTCEN bit */
     92          #define BDCR_OFFSET               (RCC_OFFSET + 0x20)
     93          #define RTCEN_BitNumber           0x0F
     94          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
     95          
     96          /* Alias word address of BDRST bit */
     97          #define BDRST_BitNumber           0x10
     98          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
     99          
    100          /* --- CSR Register ---*/
    101          
    102          /* Alias word address of LSION bit */
    103          #define CSR_OFFSET                (RCC_OFFSET + 0x24)
    104          #define LSION_BitNumber           0x00
    105          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    106          
    107          #ifdef STM32F10X_CL
    108          /* --- CFGR2 Register ---*/
    109          
    110          /* Alias word address of I2S2SRC bit */
    111          #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)
    112          #define I2S2SRC_BitNumber         0x11
    113          #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))
    114          
    115          /* Alias word address of I2S3SRC bit */
    116          #define I2S3SRC_BitNumber         0x12
    117          #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))
    118          
    119          #endif /* STM32F10X_CL */
    120          
    121          /* ---------------------- RCC registers bit mask ------------------------ */
    122          
    123          /* CR register bit mask */
    124          #define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)
    125          #define CR_HSEBYP_Set             ((uint32_t)0x00040000)
    126          #define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)
    127          #define CR_HSEON_Set              ((uint32_t)0x00010000)
    128          #define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)
    129          
    130          /* CFGR register bit mask */
    131          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
    132          #define CFGR_PLL_Mask            ((uint32_t)0xFFC2FFFF)
    133          #else
    134          #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)
    135          
    136          #endif /* STM32F10X_CL */
    137          
    138          #define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)
    139          #define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)
    140          #define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)
    141          #define CFGR_SWS_Mask             ((uint32_t)0x0000000C)
    142          #define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)
    143          #define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)
    144          #define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)
    145          #define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)
    146          #define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)
    147          #define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)
    148          #define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)
    149          #define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)
    150          #define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)
    151          
    152          /* CSR register bit mask */
    153          #define CSR_RMVF_Set              ((uint32_t)0x01000000)
    154          
    155          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
    156          /* CFGR2 register bit mask */
    157          #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)
    158          #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)
    159          
    160          #endif
    161          #ifdef STM32F10X_CL
    162          #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)
    163          #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)
    164          #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)
    165          
    166          #endif /* STM32F10X_CL */
    167          
    168          /* RCC Flag Mask */
    169          #define FLAG_Mask                 ((uint8_t)0x1F)
    170          
    171          /* CIR register byte 2 (Bits[15:8]) base address */
    172          #define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
    173          
    174          /* CIR register byte 3 (Bits[23:16]) base address */
    175          #define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
    176          
    177          /* CFGR register byte 4 (Bits[31:24]) base address */
    178          #define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)
    179          
    180          /* BDCR register base address */
    181          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    182          
    183          /**
    184            * @}
    185            */
    186          
    187          /** @defgroup RCC_Private_Macros
    188            * @{
    189            */
    190          
    191          /**
    192            * @}
    193            */
    194          
    195          /** @defgroup RCC_Private_Variables
    196            * @{
    197            */
    198          
    199          static __I uint8_t APBAHBPrescTable[16] =
    200              {
    201                  0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
    202              };
    203          
    204          static __I uint8_t ADCPrescTable[4] =
    205              {
    206                  2, 4, 6, 8
    207              };
    208          
    209          /**
    210            * @}
    211            */
    212          
    213          /** @defgroup RCC_Private_FunctionPrototypes
    214            * @{
    215            */
    216          
    217          /**
    218            * @}
    219            */
    220          
    221          /** @defgroup RCC_Private_Functions
    222            * @{
    223            */
    224          
    225          /**
    226            * @brief  Resets the RCC clock configuration to the default reset state.
    227            * @param  None
    228            * @retval None
    229            */
    230          void RCC_DeInit(void) {
    231              /* Set HSION bit */
    232              RCC->CR |= (uint32_t)0x00000001;
    233          
    234          /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
    235          #ifndef STM32F10X_CL
    236          
    237              RCC->CFGR &= (uint32_t)0xF8FF0000;
    238          #else
    239          
    240              RCC->CFGR &= (uint32_t)0xF0FF0000;
    241          
    242          #endif /* STM32F10X_CL */
    243          
    244              /* Reset HSEON, CSSON and PLLON bits */
    245          
    246              RCC->CR &= (uint32_t)0xFEF6FFFF;
    247          
    248              /* Reset HSEBYP bit */
    249              RCC->CR &= (uint32_t)0xFFFBFFFF;
    250          
    251              /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
    252              RCC->CFGR &= (uint32_t)0xFF80FFFF;
    253          
    254          #ifdef STM32F10X_CL
    255              /* Reset PLL2ON and PLL3ON bits */
    256          
    257              RCC->CR &= (uint32_t)0xEBFFFFFF;
    258          
    259              /* Disable all interrupts and clear pending bits  */
    260              RCC->CIR = 0x00FF0000;
    261          
    262              /* Reset CFGR2 register */
    263              RCC->CFGR2 = 0x00000000;
    264          #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    265              /* Disable all interrupts and clear pending bits  */
    266          
    267              RCC->CIR = 0x009F0000;
    268          
    269              /* Reset CFGR2 register */
    270              RCC->CFGR2 = 0x00000000;
    271          #else
    272              /* Disable all interrupts and clear pending bits  */
    273          
    274              RCC->CIR = 0x009F0000;
    275          
    276          #endif /* STM32F10X_CL */
    277          
    278          }
    279          
    280          /**
    281            * @brief  Configures the External High Speed oscillator (HSE).
    282            * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.
    283            * @param  RCC_HSE: specifies the new state of the HSE.
    284            *   This parameter can be one of the following values:
    285            *     @arg RCC_HSE_OFF: HSE oscillator OFF
    286            *     @arg RCC_HSE_ON: HSE oscillator ON
    287            *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    288            * @retval None
    289            */
    290          void RCC_HSEConfig(uint32_t RCC_HSE) {
    291              /* Check the parameters */
    292              assert_param(IS_RCC_HSE(RCC_HSE));
    293              /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    294              /* Reset HSEON bit */
    295              RCC->CR &= CR_HSEON_Reset;
    296              /* Reset HSEBYP bit */
    297              RCC->CR &= CR_HSEBYP_Reset;
    298              /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
    299              switch (RCC_HSE) {
    300                  case RCC_HSE_ON:
    301                      /* Set HSEON bit */
    302                      RCC->CR |= CR_HSEON_Set;
    303                      break;
    304                  case RCC_HSE_Bypass:
    305                      /* Set HSEBYP and HSEON bits */
    306                      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
    307                      break;
    308          
    309                  default:
    310                      break;
    311              }
    312          }
    313          
    314          /**
    315            * @brief  Waits for HSE start-up.
    316            * @param  None
    317            * @retval An ErrorStatus enumuration value:
    318            * - SUCCESS: HSE oscillator is stable and ready to use
    319            * - ERROR: HSE oscillator not yet ready
    320            */
    321          ErrorStatus RCC_WaitForHSEStartUp(void) {
    322              __IO uint32_t StartUpCounter = 0;
    323              ErrorStatus status = ERROR;
    324              FlagStatus HSEStatus = RESET;
    325          
    326              /* Wait till HSE is ready and if Time out is reached exit */
    327              do {
    328                  HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    329                  StartUpCounter++;
    330              } while ((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
    331          
    332              if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET) {
    333                  status = SUCCESS;
    334              } else {
    335                  status = ERROR;
    336              }
    337              return (status);
    338          }
    339          
    340          /**
    341            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    342            * @param  HSICalibrationValue: specifies the calibration trimming value.
    343            *   This parameter must be a number between 0 and 0x1F.
    344            * @retval None
    345            */
    346          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue) {
    347              uint32_t tmpreg = 0;
    348              /* Check the parameters */
    349              assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
    350              tmpreg = RCC->CR;
    351              /* Clear HSITRIM[4:0] bits */
    352              tmpreg &= CR_HSITRIM_Mask;
    353              /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    354              tmpreg |= (uint32_t)HSICalibrationValue << 3;
    355              /* Store the new value */
    356              RCC->CR = tmpreg;
    357          }
    358          
    359          /**
    360            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    361            * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
    362            * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
    363            * @retval None
    364            */
    365          void RCC_HSICmd(FunctionalState NewState) {
    366              /* Check the parameters */
    367              assert_param(IS_FUNCTIONAL_STATE(NewState));
    368              *(__IO uint32_t *)CR_HSION_BB = (uint32_t)NewState;
    369          }
    370          
    371          /**
    372            * @brief  Configures the PLL clock source and multiplication factor.
    373            * @note   This function must be used only when the PLL is disabled.
    374            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    375            *   For @b STM32_Connectivity_line_devices or @b STM32_Value_line_devices, 
    376            *   this parameter can be one of the following values:
    377            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
    378            *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
    379            *   For @b other_STM32_devices, this parameter can be one of the following values:
    380            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
    381            *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry
    382            *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry 
    383            * @param  RCC_PLLMul: specifies the PLL multiplication factor.
    384            *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
    385            *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
    386            * @retval None
    387            */
    388          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul) {
    389              uint32_t tmpreg = 0;
    390          
    391              /* Check the parameters */
    392              assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
    393              assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
    394          
    395              tmpreg = RCC->CFGR;
    396              /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
    397              tmpreg &= CFGR_PLL_Mask;
    398              /* Set the PLL configuration bits */
    399              tmpreg |= RCC_PLLSource | RCC_PLLMul;
    400              /* Store the new value */
    401              RCC->CFGR = tmpreg;
    402          }
    403          
    404          /**
    405            * @brief  Enables or disables the PLL.
    406            * @note   The PLL can not be disabled if it is used as system clock.
    407            * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
    408            * @retval None
    409            */
    410          void RCC_PLLCmd(FunctionalState NewState) {
    411              /* Check the parameters */
    412              assert_param(IS_FUNCTIONAL_STATE(NewState));
    413          
    414              *(__IO uint32_t *)CR_PLLON_BB = (uint32_t)NewState;
    415          }
    416          
    417          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
    418          /**
    419            * @brief  Configures the PREDIV1 division factor.
    420            * @note 
    421            *   - This function must be used only when the PLL is disabled.
    422            *   - This function applies only to STM32 Connectivity line and Value line 
    423            *     devices.
    424            * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.
    425            *   This parameter can be one of the following values:
    426            *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock
    427            *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock
    428            * @note 
    429            *   For @b STM32_Value_line_devices this parameter is always RCC_PREDIV1_Source_HSE  
    430            * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
    431            *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
    432            * @retval None
    433            */
    434          
    435          void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div) {
    436              uint32_t tmpreg = 0;
    437          
    438              /* Check the parameters */
    439              assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
    440              assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
    441          
    442              tmpreg = RCC->CFGR2;
    443              /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
    444              tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
    445              /* Set the PREDIV1 clock source and division factor */
    446              tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div;
    447              /* Store the new value */
    448              RCC->CFGR2 = tmpreg;
    449          }
    450          
    451          #endif
    452          
    453          #ifdef STM32F10X_CL
    454          /**
    455            * @brief  Configures the PREDIV2 division factor.
    456            * @note 
    457            *   - This function must be used only when both PLL2 and PLL3 are disabled.
    458            *   - This function applies only to STM32 Connectivity line devices.
    459            * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
    460            *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
    461            * @retval None
    462            */
    463          
    464          void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div) {
    465              uint32_t tmpreg = 0;
    466          
    467              /* Check the parameters */
    468              assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));
    469          
    470              tmpreg = RCC->CFGR2;
    471              /* Clear PREDIV2[3:0] bits */
    472              tmpreg &= ~CFGR2_PREDIV2;
    473              /* Set the PREDIV2 division factor */
    474              tmpreg |= RCC_PREDIV2_Div;
    475              /* Store the new value */
    476              RCC->CFGR2 = tmpreg;
    477          }
    478          
    479          /**
    480            * @brief  Configures the PLL2 multiplication factor.
    481            * @note
    482            *   - This function must be used only when the PLL2 is disabled.
    483            *   - This function applies only to STM32 Connectivity line devices.
    484            * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
    485            *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
    486            * @retval None
    487            */
    488          void RCC_PLL2Config(uint32_t RCC_PLL2Mul) {
    489              uint32_t tmpreg = 0;
    490          
    491              /* Check the parameters */
    492              assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));
    493          
    494              tmpreg = RCC->CFGR2;
    495              /* Clear PLL2Mul[3:0] bits */
    496              tmpreg &= ~CFGR2_PLL2MUL;
    497              /* Set the PLL2 configuration bits */
    498              tmpreg |= RCC_PLL2Mul;
    499              /* Store the new value */
    500              RCC->CFGR2 = tmpreg;
    501          }
    502          
    503          /**
    504            * @brief  Enables or disables the PLL2.
    505            * @note 
    506            *   - The PLL2 can not be disabled if it is used indirectly as system clock
    507            *     (i.e. it is used as PLL clock entry that is used as System clock).
    508            *   - This function applies only to STM32 Connectivity line devices.
    509            * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
    510            * @retval None
    511            */
    512          void RCC_PLL2Cmd(FunctionalState NewState) {
    513              /* Check the parameters */
    514              assert_param(IS_FUNCTIONAL_STATE(NewState));
    515          
    516              *(__IO uint32_t *)CR_PLL2ON_BB = (uint32_t)NewState;
    517          }
    518          
    519          /**
    520            * @brief  Configures the PLL3 multiplication factor.
    521            * @note 
    522            *   - This function must be used only when the PLL3 is disabled.
    523            *   - This function applies only to STM32 Connectivity line devices.
    524            * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
    525            *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
    526            * @retval None
    527            */
    528          void RCC_PLL3Config(uint32_t RCC_PLL3Mul) {
    529              uint32_t tmpreg = 0;
    530          
    531              /* Check the parameters */
    532              assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));
    533          
    534              tmpreg = RCC->CFGR2;
    535              /* Clear PLL3Mul[3:0] bits */
    536              tmpreg &= ~CFGR2_PLL3MUL;
    537              /* Set the PLL3 configuration bits */
    538              tmpreg |= RCC_PLL3Mul;
    539              /* Store the new value */
    540              RCC->CFGR2 = tmpreg;
    541          }
    542          
    543          /**
    544            * @brief  Enables or disables the PLL3.
    545            * @note   This function applies only to STM32 Connectivity line devices.
    546            * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
    547            * @retval None
    548            */
    549          void RCC_PLL3Cmd(FunctionalState NewState) {
    550              /* Check the parameters */
    551          
    552              assert_param(IS_FUNCTIONAL_STATE(NewState));
    553              *(__IO uint32_t *)CR_PLL3ON_BB = (uint32_t)NewState;
    554          }
    555          #endif /* STM32F10X_CL */
    556          
    557          /**
    558            * @brief  Configures the system clock (SYSCLK).
    559            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    560            *   This parameter can be one of the following values:
    561            *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
    562            *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
    563            *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
    564            * @retval None
    565            */
    566          
    567          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource) {
    568              uint32_t tmpreg = 0;
    569              /* Check the parameters */
    570              assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
    571              tmpreg = RCC->CFGR;
    572              /* Clear SW[1:0] bits */
    573              tmpreg &= CFGR_SW_Mask;
    574              /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    575              tmpreg |= RCC_SYSCLKSource;
    576              /* Store the new value */
    577              RCC->CFGR = tmpreg;
    578          }
    579          
    580          /**
    581            * @brief  Returns the clock source used as system clock.
    582            * @param  None
    583            * @retval The clock source used as system clock. The returned value can
    584            *   be one of the following:
    585            *     - 0x00: HSI used as system clock
    586            *     - 0x04: HSE used as system clock
    587            *     - 0x08: PLL used as system clock
    588            */
    589          uint8_t RCC_GetSYSCLKSource(void) {
    590              return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
    591          }
    592          
    593          /**
    594            * @brief  Configures the AHB clock (HCLK).
    595            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    596            *   the system clock (SYSCLK).
    597            *   This parameter can be one of the following values:
    598            *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    599            *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    600            *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    601            *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    602            *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    603            *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    604            *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    605            *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    606            *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    607            * @retval None
    608            */
    609          void RCC_HCLKConfig(uint32_t RCC_SYSCLK) {
    610              uint32_t tmpreg = 0;
    611              /* Check the parameters */
    612              assert_param(IS_RCC_HCLK(RCC_SYSCLK));
    613              tmpreg = RCC->CFGR;
    614              /* Clear HPRE[3:0] bits */
    615              tmpreg &= CFGR_HPRE_Reset_Mask;
    616              /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    617              tmpreg |= RCC_SYSCLK;
    618              /* Store the new value */
    619              RCC->CFGR = tmpreg;
    620          }
    621          
    622          /**
    623            * @brief  Configures the Low Speed APB clock (PCLK1).
    624            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    625            *   the AHB clock (HCLK).
    626            *   This parameter can be one of the following values:
    627            *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
    628            *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
    629            *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
    630            *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
    631            *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    632            * @retval None
    633            */
    634          void RCC_PCLK1Config(uint32_t RCC_HCLK) {
    635              uint32_t tmpreg = 0;
    636              /* Check the parameters */
    637              assert_param(IS_RCC_PCLK(RCC_HCLK));
    638              tmpreg = RCC->CFGR;
    639              /* Clear PPRE1[2:0] bits */
    640              tmpreg &= CFGR_PPRE1_Reset_Mask;
    641              /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    642              tmpreg |= RCC_HCLK;
    643              /* Store the new value */
    644              RCC->CFGR = tmpreg;
    645          }
    646          
    647          /**
    648            * @brief  Configures the High Speed APB clock (PCLK2).
    649            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    650            *   the AHB clock (HCLK).
    651            *   This parameter can be one of the following values:
    652            *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
    653            *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
    654            *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
    655            *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
    656            *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    657            * @retval None
    658            */
    659          void RCC_PCLK2Config(uint32_t RCC_HCLK) {
    660              uint32_t tmpreg = 0;
    661              /* Check the parameters */
    662              assert_param(IS_RCC_PCLK(RCC_HCLK));
    663              tmpreg = RCC->CFGR;
    664              /* Clear PPRE2[2:0] bits */
    665              tmpreg &= CFGR_PPRE2_Reset_Mask;
    666              /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    667              tmpreg |= RCC_HCLK << 3;
    668              /* Store the new value */
    669              RCC->CFGR = tmpreg;
    670          }
    671          
    672          /**
    673            * @brief  Enables or disables the specified RCC interrupts.
    674            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
    675            * 
    676            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
    677            *   of the following values        
    678            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    679            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    680            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    681            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    682            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
    683            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
    684            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
    685            * 
    686            *   For @b other_STM32_devices, this parameter can be any combination of the 
    687            *   following values        
    688            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    689            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    690            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    691            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    692            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
    693            *       
    694            * @param  NewState: new state of the specified RCC interrupts.
    695            *   This parameter can be: ENABLE or DISABLE.
    696            * @retval None
    697            */
    698          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState) {
    699              /* Check the parameters */
    700              assert_param(IS_RCC_IT(RCC_IT));
    701              assert_param(IS_FUNCTIONAL_STATE(NewState));
    702          
    703              if (NewState != DISABLE) {
    704                  /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    705                  *(__IO uint8_t *)CIR_BYTE2_ADDRESS |= RCC_IT;
    706              } else {
    707                  /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    708                  *(__IO uint8_t *)CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
    709              }
    710          }
    711          
    712          #ifndef STM32F10X_CL
    713          /**
    714            * @brief  Configures the USB clock (USBCLK).
    715            * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
    716            *   derived from the PLL output.
    717            *   This parameter can be one of the following values:
    718            *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
    719            *                                     clock source
    720            *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
    721            * @retval None
    722            */
    723          
    724          void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource) {
    725              /* Check the parameters */
    726              assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
    727          
    728              *(__IO uint32_t *)CFGR_USBPRE_BB = RCC_USBCLKSource;
    729          }
    730          #else
    731          /**
    732            * @brief  Configures the USB OTG FS clock (OTGFSCLK).
    733            *   This function applies only to STM32 Connectivity line devices.
    734            * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.
    735            *   This clock is derived from the PLL output.
    736            *   This parameter can be one of the following values:
    737            *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
    738            *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
    739            * @retval None
    740            */
    741          
    742          void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource) {
    743              /* Check the parameters */
    744              assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));
    745          
    746              *(__IO uint32_t *)CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
    747          }
    748          
    749          #endif /* STM32F10X_CL */
    750          
    751          /**
    752            * @brief  Configures the ADC clock (ADCCLK).
    753            * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
    754            *   the APB2 clock (PCLK2).
    755            *   This parameter can be one of the following values:
    756            *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
    757            *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
    758            *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
    759            *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
    760            * @retval None
    761            */
    762          
    763          void RCC_ADCCLKConfig(uint32_t RCC_PCLK2) {
    764              uint32_t tmpreg = 0;
    765              /* Check the parameters */
    766              assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
    767              tmpreg = RCC->CFGR;
    768              /* Clear ADCPRE[1:0] bits */
    769              tmpreg &= CFGR_ADCPRE_Reset_Mask;
    770              /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
    771              tmpreg |= RCC_PCLK2;
    772              /* Store the new value */
    773              RCC->CFGR = tmpreg;
    774          }
    775          
    776          #ifdef STM32F10X_CL
    777          /**
    778            * @brief  Configures the I2S2 clock source(I2S2CLK).
    779            * @note
    780            *   - This function must be called before enabling I2S2 APB clock.
    781            *   - This function applies only to STM32 Connectivity line devices.
    782            * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.
    783            *   This parameter can be one of the following values:
    784            *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
    785            *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
    786            * @retval None
    787            */
    788          
    789          void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource) {
    790              /* Check the parameters */
    791              assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));
    792          
    793              *(__IO uint32_t *)CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
    794          }
    795          
    796          /**
    797            * @brief  Configures the I2S3 clock source(I2S2CLK).
    798            * @note
    799            *   - This function must be called before enabling I2S3 APB clock.
    800            *   - This function applies only to STM32 Connectivity line devices.
    801            * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.
    802            *   This parameter can be one of the following values:
    803            *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
    804            *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
    805            * @retval None
    806            */
    807          void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource) {
    808              /* Check the parameters */
    809              assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));
    810          
    811              *(__IO uint32_t *)CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
    812          }
    813          
    814          #endif /* STM32F10X_CL */
    815          
    816          /**
    817            * @brief  Configures the External Low Speed oscillator (LSE).
    818            * @param  RCC_LSE: specifies the new state of the LSE.
    819            *   This parameter can be one of the following values:
    820            *     @arg RCC_LSE_OFF: LSE oscillator OFF
    821            *     @arg RCC_LSE_ON: LSE oscillator ON
    822            *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    823            * @retval None
    824            */
    825          
    826          void RCC_LSEConfig(uint8_t RCC_LSE) {
    827              /* Check the parameters */
    828              assert_param(IS_RCC_LSE(RCC_LSE));
    829              /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    830              /* Reset LSEON bit */
    831              *(__IO uint8_t *)BDCR_ADDRESS = RCC_LSE_OFF;
    832              /* Reset LSEBYP bit */
    833              *(__IO uint8_t *)BDCR_ADDRESS = RCC_LSE_OFF;
    834              /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    835              switch (RCC_LSE) {
    836                  case RCC_LSE_ON:
    837                      /* Set LSEON bit */
    838                      *(__IO uint8_t *)BDCR_ADDRESS = RCC_LSE_ON;
    839                      break;
    840                  case RCC_LSE_Bypass:
    841                      /* Set LSEBYP and LSEON bits */
    842                      *(__IO uint8_t *)BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
    843                      break;
    844          
    845                  default:
    846                      break;
    847              }
    848          }
    849          
    850          /**
    851            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    852            * @note   LSI can not be disabled if the IWDG is running.
    853            * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
    854            * @retval None
    855            */
    856          void RCC_LSICmd(FunctionalState NewState) {
    857              /* Check the parameters */
    858              assert_param(IS_FUNCTIONAL_STATE(NewState));
    859              *(__IO uint32_t *)CSR_LSION_BB = (uint32_t)NewState;
    860          }
    861          
    862          /**
    863            * @brief  Configures the RTC clock (RTCCLK).
    864            * @note   Once the RTC clock is selected it can't be changed unless the Backup domain is reset.
    865            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
    866            *   This parameter can be one of the following values:
    867            *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
    868            *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
    869            *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
    870            * @retval None
    871            */
    872          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource) {
    873              /* Check the parameters */
    874              assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
    875              /* Select the RTC clock source */
    876              RCC->BDCR |= RCC_RTCCLKSource;
    877          }
    878          
    879          /**
    880            * @brief  Enables or disables the RTC clock.
    881            * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
    882            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
    883            * @retval None
    884            */
    885          void RCC_RTCCLKCmd(FunctionalState NewState) {
    886              /* Check the parameters */
    887              assert_param(IS_FUNCTIONAL_STATE(NewState));
    888              *(__IO uint32_t *)BDCR_RTCEN_BB = (uint32_t)NewState;
    889          }
    890          
    891          /**
    892            * @brief  Returns the frequencies of different on chip clocks.
    893            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
    894            *         the clocks frequencies.
    895            * @note   The result of this function could be not correct when using 
    896            *         fractional value for HSE crystal.  
    897            * @retval None
    898            */
    899          void RCC_GetClocksFreq(RCC_ClocksTypeDef *RCC_Clocks) {
    900              uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
    901          
    902          #ifdef STM32F10X_CL
    903          
    904              uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
    905          
    906          #endif /* STM32F10X_CL */
    907          
    908          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    909          
    910              uint32_t prediv1factor = 0;
    911          #endif
    912          
    913              /* Get SYSCLK source -------------------------------------------------------*/
    914          
    915              tmp = RCC->CFGR & CFGR_SWS_Mask;
    916          
    917              switch (tmp) {
    918                  case 0x00: /* HSI used as system clock */
    919                      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
    920                      break;
    921                  case 0x04: /* HSE used as system clock */
    922                      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
    923                      break;
    924                  case 0x08: /* PLL used as system clock */
    925          
    926                      /* Get PLL clock source and multiplication factor ----------------------*/
    927                      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
    928                      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
    929          
    930          #ifndef STM32F10X_CL
    931          
    932                      pllmull = (pllmull >> 18) + 2;
    933          
    934                      if (pllsource == 0x00)
    935                          { /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    936                          RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
    937                      } else {
    938          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    939          
    940                          prediv1factor = (RCC->CFGR2 &CFGR2_PREDIV1)+1;
    941                          /* HSE oscillator clock selected as PREDIV1 clock entry */
    942                          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;
    943          #else
    944                          /* HSE selected as PLL clock entry */
    945          
    946                          if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
    947                              { /* HSE oscillator clock divided by 2 */
    948                              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
    949                          } else {
    950                              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
    951                          }
    952          
    953          #endif
    954          
    955                      }
    956          #else
    957          
    958                      pllmull = pllmull >> 18;
    959          
    960                      if (pllmull != 0x0D) {
    961                          pllmull += 2;
    962                      } else { /* PLL multiplication factor = PLL input clock * 6.5 */
    963                          pllmull = 13 / 2;
    964                      }
    965          
    966                      if (pllsource == 0x00)
    967                          { /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    968                          RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
    969                      } else { /* PREDIV1 selected as PLL clock entry */
    970          
    971                          /* Get PREDIV1 clock source and division factor */
    972                          prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
    973                          prediv1factor = (RCC->CFGR2 &CFGR2_PREDIV1)+1;
    974          
    975                          if (prediv1source == 0) { /* HSE oscillator clock selected as PREDIV1 clock entry */
    976                              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;
    977                          } else {                  /* PLL2 clock selected as PREDIV1 clock entry */
    978          
    979                              /* Get PREDIV2 division factor and PLL2 multiplication factor */
    980                              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
    981                              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8) + 2;
    982                              RCC_Clocks->SYSCLK_Frequency =
    983                                  (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;
    984                          }
    985                      }
    986          
    987          #endif /* STM32F10X_CL */
    988          
    989                      break;
    990          
    991                  default:
    992                      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
    993                      break;
    994              }
    995          
    996              /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
    997              /* Get HCLK prescaler */
    998              tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
    999              tmp = tmp >> 4;
   1000              presc = APBAHBPrescTable[tmp];
   1001              /* HCLK clock frequency */
   1002              RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   1003              /* Get PCLK1 prescaler */
   1004              tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
   1005              tmp = tmp >> 8;
   1006              presc = APBAHBPrescTable[tmp];
   1007              /* PCLK1 clock frequency */
   1008              RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1009              /* Get PCLK2 prescaler */
   1010              tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
   1011              tmp = tmp >> 11;
   1012              presc = APBAHBPrescTable[tmp];
   1013              /* PCLK2 clock frequency */
   1014              RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1015              /* Get ADCCLK prescaler */
   1016              tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
   1017              tmp = tmp >> 14;
   1018              presc = ADCPrescTable[tmp];
   1019              /* ADCCLK clock frequency */
   1020              RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
   1021          }
   1022          
   1023          /**
   1024            * @brief  Enables or disables the AHB peripheral clock.
   1025            * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
   1026            *   
   1027            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
   1028            *   of the following values:        
   1029            *     @arg RCC_AHBPeriph_DMA1
   1030            *     @arg RCC_AHBPeriph_DMA2
   1031            *     @arg RCC_AHBPeriph_SRAM
   1032            *     @arg RCC_AHBPeriph_FLITF
   1033            *     @arg RCC_AHBPeriph_CRC
   1034            *     @arg RCC_AHBPeriph_OTG_FS    
   1035            *     @arg RCC_AHBPeriph_ETH_MAC   
   1036            *     @arg RCC_AHBPeriph_ETH_MAC_Tx
   1037            *     @arg RCC_AHBPeriph_ETH_MAC_Rx
   1038            * 
   1039            *   For @b other_STM32_devices, this parameter can be any combination of the 
   1040            *   following values:        
   1041            *     @arg RCC_AHBPeriph_DMA1
   1042            *     @arg RCC_AHBPeriph_DMA2
   1043            *     @arg RCC_AHBPeriph_SRAM
   1044            *     @arg RCC_AHBPeriph_FLITF
   1045            *     @arg RCC_AHBPeriph_CRC
   1046            *     @arg RCC_AHBPeriph_FSMC
   1047            *     @arg RCC_AHBPeriph_SDIO
   1048            *   
   1049            * @note SRAM and FLITF clock can be disabled only during sleep mode.
   1050            * @param  NewState: new state of the specified peripheral clock.
   1051            *   This parameter can be: ENABLE or DISABLE.
   1052            * @retval None
   1053            */
   1054          void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState) {
   1055              /* Check the parameters */
   1056              assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
   1057              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1058          
   1059              if (NewState != DISABLE) {
   1060                  RCC->AHBENR |= RCC_AHBPeriph;
   1061              } else {
   1062                  RCC->AHBENR &= ~RCC_AHBPeriph;
   1063              }
   1064          }
   1065          
   1066          /**
   1067            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1068            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1069            *   This parameter can be any combination of the following values:
   1070            *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
   1071            *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
   1072            *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
   1073            *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
   1074            *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
   1075            *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
   1076            *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11     
   1077            * @param  NewState: new state of the specified peripheral clock.
   1078            *   This parameter can be: ENABLE or DISABLE.
   1079            * @retval None
   1080            */
   1081          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState) {
   1082              /* Check the parameters */
   1083              assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1084              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1085          
   1086              if (NewState != DISABLE) {
   1087                  RCC->APB2ENR |= RCC_APB2Periph;
   1088              } else {
   1089                  RCC->APB2ENR &= ~RCC_APB2Periph;
   1090              }
   1091          }
   1092          
   1093          /**
   1094            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1095            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1096            *   This parameter can be any combination of the following values:
   1097            *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1098            *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1099            *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1100            *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
   1101            *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1102            *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
   1103            *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
   1104            *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14
   1105            * @param  NewState: new state of the specified peripheral clock.
   1106            *   This parameter can be: ENABLE or DISABLE.
   1107            * @retval None
   1108            */
   1109          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState) {
   1110              /* Check the parameters */
   1111              assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1112              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1113          
   1114              if (NewState != DISABLE) {
   1115                  RCC->APB1ENR |= RCC_APB1Periph;
   1116              } else {
   1117                  RCC->APB1ENR &= ~RCC_APB1Periph;
   1118              }
   1119          }
   1120          
   1121          #ifdef STM32F10X_CL
   1122          /**
   1123            * @brief  Forces or releases AHB peripheral reset.
   1124            * @note   This function applies only to STM32 Connectivity line devices.
   1125            * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
   1126            *   This parameter can be any combination of the following values:
   1127            *     @arg RCC_AHBPeriph_OTG_FS 
   1128            *     @arg RCC_AHBPeriph_ETH_MAC
   1129            * @param  NewState: new state of the specified peripheral reset.
   1130            *   This parameter can be: ENABLE or DISABLE.
   1131            * @retval None
   1132            */
   1133          
   1134          void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState) {
   1135              /* Check the parameters */
   1136              assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
   1137              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1138          
   1139              if (NewState != DISABLE) {
   1140                  RCC->AHBRSTR |= RCC_AHBPeriph;
   1141              } else {
   1142                  RCC->AHBRSTR &= ~RCC_AHBPeriph;
   1143              }
   1144          }
   1145          
   1146          #endif /* STM32F10X_CL */
   1147          
   1148          /**
   1149            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1150            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1151            *   This parameter can be any combination of the following values:
   1152            *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
   1153            *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
   1154            *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
   1155            *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
   1156            *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
   1157            *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
   1158            *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11  
   1159            * @param  NewState: new state of the specified peripheral reset.
   1160            *   This parameter can be: ENABLE or DISABLE.
   1161            * @retval None
   1162            */
   1163          
   1164          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState) {
   1165              /* Check the parameters */
   1166              assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1167              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1168          
   1169              if (NewState != DISABLE) {
   1170                  RCC->APB2RSTR |= RCC_APB2Periph;
   1171              } else {
   1172                  RCC->APB2RSTR &= ~RCC_APB2Periph;
   1173              }
   1174          }
   1175          
   1176          /**
   1177            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1178            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1179            *   This parameter can be any combination of the following values:
   1180            *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1181            *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1182            *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1183            *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
   1184            *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1185            *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
   1186            *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
   1187            *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14  
   1188            * @param  NewState: new state of the specified peripheral clock.
   1189            *   This parameter can be: ENABLE or DISABLE.
   1190            * @retval None
   1191            */
   1192          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState) {
   1193              /* Check the parameters */
   1194              assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1195              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1196          
   1197              if (NewState != DISABLE) {
   1198                  RCC->APB1RSTR |= RCC_APB1Periph;
   1199              } else {
   1200                  RCC->APB1RSTR &= ~RCC_APB1Periph;
   1201              }
   1202          }
   1203          
   1204          /**
   1205            * @brief  Forces or releases the Backup domain reset.
   1206            * @param  NewState: new state of the Backup domain reset.
   1207            *   This parameter can be: ENABLE or DISABLE.
   1208            * @retval None
   1209            */
   1210          void RCC_BackupResetCmd(FunctionalState NewState) {
   1211              /* Check the parameters */
   1212              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1213              *(__IO uint32_t *)BDCR_BDRST_BB = (uint32_t)NewState;
   1214          }
   1215          
   1216          /**
   1217            * @brief  Enables or disables the Clock Security System.
   1218            * @param  NewState: new state of the Clock Security System..
   1219            *   This parameter can be: ENABLE or DISABLE.
   1220            * @retval None
   1221            */
   1222          void RCC_ClockSecuritySystemCmd(FunctionalState NewState) {
   1223              /* Check the parameters */
   1224              assert_param(IS_FUNCTIONAL_STATE(NewState));
   1225              *(__IO uint32_t *)CR_CSSON_BB = (uint32_t)NewState;
   1226          }
   1227          
   1228          /**
   1229            * @brief  Selects the clock source to output on MCO pin.
   1230            * @param  RCC_MCO: specifies the clock source to output.
   1231            *   
   1232            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1233            *   following values:       
   1234            *     @arg RCC_MCO_NoClock: No clock selected
   1235            *     @arg RCC_MCO_SYSCLK: System clock selected
   1236            *     @arg RCC_MCO_HSI: HSI oscillator clock selected
   1237            *     @arg RCC_MCO_HSE: HSE oscillator clock selected
   1238            *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
   1239            *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected                     
   1240            *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected   
   1241            *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected  
   1242            *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected 
   1243            * 
   1244            *   For  @b other_STM32_devices, this parameter can be one of the following values:        
   1245            *     @arg RCC_MCO_NoClock: No clock selected
   1246            *     @arg RCC_MCO_SYSCLK: System clock selected
   1247            *     @arg RCC_MCO_HSI: HSI oscillator clock selected
   1248            *     @arg RCC_MCO_HSE: HSE oscillator clock selected
   1249            *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
   1250            *   
   1251            * @retval None
   1252            */
   1253          void RCC_MCOConfig(uint8_t RCC_MCO) {
   1254              /* Check the parameters */
   1255              assert_param(IS_RCC_MCO(RCC_MCO));
   1256          
   1257              /* Perform Byte access to MCO bits to select the MCO source */
   1258              *(__IO uint8_t *)CFGR_BYTE4_ADDRESS = RCC_MCO;
   1259          }
   1260          
   1261          /**
   1262            * @brief  Checks whether the specified RCC flag is set or not.
   1263            * @param  RCC_FLAG: specifies the flag to check.
   1264            *   
   1265            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1266            *   following values:
   1267            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1268            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1269            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1270            *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready      
   1271            *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready                           
   1272            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1273            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1274            *     @arg RCC_FLAG_PINRST: Pin reset
   1275            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1276            *     @arg RCC_FLAG_SFTRST: Software reset
   1277            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1278            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1279            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1280            * 
   1281            *   For @b other_STM32_devices, this parameter can be one of the following values:        
   1282            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1283            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1284            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1285            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1286            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1287            *     @arg RCC_FLAG_PINRST: Pin reset
   1288            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1289            *     @arg RCC_FLAG_SFTRST: Software reset
   1290            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1291            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1292            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1293            *   
   1294            * @retval The new state of RCC_FLAG (SET or RESET).
   1295            */
   1296          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG) {
   1297              uint32_t tmp = 0;
   1298              uint32_t statusreg = 0;
   1299              FlagStatus bitstatus = RESET;
   1300              /* Check the parameters */
   1301              assert_param(IS_RCC_FLAG(RCC_FLAG));
   1302          
   1303              /* Get the RCC register index */
   1304              tmp = RCC_FLAG >> 5;
   1305          
   1306              if (tmp == 1) /* The flag to check is in CR register */
   1307              {
   1308                  statusreg = RCC->CR;
   1309              } else if (tmp == 2) /* The flag to check is in BDCR register */
   1310              {
   1311                  statusreg = RCC->BDCR;
   1312              } else /* The flag to check is in CSR register */
   1313              {
   1314                  statusreg = RCC->CSR;
   1315              }
   1316          
   1317              /* Get the flag position */
   1318              tmp = RCC_FLAG & FLAG_Mask;
   1319          
   1320              if ((statusreg &((uint32_t)1 << tmp)) != (uint32_t)RESET) {
   1321                  bitstatus = SET;
   1322              } else {
   1323                  bitstatus = RESET;
   1324              }
   1325          
   1326              /* Return the flag status */
   1327              return bitstatus;
   1328          }
   1329          
   1330          /**
   1331            * @brief  Clears the RCC reset flags.
   1332            * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
   1333            *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   1334            * @param  None
   1335            * @retval None
   1336            */
   1337          void RCC_ClearFlag(void) {
   1338              /* Set RMVF bit to clear the reset flags */
   1339              RCC->CSR |= CSR_RMVF_Set;
   1340          }
   1341          
   1342          /**
   1343            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1344            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1345            *   
   1346            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1347            *   following values:
   1348            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1349            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1350            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1351            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1352            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1353            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
   1354            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
   1355            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1356            * 
   1357            *   For @b other_STM32_devices, this parameter can be one of the following values:        
   1358            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1359            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1360            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1361            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1362            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1363            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1364            *   
   1365            * @retval The new state of RCC_IT (SET or RESET).
   1366            */
   1367          ITStatus RCC_GetITStatus(uint8_t RCC_IT) {
   1368              ITStatus bitstatus = RESET;
   1369              /* Check the parameters */
   1370              assert_param(IS_RCC_GET_IT(RCC_IT));
   1371          
   1372              /* Check the status of the specified RCC interrupt */
   1373              if ((RCC->CIR & RCC_IT) != (uint32_t)RESET) {
   1374                  bitstatus = SET;
   1375              } else {
   1376                  bitstatus = RESET;
   1377              }
   1378          
   1379              /* Return the RCC_IT status */
   1380              return bitstatus;
   1381          }
   1382          
   1383          /**
   1384            * @brief  Clears the RCC's interrupt pending bits.
   1385            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1386            *   
   1387            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
   1388            *   of the following values:
   1389            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1390            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1391            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1392            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1393            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1394            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
   1395            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
   1396            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1397            * 
   1398            *   For @b other_STM32_devices, this parameter can be any combination of the
   1399            *   following values:        
   1400            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1401            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1402            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1403            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1404            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1405            *   
   1406            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1407            * @retval None
   1408            */
   1409          void RCC_ClearITPendingBit(uint8_t RCC_IT) {
   1410              /* Check the parameters */
   1411              assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   1412          
   1413              /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1414                 pending bits */
   1415              *(__IO uint8_t *)CIR_BYTE3_ADDRESS = RCC_IT;
   1416          }
   1417          
   1418          /**
   1419            * @}
   1420            */
   1421          
   1422          /**
   1423            * @}
   1424            */
   1425          
   1426          /**
   1427            * @}
   1428            */
   1429          
   1430          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  RCC_ADCCLKConfig
        0  RCC_AHBPeriphClockCmd
        0  RCC_AHBPeriphResetCmd
        0  RCC_APB1PeriphClockCmd
        0  RCC_APB1PeriphResetCmd
        0  RCC_APB2PeriphClockCmd
        0  RCC_APB2PeriphResetCmd
        0  RCC_AdjustHSICalibrationValue
        0  RCC_BackupResetCmd
        0  RCC_ClearFlag
        0  RCC_ClearITPendingBit
        0  RCC_ClockSecuritySystemCmd
        0  RCC_DeInit
       20  RCC_GetClocksFreq
        4  RCC_GetFlagStatus
        0  RCC_GetITStatus
        0  RCC_GetSYSCLKSource
        0  RCC_HCLKConfig
        0  RCC_HSEConfig
        0  RCC_HSICmd
        0  RCC_I2S2CLKConfig
        0  RCC_I2S3CLKConfig
        0  RCC_ITConfig
        0  RCC_LSEConfig
        0  RCC_LSICmd
        0  RCC_MCOConfig
        0  RCC_OTGFSCLKConfig
        0  RCC_PCLK1Config
        0  RCC_PCLK2Config
        0  RCC_PLL2Cmd
        0  RCC_PLL2Config
        0  RCC_PLL3Cmd
        0  RCC_PLL3Config
        0  RCC_PLLCmd
        0  RCC_PLLConfig
        0  RCC_PREDIV1Config
        0  RCC_PREDIV2Config
        0  RCC_RTCCLKCmd
        0  RCC_RTCCLKConfig
        0  RCC_SYSCLKConfig
       16  RCC_WaitForHSEStartUp
             16 -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_10
       4  ??DataTable39_11
       4  ??DataTable39_12
       4  ??DataTable39_13
       4  ??DataTable39_14
       4  ??DataTable39_15
       4  ??DataTable39_16
       4  ??DataTable39_17
       4  ??DataTable39_18
       4  ??DataTable39_19
       4  ??DataTable39_2
       4  ??DataTable39_20
       4  ??DataTable39_21
       4  ??DataTable39_22
       4  ??DataTable39_23
       4  ??DataTable39_24
       4  ??DataTable39_25
       4  ??DataTable39_26
       4  ??DataTable39_27
       4  ??DataTable39_28
       4  ??DataTable39_29
       4  ??DataTable39_3
       4  ??DataTable39_30
       4  ??DataTable39_31
       4  ??DataTable39_32
       4  ??DataTable39_33
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
       4  ??DataTable39_7
       4  ??DataTable39_8
       4  ??DataTable39_9
       4  ADCPrescTable
      16  APBAHBPrescTable
      24  RCC_ADCCLKConfig
      30  RCC_AHBPeriphClockCmd
      30  RCC_AHBPeriphResetCmd
      30  RCC_APB1PeriphClockCmd
      30  RCC_APB1PeriphResetCmd
      30  RCC_APB2PeriphClockCmd
      30  RCC_APB2PeriphResetCmd
      28  RCC_AdjustHSICalibrationValue
       8  RCC_BackupResetCmd
      14  RCC_ClearFlag
       6  RCC_ClearITPendingBit
       8  RCC_ClockSecuritySystemCmd
     120  RCC_DeInit
     416  RCC_GetClocksFreq
      80  RCC_GetFlagStatus
      28  RCC_GetITStatus
      12  RCC_GetSYSCLKSource
      24  RCC_HCLKConfig
      86  RCC_HSEConfig
      10  RCC_HSICmd
       8  RCC_I2S2CLKConfig
       8  RCC_I2S3CLKConfig
      38  RCC_ITConfig
      52  RCC_LSEConfig
      10  RCC_LSICmd
       6  RCC_MCOConfig
       8  RCC_OTGFSCLKConfig
      24  RCC_PCLK1Config
      26  RCC_PCLK2Config
      10  RCC_PLL2Cmd
      24  RCC_PLL2Config
      10  RCC_PLL3Cmd
      24  RCC_PLL3Config
      10  RCC_PLLCmd
      28  RCC_PLLConfig
      30  RCC_PREDIV1Config
      24  RCC_PREDIV2Config
       8  RCC_RTCCLKCmd
      12  RCC_RTCCLKConfig
      24  RCC_SYSCLKConfig
      64  RCC_WaitForHSEStartUp

 
    20 bytes in section .data
 1 628 bytes in section .text
 
 1 628 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
