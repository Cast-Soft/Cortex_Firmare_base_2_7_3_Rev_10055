###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     17/Apr/2019  16:26:55 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\App\tasks.c                                         #
#    Command line =  "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\App\tasks.c" -D BEACON_APP -D USE_STDPERIPH_DRIVER  #
#                    -D STM32F10X_CL -D COOS -D USE_MY_ASSERT -D BC_HW_REVJ   #
#                    -D _DEBUG -D BOOTLOADER -D EE_M24C02 -D TASKS_PROFILE    #
#                    -D BATTERY_CHECK -D CCA_EN_NO -D NEW_BEACON -D USE_TIM4  #
#                    -D WDT_ENABLE -D OLD_CONFIG -D CIRCULAR_LOG -D           #
#                    msgmethod1 -lcN "C:\Users\User\Documents\Cortex_git\BLKT #
#                    -01.git\Source Code\BLKT-01                              #
#                    Beacon\Source\firmware\beacon -                          #
#                    Copy\IAR\Debug-Bootloader\List\" -o                      #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\Debug-Bootloader\Obj\" --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.gi #
#                    t\Source Code\BLKT-01 Beacon\Source\firmware\beacon -    #
#                    Copy\IAR\..\App\" -I "C:\Users\User\Documents\Cortex_git #
#                    \BLKT-01.git\Source Code\BLKT-01                         #
#                    Beacon\Source\firmware\beacon -                          #
#                    Copy\IAR\..\..\common\CMSIS\CM3\DeviceSupport\ST\STM32F1 #
#                    0x\" -I "C:\Users\User\Documents\Cortex_git\BLKT-01.git\ #
#                    Source Code\BLKT-01 Beacon\Source\firmware\beacon -      #
#                    Copy\IAR\..\..\common\STM32F10x_StdPeriph_Driver\inc\"   #
#                    -I "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Sourc #
#                    e Code\BLKT-01 Beacon\Source\firmware\beacon -           #
#                    Copy\IAR\..\..\common\CoOS\kernel\" -I                   #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\..\..\common\CoOS\portable\" -I                 #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\..\..\..\common\" -I                            #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\..\..\common\USB-Device-CDC\" -I                #
#                    "C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source   #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\..\..\common\" -I "C:\Users\User\Documents\Cort #
#                    ex_git\BLKT-01.git\Source Code\BLKT-01                   #
#                    Beacon\Source\firmware\beacon - Copy\IAR\" -On           #
#                    --use_c++_inline -I "C:\Program Files (x86)\IAR          #
#                    Systems\Embedded Workbench 6.4\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\Debug-Bootloader\List\tasks.lst                 #
#    Object file  =  C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source    #
#                    Code\BLKT-01 Beacon\Source\firmware\beacon -             #
#                    Copy\IAR\Debug-Bootloader\Obj\tasks.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\User\Documents\Cortex_git\BLKT-01.git\Source Code\BLKT-01 Beacon\Source\firmware\beacon - Copy\App\tasks.c
      1          /********************  All title and rights are owned by  *********************
      2          *******  the CAST Group of Companies Inc. or licensors thereto. ***************
      3          *******************************************************************************
      4          * File Name          : tasks.c
      5          * Author             : ?
      6          * Version            : V1.0
      7          * Date               : 6/2/2011
      8          * Description        : All the various System Tasks
      9          *******************************************************************************/
     10          
     11          #include "VersionNo.h"
     12          
     13          /* INCLUDES ------------------------------------------------------------------*/
     14          
     15          #include "tasks.h"
     16          #include "CoOS.h"
     17          #include "hardware.h"
     18          #include "basic_rf.h"
     19          #include "radio.h"
     20          #include "stm32f10x_it.h"
     21          #include "stm32f10x_iwdg.h"
     22          #include "stm32f10x_flash.h"
     23          #include "stm32f10x_adc.h"
     24          #include "i2c_ee.h"
     25          #include <stdio.h>
     26          #include <string.h>
     27          #include <ctype.h>
     28          
     29          #include "radio.h"
     30          #include "radio_defs.h"
     31          #include "packets.h"
     32          #include "flash_map.h"
     33          #include "util.h"
     34          #include "config.h"
     35          #include "console_tail.h"
     36          
     37          /* PRIVATE TYPEDEF -----------------------------------------------------------*/
     38          
     39          typedef struct {
     40              uint16_t    dstAddr;
     41              uint8_t     payloadSize;
     42              uint8_t     payload[FRAME_LENGTH_MAX - MHR_SIZE - MFR_SIZE];
     43          } txPktRec_t;
     44          
     45          /* PRIVATE DEFINES -----------------------------------------------------------*/
     46          
     47          #ifdef STDIO_TO_USART
     48          #define DISABLE_PWR_SW
     49          #endif
     50          
     51          #define PINGER_ADDR         0x1234
     52          #define TX_PKT_QUEUE_SIZE   8
     53          
     54          #define UPDATE_FLAG_PANID       0x01
     55          #define UPDATE_FLAG_DSTADDR     0x02
     56          #define UPDATE_FLAG_DAC         0x04
     57          #define UPDATE_FLAG_RFCHAN      0x08
     58          #define UPDATE_FLAG_TXLEVEL     0x10
     59          
     60          /*
     61           Beacon Pkt Duration = 0.70ms
     62           Max TX Pkt Duration = 3.5ms
     63           Inhibit Guard-Band Pre = 4.0ms
     64           Inhibit Guard-Band Post = 0.5ms
     65          */
     66          #define SOH 0x01
     67          #define EOT 0x04
     68          #define ACK 0x06
     69          
     70          /**  IMU LSM330DLC definitions **/
     71          
     72          #define IMU_CTRL_REG1         0x20
     73          #define IMU_CTRL_REG2         0x21
     74          #define IMU_CTRL_REG3         0x22
     75          #define IMU_CTRL_REG4         0x23
     76          #define IMU_CTRL_REG5         0x24
     77          #define IMU_WHOAMI_REG        0x0F
     78          #define IMU_IM_LSM330         0xD4
     79          
     80          #define IMU_A_RATE_1HZ          0x10
     81          #define IMU_A_RATE_10HZ         0x20
     82          #define IMU_A_RATE_25HZ         0x30
     83          #define IMU_A_RATE_50HZ         0x40
     84          #define IMU_A_RATE_100HZ        0x50
     85          #define IMU_A_RATE_200HZ        0x60
     86          #define IMU_A_RATE_400HZ        0x70
     87          
     88          #define IMU_A_AXIS_X_EN         0x01
     89          #define IMU_A_AXIS_Y_EN         0x02
     90          #define IMU_A_AXIS_Z_EN         0x04
     91          
     92          #define IMU_BIG_ENDIAN          0x40
     93          #define IMU_H_RESOL             0x08
     94          
     95          
     96          #define BTN_BURST_SEND 5
     97          
     98          #define NUM_TX_RETRIES 4
     99          
    100          #define DEBOUNCE_MIN    1
    101          #define DEBOUNCE_MAX    9
    102          #define DBLCLICK_MIN_TIME       1
    103          #define DBLCLICK_MAX_TIME       9
    104          
    105          /* PRIVATE MACROS ------------------------------------------------------------*/
    106          
    107          /* EXTERN VARIABLES ----------------------------------------------------------*/
    108          
    109          
    110          /* Variables Defined in main.c */
    111          
    112          extern char firmwareVersion[];
    113          extern uint8_t radio_off;
    114          
    115          extern uint32_t txFrmDoneCount;
    116          extern uint32_t irq_spi_dma;
    117          //uint32_t task2Counter;
    118          extern StatusType task2StatusType;
    119          extern uint32_t task2enter;
    120          
    121          extern OS_TID task1Id;
    122          extern OS_TID taskRadioRxId;
    123          extern OS_TID task3Id;
    124          extern OS_TID taskConfigId;
    125          extern OS_TID taskRadioTxId;
    126          extern OS_TID task8Id;
    127          extern OS_TID taskIMUGId;
    128          
    129          extern OS_FlagID flagBTNNewData;
    130          extern OS_FlagID flagIMUNewData;
    131          extern OS_FlagID flagIMU_G_DRDY;
    132          extern OS_FlagID flagRadioTxReq;
    133          extern OS_FlagID flagIMUTimeToSend;
    134          extern OS_FlagID flagRadioCCA;
    135          
    136          extern uint32_t drift;
    137          extern int32_t last_drift;
    138          
    139          extern OS_EventID semIMUAllow;
    140          extern OS_FlagID   flagIMUDataReady;
    141          extern OS_FlagID   flagBtnDataReady;
    142          extern OS_FlagID   flagBatDataReady;
    143          extern OS_FlagID   flagLEDDataReady;
    144          
    145          extern volatile uint32_t IMUSampleTime;
    146          extern volatile uint16_t MsTimerAtSync;
    147          extern volatile uint8_t IMUPktNumAtSync;
    148          
    149          extern Batt_Union_t BattUnion, *pBattUnion;
    150          //extern SPI3_CS_TypeDef SPI3_CS;
    151          
    152          extern uint32_t rxErrors;
    153          extern uint32_t sec;
    154          extern struct realTime semTime2;
    155          extern struct realTime rxFIFOTime;
    156          
    157          extern volatile uint16_t tasksWDT;
    158          #if (defined USE_MY_ASSERT) || (defined USE_FULL_ASSERT)
    159          extern uint8_t  assert_loop;
    160          #endif
    161          extern uint16_t routerAddr;
    162          extern uint8_t asserted;
    163          extern uint8_t cc2520_flags0;
    164          extern uint8_t cc2520_flags1;
    165          extern uint8_t cc2520_flags2;
    166          extern uint16_t sampledCCA;
    167          
    168          #ifdef CIRCULAR_LOG
    169          tLogStruct log[LOG_SIZE/sizeof(tLogStruct)];
    170          uint16_t  log_index_in;
    171          #endif
    172          
    173          uint8_t last_percents;
    174          uint32_t Valids;
    175          uint32_t notValids;
    176          uint32_t lostSync;
    177          uint32_t changeClocks;
    178          uint32_t newbcn;
    179          uint32_t frameIdCorrectionCount;
    180          //uint8_t TRACE_ADJUST = 0;
    181          uint32_t oldFrameIdAtSync, newFrameIdAtSync;
    182          
    183          //extern uint32_t rx_overflow;
    184          //extern uint32_t tx_overflow;
    185          extern uint16_t tim2_phase;
    186          extern uint16_t tim3_phase;
    187          //extern uint32_t syncPackets;
    188          
    189          extern uint16_t adjusted;
    190          extern uint8_t adjusted_changed;
    191          
    192          extern tBtn_State btnA;
    193          extern tBtn_State btnB;
    194          
    195          int TRACE(char* fmt, ...);
    196          size_t __writeIMU(const unsigned char *buffer, size_t size);
    197          extern void RadioIMU_WaitGrabSPI();
    198          extern void RadioIMU_ReleaseSPI(void);
    199          
    200          void IMUWaitGrabSPI();
    201          void IMUReleaseSPI();
    202          
    203          size_t __writeCmdLineRespPacket(const unsigned char *buffer, size_t size, uint8_t contentType);
    204          uint16_t tim_at_sec;
    205          
    206          uint32_t rt_flags;
    207          
    208          /* PRIVATE VARIABLES ---------------------------------------------------------*/
    209          //static uint16_t tim4MovAvgMin = UINT16_MAX, tim4MovAvgMax = 0;
    210          static volatile uint16_t halted = 0;
    211          static uint8_t beaconInSync = 0;
    212          static uint16_t txCount;        // ping count
    213          static uint8_t txTestStr[] = {0xAA, 0x55, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
    214          static uint8_t txBuf[FRAME_LENGTH_MAX - MHR_SIZE - MFR_SIZE];  // tx-payload buffer
    215          static uint8_t rfChan;
    216          static uint8_t beaconRSSI;
    217          static txPktRec_t txPktQueue[TX_PKT_QUEUE_SIZE];
    218          static uint16_t inIdx = 0;
    219          static uint16_t outIdx = 0;
    220          static struct realTime startRadioTx;
    221          static struct realTime endRadioTx;
    222          static uint8_t queue_full;
    223          //static uint8_t send_battery_info = 1;
    224          
    225          volatile int32_t remainOutOfSyncTime;
    226          
    227          static struct Beacon_BatData lastBatStatus;
    228          
    229          uint8_t          frameIdFlag = 1;
    230          uint32_t         errorFrameId;
    231          
    232          //#define EIGHTSAMPLEOFFSET 48299   // 80.5mS / 1.666 uS
    233          #define EIGHTSAMPLEOFFSET 48089   // 80.0mS / 1.666 uS
    234          #define FIVESAMPLEOFFSET  0   // 3.5mS / 1.666 uS
    235          
    236          // Timeslots in uS
    237          //  0, 876, 5,532, 10,188, 14,844, 19,500, 24,156, 28,812, 33,468, 38,124, 42,780
    238          //  47,436, 52,092, 56,748, 61,404, 66,060, 70,716, 75,372, 80,028, 84,684, 89,340
    239          //  93,996
    240          // timeslot offset run from 1.666uS counter
    241          //
    242          /*uint16_t TimeSlotVals[] = {0, 525, 3319, 6112, 8906, 11700, 14493, 17287, 20080, 22874,
    243                    25667, 28461, 31254, 34048, 36841, 39635, 42429, 45222, 48016, 50809,
    244                  53603, 56396 };*/
    245          
    246          /* same as above but now using 3.0 ms time slots instead of 4.65ms
    247          1800 counts per 3.0ms*/
    248          
    249          //3.5ms slots
    250          /*uint16_t TimeSlotVals[] = {0,   525,  2625, 4725, 6825, 8925,11025,13125,15225,17325,
    251                                    19425,21525,23625,25725,};*/
    252          static uint16_t TimeSlotVals[] = {0,   0, 2100, 4200, 6300, 8400,10500,12600,14700,16800,
    253                                    18900,21000,23100,25200, 27300, 29400};
    254          
    255          #define MAX_NUMBER_OF_TIMESLOTS sizeof(TimeSlotVals) / sizeof(uint16_t)
    256          
    257          /* PUBLIC VARIABLES ----------------------------------------------------------*/
    258          
    259          
    260          __no_init uint32_t random;
    261          
    262          config_t config;
    263          tButton buttonA;
    264          tButton buttonB;
    265          
    266          struct realTime oldFrameTime;
    267          struct realTime newFrameTime;
    268          
    269          uint32_t realFrameId;
    270          uint32_t lastFrameIdAtSync;
    271          uint32_t lastFrameIdCorrection;
    272          int8_t frameAdjust = 4;
    273          uint32_t successBeacons;
    274          uint16_t routerAddr = 0;
    275          uint8_t use_sync = 1;
    276          uint16_t RfTxLevel;
    277          uint32_t IMUdbgPrt = 0;
    278          uint16_t frameOffset;
    279          uint8_t bat_slot_numbers;
    280          static uint32_t bat_send_time;
    281          
    282          
    283          //IMUData IMU_Packets;
    284          
    285          //I2C_ADDR_TypeDef ADDR_I2C;
    286          
    287          uint8_t button_state;
    288          uint32_t last_bat_sent;
    289          
    290          uint8_t IMUPresent = 0;   // imu present absent flag
    291          uint8_t test_imu_pkt_ctr = 0; // IMU packet ctr from IMU interrupt
    292          
    293          uint16_t txTimeSlot = 40000;
    294          
    295          uint8_t firstTime = 1;  // first need to initialize timer of time slot
    296          uint16_t random_slot1 = 0xFFFF;
    297          uint16_t random_slot2 = 0xFFFF;
    298          
    299          /* EXTERNAL FUNCTION PROTOTYPES ---------------------------------------------*/
    300          uint8_t IMURegRd(uint8_t addr, HwSPI_TypeDef Sensor);
    301          void IMURegWr(uint8_t addr, HwSPI_TypeDef Sensor, uint8_t val);
    302          
    303          /* PRIVATE FUNCTION PROTOTYPES -----------------------------------------------*/
    304          static void GetAverageImuData(uint16_t *pBuff);
    305          static void InputDataIntoBuffer(uint8_t volatile *pImuData);
    306          
    307          static void mygets(char *str);
    308          //static void IMURegWr(uint8_t addr, uint16_t val);
    309          //static uint16_t IMURegRd(uint8_t addr);
    310          static void SetConfig(uint16_t idx, uint32_t val, uint32_t pattern, uint8_t ledBits, uint8_t ledId);
    311          static void PrintConfig(void);
    312          
    313          static uint8_t RadioTxPktQueue(uint16_t dstAddr, uint8_t payloadSize, uint8_t *payload);
    314          uint16_t fastdivide250(uint16_t);
    315          
    316          static uint8_t __task1_imu_pack(uint8_t * ptr);
    317          static uint8_t __task1_btn_pack(uint8_t * ptr);
    318          static uint8_t __task1_btnimu_pack(uint8_t * ptr);
    319          static uint8_t __task1_bat_pack(uint8_t * ptr);
    320          static uint8_t __task1_batimu_pack(uint8_t * ptr);
    321          static uint8_t __task1_batbtn_pack(uint8_t * ptr);
    322          static uint8_t __task1_batbtnimu_pack(uint8_t * ptr);
    323          static uint8_t __task1_led_pack(uint8_t * ptr);
    324          static uint8_t __task1_ledimu_pack(uint8_t * ptr);
    325          static uint8_t __task1_ledbtn_pack(uint8_t * ptr);
    326          static uint8_t __task1_ledbtnimu_pack(uint8_t * ptr);
    327          static uint8_t __task1_ledbat_pack(uint8_t * ptr);
    328          static uint8_t __task1_ledbatimu_pack(uint8_t * ptr);
    329          static uint8_t __task1_ledbatbtn_pack(uint8_t * ptr);
    330          static uint8_t __task1_ledbatbtnimu_pack(uint8_t * ptr);
    331          /* PRIVATE FUNCTIONS ---------------------------------------------------------*/
    332          
    333          /*******************************************************************************
    334          * Description : Sets Outgoing Tx Timeslot
    335          * Input       :
    336          * Return      : -
    337          *******************************************************************************/
    338          void SetTimeSlot(void){
    339          
    340          uint16_t TimeSlotTemp = 40000;
    341          
    342            if((config.rfTimeSlot > 1) && (config.rfTimeSlot < MAX_NUMBER_OF_TIMESLOTS))
    343            {
    344              TimeSlotTemp = TimeSlotVals[config.rfTimeSlot];
    345              //TimeSlotTemp -= FIVESAMPLEOFFSET;
    346              /*if(TimeSlotTemp > FIVESAMPLEOFFSET)
    347              {
    348                  TimeSlotTemp -= FIVESAMPLEOFFSET;
    349              }
    350              else
    351              {
    352                TimeSlotTemp = FIVESAMPLEOFFSET -  (TimeSlotVals[config.rfTimeSlot]);
    353                TimeSlotTemp = 60000 - TimeSlotTemp;
    354              }*/
    355              txTimeSlot =TimeSlotTemp;
    356              firstTime = 1;           // reset timeslot
    357            }
    358            else
    359            {
    360              config.rfTimeSlot = 2;
    361              //recursive call
    362              SetTimeSlot();
    363            }
    364          }
    365          
    366          
    367          /*******************************************************************************
    368          * Description : Get a line from STDIN
    369          * Input       :
    370          * Return      : -
    371          *******************************************************************************/
    372          static void mygets(char *str) {
    373              char *tmp = str;
    374              int c;
    375              SAVE_POINT
    376              do {
    377                  while( (c = getchar()) == EOF ) {
    378                      SAVE_POINT
    379                      CoTickDelay(10);
    380                      SAVE_POINT
    381                      // reset tasksWDT
    382                      tasksWDT |= 0x0002;
    383                  }
    384                  putchar(c);
    385                  *tmp++ = (char) c;
    386              } while (c != '\r');
    387              SAVE_POINT
    388          
    389              putchar('\n');
    390              *(--tmp) = '\0';
    391          }
    392          /*******************************************************************************
    393          * Description : Write to an IMU Register
    394          * Input       :
    395          * Return      : -
    396          *******************************************************************************/
    397          void IMURegWr(uint8_t addr, HwSPI_TypeDef Sensor, uint8_t val) {
    398              SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI); // flush RXNE
    399          
    400              // write LSB
    401              HwSPISSAssert(Sensor);
    402              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, ((addr << 8) | val) );
    403              //TK_BK_SPI_WAIT_RXRDY();
    404              while (SPI_I2S_GetFlagStatus(SPI_RADIO_IMU_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    405              SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI); // flush RXNE
    406              HwSPISSDeAssert(Sensor);
    407          }
    408          
    409          #define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
    410          
    411          /*******************************************************************************
    412          * Function Name  : NVIC_GenerateSystemReset
    413          * Description    : Generates a system reset.
    414          * Input          : None
    415          * Output         : None
    416          * Return         : None
    417          *******************************************************************************/
    418          void NVIC_GenerateSystemReset(void)
    419          {
    420            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
    421          }
    422          
    423          
    424          /*******************************************************************************
    425          * Description : Read from an IMU Register
    426          * Input       :
    427          * Return      : -
    428          *******************************************************************************/
    429          uint8_t IMURegRd(uint8_t addr, HwSPI_TypeDef Sensor) {
    430          
    431              uint16_t value;
    432          
    433              SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI); // flush RXNE
    434          
    435              // send register addr
    436              HwSPISSAssert(Sensor);
    437              // With Read Bit set 0x8000
    438              SPI_I2S_SendData(SPI_RADIO_IMU_SPI, 0x8000 | (addr << 8));
    439              // TK_BK_SPI_WAIT_RXRDY();
    440              while (SPI_I2S_GetFlagStatus(SPI_RADIO_IMU_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    441              value = SPI_I2S_ReceiveData(SPI_RADIO_IMU_SPI);
    442              HwSPISSDeAssert(Sensor);
    443          
    444              return (uint8_t)value;
    445          }
    446          /*******************************************************************************
    447          * Description : Reads all the IMU buffered data and averages it
    448          * Input       :
    449          * Return      : - Averaged and packed data according to old ADI format
    450          *                 BK_IMUData.
    451          *******************************************************************************/
    452          static void GetAverageImuData(uint16_t *pBuff)
    453          {
    454            // Get Data from Gyro Buffer
    455            //x__disable_interrupt();
    456            pBuff[0] = ImuGyroBuffer.xSum;
    457            pBuff[1] = ImuGyroBuffer.ySum;
    458            pBuff[2] = ImuGyroBuffer.zSum;
    459            pBuff[3] = ImuAccelBuffer.xSum;
    460            pBuff[4] = ImuAccelBuffer.ySum;
    461            pBuff[5] = ImuAccelBuffer.zSum;
    462            //x__enable_interrupt();
    463          }
    464          
    465          
    466          uint16_t fastdivide250(uint16_t val){
    467            uint32_t x = ((val*0x8312)>>16)>>7;
    468            return (uint16_t) x;
    469          }
    470          /*******************************************************************************
    471          * Description : Inputs the XYZ data into IMU Buffer
    472          * Input       :   Buffer of Data and Buffer
    473          * Return      : -
    474          *******************************************************************************/
    475          static void InputDataIntoBuffer(uint8_t volatile *pImuData)
    476          {
    477          	ImuBuffer_t volatile *pImuBuff = &ImuGyroBuffer;
    478          	pImuBuff->xSum = (*(uint16_t*)&pImuData[6])/250;
    479          	pImuBuff->ySum = (*(uint16_t*)&pImuData[8])/250;
    480          	pImuBuff->zSum = (*(uint16_t*)&pImuData[10])/250;
    481          	pImuBuff->count = 1;
    482          	
    483          	pImuBuff = &ImuAccelBuffer;
    484          	pImuBuff->xSum = *((uint16_t*)&pImuData[0]) >>1;
    485          	pImuBuff->ySum = *((uint16_t*)&pImuData[2]) >>1;
    486          	pImuBuff->zSum = *((uint16_t*)&pImuData[4]) >>1;
    487          	pImuBuff->count = 1;
    488            //x__disable_interrupt();
    489            
    490            
    491            //x__enable_interrupt();
    492          }
    493          
    494          /*******************************************************************************
    495          * Description : Set Configuration
    496          * Input       :
    497          * Return      : -
    498          *******************************************************************************/
    499          static void SetConfig(uint16_t idx, uint32_t val, uint32_t pattern, uint8_t ledBits, uint8_t ledId) {
    500              SAVE_POINT
    501              switch (idx) {
    502                  /*
    503                      0 : productID
    504                      1 : serialNum
    505                      2 : panId
    506                      3 : mySrcAddr
    507                      4 : tkDstAddr
    508                      5 : ledOnOffs
    509                      6 : ledOffOffs
    510                      7 : ledDAC
    511                      8 : rfChan
    512                      9 : led0Id
    513                      A : led1Id
    514                      B : led2Id
    515                      C : TestMode
    516                  */
    517                  case 0x0:
    518                      config.productID = val;
    519                      break;
    520                  case 0x1:
    521                      config.serialNum = val;
    522                      break;
    523                  case 0x2:
    524                      config.panId = val;
    525                      RadioSetPanIdShortAddr(config.panId, config.mySrcAddr);
    526                      break;
    527                  case 0x3:
    528                      config.mySrcAddr = val;
    529                      RadioSetPanIdShortAddr(config.panId, config.mySrcAddr);
    530                      SAVE_POINT
    531                      break;
    532                  case 0x4:
    533                      config.routerDstAddr = val;
    534                      break;
    535                  case 0x5:
    536                      config.ledOnOffs = val;
    537                      break;
    538                  case 0x6:
    539                      config.ledOffOffs = val;
    540                      break;
    541                  case 0x7:
    542                      config.ledDAC = val;
    543                      DAC_SetChannel2Data(DAC_Align_12b_R, val);
    544                      break;
    545                  case 0x8:
    546                      if(val >= OLD_RF_CHANNEL_MIN && val <= OLD_RF_CHANNEL_MAX)
    547                      {
    548                        config.rfChan = val;
    549                        SAVE_POINT
    550                        RadioSetRFChan(val);
    551                      }
    552                      break;
    553                  case 0x9:
    554                      config.led0Id = val;
    555                      break;
    556                  case 0xA:
    557                      config.led1Id = val;
    558                      break;
    559                  case 0xB:
    560                      config.led2Id = val;
    561                      break;
    562                  case 0xC:
    563                    config.TestMode = val;
    564                    break;
    565                  case 0xD:
    566                    config.rfTimeSlot = val;
    567                    SetTimeSlot();
    568                    break;
    569                 case 0xE:
    570                    config.TxLevel = val;
    571                    SAVE_POINT
    572                    RadioSetRFLevel(config.TxLevel);
    573                    SAVE_POINT
    574                    break;
    575              case 0x10:
    576                    config.radioPacketFlags = val;
    577                    break;
    578              case 0x13:
    579                    config.led0IdPattern = pattern;
    580                    config.led0Index = val;
    581                    config.frameBits = ledBits;
    582                    config.led0Id = ledId;
    583                   break;
    584              case 0x14:
    585                    config.led1IdPattern = pattern;
    586                    config.led1Index = val;
    587                    config.frameBits = ledBits;
    588                    config.led1Id = ledId;
    589                    break;
    590              case 0x15:
    591                    config.led2IdPattern = pattern;
    592                    config.led2Index = val;
    593                    config.frameBits = ledBits;
    594                    config.led2Id = ledId;
    595                    break;
    596              case 22:
    597                      if(val >= RF_CHANNEL_MIN && val <= RF_CHANNEL_MAX)
    598                      {
    599                        config.rfChan = val;
    600                        SAVE_POINT
    601                        RadioSetRFChan(val);
    602                      }
    603                      break;
    604          #ifndef OLD_CONFIG
    605              case 24:
    606                    if (val >= DEBOUNCE_MIN && val <= DEBOUNCE_MAX) {
    607                      config.debounce_time = val;
    608                    }
    609                    break;
    610              case 25:
    611                    if (val >= DBLCLICK_MIN_TIME && val <= DBLCLICK_MAX_TIME) {
    612                      config.doubleclick_time = val;
    613                    }
    614                    break;
    615          #endif
    616              default:
    617                      TRACE("**ERROR** Unrecognized Configuration Setting\n\r");
    618                      break;
    619          
    620              }
    621          }
    622          /*******************************************************************************
    623          * Description : Print Configuration
    624          * Input       : -
    625          * Return      : -
    626          *******************************************************************************/
    627          static void PrintConfig(void) {
    628              SAVE_POINT
    629          
    630          
    631          #ifdef _DEBUG
    632              TRACE("\n\r FIRMWARE VERSION: " STRINGIFY(THIS_MAJOR) "." STRINGIFY(THIS_MINOR) "." STRINGIFY(THIS_PATCH) "." STRINGIFY(THIS_REVISION) " BC DEBUG \n\r\n\r");
    633          #else
    634              TRACE("\n\r FIRMWARE VERSION: " STRINGIFY(THIS_MAJOR) "." STRINGIFY(THIS_MINOR) "." STRINGIFY(THIS_PATCH) "." STRINGIFY(THIS_REVISION) " BC RELEASE \n\r\n\r");
    635          #endif
    636              TRACE(" "__DATE__" : "__TIME__" \n\n\r");
    637              TRACE("ARM Serial Number 0x%X,0x%X,0x%X \n\n\r",ARM_proc_SN.a,ARM_proc_SN.b, ARM_proc_SN.c);
    638          
    639              if(IMUPresent){
    640                 TRACE("IMU Present\n\n\r");
    641              }else{
    642                TRACE(" No IMU Installed\n\n\r");
    643              }
    644          
    645          TRACE("[0] productID   : %X\n\r", config.productID);
    646          TRACE("[1] serialNum   : %X\n\r", config.serialNum);
    647          TRACE("[2] panId       : %04X\n\r", config.panId);
    648          TRACE("[3] mySrcAddr   : %04X\n\r", config.mySrcAddr);
    649          TRACE("[4] routerDstAddr   : %04X\n\r", config.routerDstAddr);
    650          TRACE("[5] ledOnOffs   : %X\n\r", config.ledOnOffs);
    651          TRACE("[6] ledOffOffs  : %X\n\r", config.ledOffOffs);
    652          TRACE("[7] ledDAC      : %X\n\r", config.ledDAC);
    653          TRACE("[8] rfChan      : %02X\n\r", config.rfChan);
    654          TRACE("[?] rfTimeSlot  : %02X\n\r", config.rfTimeSlot);
    655          TRACE("[9] led0Id      : %02X\n\r", config.led0Id);
    656          TRACE("[A] led1Id      : %02X\n\r", config.led1Id);
    657          TRACE("[B] led2Id      : %02X\n\r", config.led2Id);
    658          TRACE("[C] TestMode    : %d\n\r", config.TestMode);
    659          TRACE("[J] led0IdPattern : %08X\n\r", config.led0IdPattern);
    660          TRACE("[K] led1IdPattern : %08X\n\r", config.led1IdPattern);
    661          TRACE("[L] led2IdPattern : %08X\n\r", config.led2IdPattern);
    662          TRACE("[M] led0Index : %08X\n\r", config.led0Index);
    663          TRACE("[N] led1Index : %08X\n\r", config.led1Index);
    664          TRACE("[O] led2Index : %08X\n\r", config.led2Index);
    665          TRACE("[Y] frameBits   : %d\n\r", config.frameBits);
    666          TRACE("[Z] Tx RF Level : %X\n\r", TxAmpValues[config.TxLevel]);
    667          TRACE("[X] Radio: %s\n\r", radio_off == 0? "on":"off");
    668          
    669            TRACE("Built on "__DATE__" "__TIME__"\n\r");
    670            TRACE("Flags = 0x%08X \r\n", config.flags);
    671            TRACE("Timer adjust: %d\n\r", config.time_adjust);
    672            TRACE("Timekeeper sync: %s\n\r", use_sync?"yes":"no");
    673            TRACE("No sync timeout sec: %d\n\r", config.frameCountNoSync/10);
    674          #ifndef OLD_CONFIG
    675            TRACE("FrameId 24 bits wrap around: %s\n\r", (config.flags & FLAG_FRAMEID_24BITS)?"yes":"no");
    676            TRACE("Debounce value[1-9]: %u, doubleclick value[1-9]: %u\r\n", config.debounce_time,
    677                  config.doubleclick_time);
    678          #endif
    679          }
    680          
    681          
    682          uint32_t txCalls;
    683          uint32_t txCalls2;
    684          StatusType setRadioTx;
    685          
    686          /*******************************************************************************
    687          * Description : Add Packet to Radio Transmit Queue
    688          * Input       : -
    689          * Return      : 0 if buffer full otherwise just returns payloadSize back
    690          *******************************************************************************/
    691          static uint8_t RadioTxPktQueue(uint16_t dstAddr, uint8_t payloadSize, uint8_t *payload) {
    692              // critical section.
    693              SAVE_POINT
    694          
    695              __disable_interrupt();
    696              if ( ((inIdx + 1) % TX_PKT_QUEUE_SIZE) == outIdx )
    697              {
    698                  __enable_interrupt();
    699                    SAVE_POINT
    700                    return 0; // queue is full => ignore request
    701              }
    702              txCalls++;
    703              txPktQueue[inIdx].dstAddr = dstAddr;
    704              txPktQueue[inIdx].payloadSize = payloadSize;
    705              memcpy((void *)txPktQueue[inIdx].payload, (void *)payload, payloadSize);
    706              inIdx = (inIdx + 1) % TX_PKT_QUEUE_SIZE;
    707          
    708              __enable_interrupt();
    709          
    710              setRadioTx = CoSetFlag(flagRadioTxReq);  // Wake up TX task if it is waiting for sending
    711              txCalls2++;
    712              return payloadSize;
    713          }
    714          
    715          uint32_t calls;
    716          uint32_t pushed_times;
    717          
    718          StatusType semAllowPostTask;
    719          uint8_t semAllow = 0;
    720          
    721          /* PUBLIC FUNCTIONS ----------------------------------------------------------*/
    722          extern uint32_t secs;
    723          
    724          
    725          /*
    726          #define RADIOPACKET_IMU         0x01
    727          #define RADIOPACKET_BUTTONPRESS 0x02
    728          #define RADIOPACKET_BATTERY     0x04
    729          */
    730          typedef enum{
    731            no_msg_flag     = 0x00,
    732            imu_packet_flag = 0x01,
    733            btn_packet_flag = 0x02,
    734            bat_packet_flag = 0x04,
    735            led_packet_flag = 0x08
    736          }packetdatacheck;
    737          
    738          typedef enum{
    739            no_msg =0,
    740            imu_msg=1,
    741            btn_msg=2,
    742            btn_imu_msg=3,
    743            bat_msg=4,
    744            bat_imu_msg=5,
    745            bat_btn_msg=6,
    746            bat_btn_imu_msg=7,
    747            led_msg=8,
    748            led_imu_msg=9,
    749            led_btn_msg=10,
    750            led_btn_imu_msg=11,
    751            led_bat_msg=12,
    752            led_bat_imu_msg=13,
    753            led_bat_btn_msg=14,
    754            led_bat_btn_imu_msg=15
    755          }messagetype;
    756          
    757          
    758          uint8_t filltxbuf(uint8_t messagetype,uint8_t * ptr){
    759            uint8_t size=0;
    760            switch(messagetype){
    761              case  imu_msg:
    762                size = __task1_imu_pack(ptr);
    763                break;
    764              case  btn_msg:
    765                size = __task1_btn_pack(ptr);
    766                break;
    767              case  btn_imu_msg:
    768                size = __task1_btnimu_pack(ptr);
    769                break;
    770              case  bat_msg:
    771                size = __task1_bat_pack(ptr);
    772                break;
    773              case  bat_imu_msg:
    774                size = __task1_batimu_pack(ptr);
    775                break;
    776              case  bat_btn_msg:
    777                size = __task1_batbtn_pack(ptr);
    778                break;
    779              case  bat_btn_imu_msg:
    780                size = __task1_batbtnimu_pack(ptr);
    781                break;
    782              case  led_msg:
    783                size = __task1_led_pack(ptr);
    784                break;
    785              case  led_imu_msg:
    786                size = __task1_ledimu_pack(ptr);
    787                break;
    788              case  led_btn_msg:
    789                size = __task1_ledbtn_pack(ptr);
    790                break;
    791              case  led_btn_imu_msg:
    792                size = __task1_ledbtnimu_pack(ptr);
    793                break;
    794              case  led_bat_msg:
    795                size = __task1_ledbat_pack(ptr);
    796                break;
    797              case  led_bat_imu_msg:
    798                size = __task1_ledbatimu_pack(ptr);
    799                break;
    800              case  led_bat_btn_msg:
    801                size = __task1_ledbatbtn_pack(ptr);
    802                break;
    803              case  led_bat_btn_imu_msg:
    804                size = __task1_ledbatbtnimu_pack(ptr);
    805                break; 
    806              default:
    807                size = 0;
    808                break;  
    809            }
    810            return size;
    811          }
    812          
    813          void fillmsgPreamble(uint8_t*ptr,uint8_t msgtype){
    814            static uint8_t seqNum = 0;
    815            SAVE_POINT
    816          #ifdef msgmethod1
    817            ptr[0]= seqNum;
    818            ptr[1]= msgtype;
    819            ptr[2]= beaconRSSI;
    820            ptr[3]= frameIdAtSync;
    821            ptr[4]= MsTimerAtSync;
    822            ptr[5]= IMUPktNumAtSync;
    823          #else
    824            struct Beacon_Preamble * dataptr;
    825            dataptr = (struct Beacon_Preamble*) ptr;
    826          
    827            dataptr->seq_Num= seqNum;
    828            dataptr->type = msgtype;
    829            dataptr->BeaconRSSI= beaconRSSI;
    830            pBeacon_Data_pkt->SyncFrameIMU=frameIdAtSync;
    831            pBeacon_Data_pkt->MsTimerIMU=MsTimerAtSync;
    832            pBeacon_Data_pkt->IMUPktNum=IMUPktNumAtSync;
    833          #endif
    834            SAVE_POINT
    835            seqNum++;
    836          }
    837          #if 0
    838          void fillmsgIMU(struct BK_IMUData*ptr){
    839            uint16_t * dataptr;
    840            uint8_t i = 0;
    841            uint8_t last_test_imu_pkt_ctr = 255;
    842          
    843            while(i < NUM_OF_IMU_PKTS_IN_RF_PKT){
    844                SAVE_POINT
    845                dataptr = (uint16_t*) &ptr->gyroscopeX;
    846                CoWaitForSingleFlag(flagIMUDataReady,0);
    847                CoClearFlag(flagIMUDataReady);
    848                GetAverageImuData(dataptr);
    849                last_test_imu_pkt_ctr = test_imu_pkt_ctr;
    850                dataptr->Timestamp = test_imu_pkt_ctr;
    851            }
    852            SAVE_POINT
    853          }
    854          #endif
    855          
    856          void fillmsgBTN(uint8_t*ptr){
    857            SAVE_POINT
    858          #ifdef msgmethod1
    859            ptr[0] = btnA.message;      //button A event
    860            ptr[1] = btnB.message;      //button B event
    861            ptr[2] = btnA.sequence;     //button A sequence 
    862            ptr[3] = btnB.sequence;     //button B sequence
    863          #else
    864            struct BK_BTNData * dataptr;
    865            dataptr = (struct BK_BTNData*) ptr;
    866            dataptr->buttonA_events = btnA.message;
    867            dataptr->buttonB_events = btnB.message;
    868            dataptr->buttonA_tick = btnA.sequence;
    869            dataptr->buttonB_tick = btnB.sequence;
    870          #endif
    871            SAVE_POINT
    872            if(btnA.mcount!=0) btnA.mcount--;
    873            if(btnB.mcount!=0) btnB.mcount--;
    874            if(btnA.mcount==0 && btnB.mcount==0){
    875              CoClearFlag(flagBtnDataReady);
    876            }
    877            SAVE_POINT
    878          }
    879          void fillmsgBAT(uint8_t*ptr){
    880          #ifdef msgmethod1
    881            ptr[0] = 0;               //battery_lev
    882            ptr[1] = 0;               //charge_cycle
    883          #else 
    884            struct BK_BATData * dataptr;
    885            dataptr = (struct BK_BATData*) ptr;
    886            dataptr->Battery_lev = 0; //TBA
    887            dataptr->charge_cycle = 0;//TBA
    888          #endif
    889            CoClearFlag(flagBatDataReady);
    890            SAVE_POINT
    891          }
    892          
    893          void fillmsgLED(uint8_t*ptr){
    894            SAVE_POINT
    895          #ifdef msgmethod1
    896            ptr[0]= 0;              //led1id tbd
    897            ptr[1]= 0;              //led2id tbd
    898            ptr[2]= 0;              //led3id tbd
    899            ptr[3]= 0;              //led1stat tbd
    900            ptr[4]= 0;              //led2stat tbd
    901            ptr[5]= 0;              //led3stat tbd
    902          #else 
    903            struct BK_LEDData * dataptr;
    904            dataptr = (struct BK_LEDData*) ptr;
    905            dataptr->led1ID = 0;
    906            dataptr->led2ID = 0;
    907            dataptr->led3ID = 0;
    908            dataptr->led1stat = 0;
    909            dataptr->led2stat = 0;
    910            dataptr->led3stat = 0;
    911          #endif
    912            CoClearFlag(flagLEDDataReady);
    913            SAVE_POINT
    914          }
    915          
    916          static uint8_t __task1_imu_pack(uint8_t * ptr){
    917            struct IMU_Data_pkt *pData_pkt;
    918            pData_pkt = (struct IMU_Data_pkt*) ptr;
    919            uint16_t * pBuf;
    920            uint8_t i=0;
    921            uint8_t last_test_imu_pkt_ctr = 255;
    922          
    923            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_IMU_PacketFrame);
    924            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
    925              SAVE_POINT
    926              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
    927              CoWaitForSingleFlag(flagIMUDataReady, 0);
    928              SAVE_POINT
    929              GetAverageImuData(pBuf);
    930              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
    931              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
    932              ++i;
    933            }
    934            return sizeof(struct IMU_Data_pkt);
    935          }
    936          
    937          static uint8_t __task1_btn_pack(uint8_t * ptr){
    938            struct BTN_Data_pkt *pData_pkt;
    939            pData_pkt = (struct BTN_Data_pkt*) ptr;
    940            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_BTN_PacketFrame);
    941            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
    942          
    943            return sizeof(struct BTN_Data_pkt);
    944          }
    945          
    946          static uint8_t __task1_btnimu_pack(uint8_t * ptr){
    947            struct BTN_IMU_Data_pkt *pData_pkt;
    948            pData_pkt = (struct BTN_IMU_Data_pkt*) ptr;
    949            uint16_t * pBuf;
    950            uint8_t i=0;
    951            uint8_t last_test_imu_pkt_ctr = 255;
    952            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_BTN_IMU_PacketFrame);
    953          
    954            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
    955              SAVE_POINT
    956              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
    957              CoWaitForSingleFlag(flagIMUDataReady, 0);
    958              SAVE_POINT
    959              GetAverageImuData(pBuf);
    960              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
    961              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
    962              ++i;
    963            }
    964            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
    965          
    966            return sizeof(struct BTN_IMU_Data_pkt);
    967          }
    968          
    969          static uint8_t __task1_bat_pack(uint8_t * ptr){
    970            struct BAT_Data_pkt *pData_pkt;
    971            pData_pkt = (struct BAT_Data_pkt*) ptr; 
    972            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_BAT_PacketFrame);
    973          
    974            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
    975          
    976            return sizeof(struct BAT_Data_pkt);
    977          }
    978          
    979          static uint8_t __task1_batimu_pack(uint8_t * ptr){
    980            struct BAT_IMU_Data_pkt *pData_pkt;
    981            pData_pkt = (struct BAT_IMU_Data_pkt*) ptr;
    982            uint16_t * pBuf;
    983            uint8_t i=0;
    984            uint8_t last_test_imu_pkt_ctr = 255;
    985            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_BAT_IMU_PacketFrame);
    986          
    987            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
    988              SAVE_POINT
    989              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
    990              CoWaitForSingleFlag(flagIMUDataReady, 0);
    991              SAVE_POINT
    992              GetAverageImuData(pBuf);
    993              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
    994              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
    995              ++i;
    996            }
    997            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
    998          
    999            return sizeof(struct BAT_IMU_Data_pkt);
   1000          }
   1001          
   1002          static uint8_t __task1_batbtn_pack(uint8_t * ptr){
   1003            struct BAT_BTN_Data_pkt *pData_pkt;
   1004            pData_pkt = (struct BAT_BTN_Data_pkt*) ptr;
   1005            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_BAT_BTN_PacketFrame);
   1006          
   1007            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
   1008            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
   1009          
   1010            return sizeof(struct BAT_BTN_Data_pkt);
   1011          }
   1012          
   1013          static uint8_t __task1_batbtnimu_pack(uint8_t * ptr){
   1014            struct BAT_BTN_IMU_Data_pkt *pData_pkt;
   1015            pData_pkt = (struct BAT_BTN_IMU_Data_pkt*) ptr;
   1016            uint16_t * pBuf;
   1017            uint8_t i=0;
   1018            uint8_t last_test_imu_pkt_ctr = 255;
   1019            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_BAT_BTN_IMU_PacketFrame);
   1020          
   1021            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
   1022              SAVE_POINT
   1023              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
   1024              CoWaitForSingleFlag(flagIMUDataReady, 0);
   1025              SAVE_POINT
   1026              GetAverageImuData(pBuf);
   1027              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
   1028              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
   1029              ++i;
   1030            }
   1031            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
   1032            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
   1033          
   1034            return sizeof(struct BAT_BTN_IMU_Data_pkt);
   1035          }
   1036          
   1037          static uint8_t __task1_led_pack(uint8_t * ptr){
   1038            struct LED_Data_pkt *pData_pkt;
   1039            pData_pkt = (struct LED_Data_pkt*) ptr;
   1040            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_PacketFrame);
   1041          
   1042            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1043          
   1044            return sizeof(struct LED_Data_pkt);
   1045          }
   1046          
   1047          static uint8_t __task1_ledimu_pack(uint8_t * ptr){
   1048            struct LED_IMU_Data_pkt *pData_pkt;
   1049            pData_pkt = (struct LED_IMU_Data_pkt*) ptr;
   1050            uint16_t * pBuf;
   1051            uint8_t i=0;
   1052            uint8_t last_test_imu_pkt_ctr = 255;
   1053            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_IMU_PacketFrame);
   1054          
   1055            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
   1056              SAVE_POINT
   1057              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
   1058              CoWaitForSingleFlag(flagIMUDataReady, 0);
   1059              SAVE_POINT
   1060              GetAverageImuData(pBuf);
   1061              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
   1062              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
   1063              ++i;
   1064            }
   1065            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1066          
   1067            return sizeof(struct LED_IMU_Data_pkt);
   1068          }
   1069          
   1070          static uint8_t __task1_ledbtn_pack(uint8_t * ptr){
   1071            struct LED_BTN_Data_pkt *pData_pkt;
   1072            pData_pkt = (struct LED_BTN_Data_pkt*) ptr;
   1073            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_BTN_PacketFrame);
   1074          
   1075            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
   1076            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1077          
   1078            return sizeof(struct LED_BTN_Data_pkt);
   1079          }
   1080          
   1081          static uint8_t __task1_ledbtnimu_pack(uint8_t * ptr){
   1082            struct LED_BTN_IMU_Data_pkt *pData_pkt;
   1083            pData_pkt = (struct LED_BTN_IMU_Data_pkt*) ptr;
   1084            uint16_t * pBuf;
   1085            uint8_t i=0;
   1086            uint8_t last_test_imu_pkt_ctr = 255;
   1087            
   1088            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_BTN_IMU_PacketFrame);
   1089          
   1090            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
   1091              SAVE_POINT
   1092              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
   1093              CoWaitForSingleFlag(flagIMUDataReady, 0);
   1094              SAVE_POINT
   1095              GetAverageImuData(pBuf);
   1096              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
   1097              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
   1098              ++i;
   1099            }
   1100            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
   1101            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1102          
   1103            return sizeof(struct LED_BTN_IMU_Data_pkt);
   1104          }
   1105          
   1106          static uint8_t __task1_ledbat_pack(uint8_t * ptr){
   1107            struct LED_BAT_Data_pkt *pData_pkt;
   1108            pData_pkt = (struct LED_BAT_Data_pkt*) ptr;  
   1109            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_BAT_PacketFrame);
   1110          
   1111            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
   1112            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1113          
   1114            return sizeof(struct LED_BAT_Data_pkt);
   1115          }
   1116          
   1117          static uint8_t __task1_ledbatimu_pack(uint8_t * ptr){
   1118            struct LED_BAT_IMU_Data_pkt *pData_pkt;
   1119            pData_pkt = (struct LED_BAT_IMU_Data_pkt*) ptr;
   1120            uint16_t * pBuf;
   1121            uint8_t i=0;
   1122            uint8_t last_test_imu_pkt_ctr = 255;
   1123            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_BAT_IMU_PacketFrame);
   1124          
   1125            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
   1126              SAVE_POINT
   1127              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
   1128              CoWaitForSingleFlag(flagIMUDataReady, 0);
   1129              SAVE_POINT
   1130              GetAverageImuData(pBuf);
   1131              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
   1132              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
   1133              ++i;
   1134            }
   1135            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
   1136            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1137          
   1138            return sizeof(struct LED_BAT_IMU_Data_pkt);
   1139          }
   1140          
   1141          static uint8_t __task1_ledbatbtn_pack(uint8_t * ptr){
   1142            struct LED_BAT_BTN_Data_pkt *pData_pkt;
   1143            pData_pkt = (struct LED_BAT_BTN_Data_pkt*) ptr;
   1144            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_BAT_BTN_PacketFrame);
   1145          
   1146            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
   1147            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
   1148            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1149          
   1150            return sizeof(struct LED_BAT_BTN_Data_pkt);
   1151          }
   1152          
   1153          static uint8_t __task1_ledbatbtnimu_pack(uint8_t * ptr){
   1154            struct LED_BAT_BTN_IMU_Data_pkt *pData_pkt;
   1155            pData_pkt = (struct LED_BAT_BTN_IMU_Data_pkt*) ptr; 
   1156            uint16_t * pBuf;
   1157            uint8_t i=0;
   1158            uint8_t last_test_imu_pkt_ctr = 255;
   1159            
   1160            fillmsgPreamble(&pData_pkt->BK_Preamble.Seq_Num,BC_LED_BAT_BTN_IMU_PacketFrame);
   1161            while(i< NUM_OF_IMU_PKTS_IN_RF_PKT){
   1162              SAVE_POINT
   1163              pBuf = (uint16_t*) &pData_pkt->BeaconIMUData[i].gyroscopeX;
   1164              CoWaitForSingleFlag(flagIMUDataReady, 0);
   1165              SAVE_POINT
   1166              GetAverageImuData(pBuf);
   1167              last_test_imu_pkt_ctr = test_imu_pkt_ctr;
   1168              pData_pkt->BeaconIMUData[i].Timestamp = test_imu_pkt_ctr;
   1169              ++i;
   1170            }
   1171            fillmsgBTN((uint8_t*) &pData_pkt->BeaconBTNData.buttonA_events);
   1172            fillmsgBAT((uint8_t*) &pData_pkt->BeaconBATData.Battery_lev);
   1173            fillmsgLED((uint8_t*) &pData_pkt->BeaconLEDData.led1ID);
   1174          
   1175            return sizeof(struct LED_BAT_BTN_IMU_Data_pkt);
   1176          }
   1177          /*******************************************************************************
   1178          * Description    : [Task] Process and Send each new IMU data sample
   1179          * Input          :
   1180          * Return         :
   1181          *******************************************************************************/
   1182          void Task1(void* pdata){
   1183            uint8_t messagetype;
   1184            static uint16_t *pBuf;
   1185            static uint8_t bufsize;
   1186            StatusType err_det;
   1187            static uint32_t target;
   1188          
   1189            while (1) {
   1190              RELOAD_WATCHDOG
   1191              SAVE_POINT
   1192              //wait for a message that came from other tasks
   1193              messagetype = no_msg_flag;
   1194              if(!(config.radioPacketFlags & RADIOPACKET_IMU)){
   1195                target = CoWaitForMultipleFlags(flagIMUDataReady|flagBtnDataReady|flagLEDDataReady|flagBatDataReady,
   1196                                                OPT_WAIT_ANY,     //waits for any of the flags to occur
   1197                                                0,                //wait indefinitely until a flag occurs
   1198                                                &err_det);        //error pointer
   1199                if(target == flagIMUDataReady){
   1200                  messagetype |= imu_packet_flag;   //in case config flag was asserted during waiting period & no other event occurs
   1201                }
   1202              }
   1203              else{
   1204                messagetype |= imu_packet_flag;
   1205              }
   1206              if(CoAcceptSingleFlag(flagBtnDataReady)==E_OK){
   1207                messagetype |= btn_packet_flag;
   1208              }
   1209              if(CoAcceptSingleFlag(flagBatDataReady)==E_OK){
   1210                messagetype |= bat_packet_flag;
   1211              }
   1212              if(CoAcceptSingleFlag(flagLEDDataReady)==E_OK){
   1213                messagetype |= led_packet_flag;
   1214              }
   1215              SAVE_POINT 
   1216              bufsize = filltxbuf(messagetype, txBuf); //Fill out temp buffer with the appropriate data.  
   1217          
   1218              SAVE_POINT
   1219              if(bufsize != 0){     //no message found. for peace of mind.
   1220                CoPendSem(semIMUAllow, 0);
   1221                SAVE_POINT
   1222                calls++;
   1223                uint8_t pushed = 0;
   1224                if (IMUdbgPrt) {         // It is for USB output now
   1225                  __writeIMU((unsigned char*) txBuf, bufsize);
   1226                }
   1227                else {
   1228                  // conditional send based on radio packets flags;
   1229                  if(!(pushed = RadioTxPktQueue(routerAddr, bufsize , txBuf))) {
   1230                     if (config.flags & FLAG_TRACE_IMU_QUEUE_FULL) {
   1231                        TRACE("ERROR! Tx Buffer full\n\r");
   1232                     }
   1233                    SAVE_LINE
   1234                  } else {
   1235                    pushed_times++;
   1236                    SAVE_LINE
   1237                  }
   1238                  SAVE_FUNC
   1239                }
   1240                if (!pushed || radio_off) {
   1241                  semAllowPostTask = CoPostSem(semIMUAllow);
   1242                  semAllow = 2;
   1243                }
   1244              }
   1245              SAVE_POINT
   1246              //last_button_state = pBeacon_Data_pkt->BK_Preamble.button_pr;
   1247              //battery_minutes =  secs/600;
   1248              // reset tasksWDT
   1249              tasksWDT |= 0x0001;
   1250            }
   1251          }
   1252          uint32_t now_sec;
   1253          uint32_t tim;
   1254          uint32_t old_sec;
   1255          uint32_t old_tim;
   1256          
   1257          #ifndef STM3210C_EVAL
   1258          extern OS_EventID semRFRxFrames;
   1259          StatusType task2StatusType;
   1260          uint32_t task2enter;
   1261          uint8_t rx_reload;
   1262          uint32_t rxReloaded;
   1263          uint32_t task2_errors;
   1264          extern uint8_t rxCount;
   1265          
   1266          struct realTime radioRxStart;
   1267          struct realTime radioRxEnd;
   1268          struct realTime radioRxWait;
   1269          
   1270          uint32_t rxTotalRcvd;
   1271          uint32_t rxNotEmpty;
   1272          extern uint32_t rxPackets;
   1273          uint32_t lastTime;
   1274          uint32_t span;
   1275          uint16_t tim4_phase;
   1276          
   1277          int32_t acc_time_adjust;
   1278          uint8_t  acc_adjust_count;
   1279          uint8_t acc_done = 0;
   1280          
   1281          int16_t accs[32];
   1282          struct realTime lastFrameTime;
   1283          extern struct realTime frameTime;
   1284          uint32_t savedFrameIdAtSync;
   1285          uint16_t newTim3Phase, oldTim3Phase, lastTim3Phase;
   1286          extern uint32_t trace_irq;
   1287          uint8_t got_beacon = 0;
   1288          
   1289          extern int frameIdInced;
   1290          
   1291          /*******************************************************************************
   1292          * Description    : [Task] Process Incoming Radio Packets
   1293          * Input          :
   1294          * Return         :
   1295          *******************************************************************************/
   1296          void TaskRadioRx(void* pdata) {
   1297          
   1298              static rxPkt_t *pRxPkt;
   1299              static uint8_t lastFrameClock = 0;
   1300          
   1301              while (1) {
   1302                RELOAD_WATCHDOG
   1303                SAVE_POINT
   1304                radioRxWait.sec = sec;
   1305                radioRxWait.uSec = TIM1->CNT;
   1306                frameIdFlag = 1;
   1307                task2StatusType = CoPendSem(semRFRxFrames, 0);
   1308                SAVE_POINT
   1309                radioRxStart.sec = sec;
   1310                radioRxStart.uSec = TIM1->CNT;
   1311                assert(task2StatusType == E_OK);
   1312          
   1313                SAVE_POINT
   1314                RadioIMU_WaitGrabSPI();
   1315                SAVE_POINT
   1316                if (rxFIFOError) {
   1317                  rxFIFOError = 0;
   1318                  ProcessRXError();
   1319                  pRxPkt = NULL;
   1320                } else {
   1321                  pRxPkt = RadioRxPkt();
   1322                  rxTotalRcvd++;
   1323                }
   1324                SAVE_POINT
   1325          
   1326                radioRxEnd.sec = sec;
   1327                radioRxEnd.uSec = TIM1->CNT;
   1328                RadioIMU_ReleaseSPI();
   1329                if (pRxPkt != NULL) {
   1330                    SAVE_LINE
   1331                    rxNotEmpty++;
   1332                    // Check for Beacon frame types from the TimeKeeper.  Ignore other data packets
   1333                    // from beacons
   1334                      if ((pRxPkt->fcf0 & 0x07) == 0 && pRxPkt->panId == config.panId
   1335                          && (pRxPkt->destAddr == 0xFFFF)) { // FCF[2:0] = 802.15.4 Beacon Frame Type
   1336                            //additional check may be on source address
   1337                          /* RF Sync (Beacon) Packet */
   1338          #ifdef NEW_BEACON
   1339                          /* RF Sync (Beacon) Packet */
   1340                          if (pRxPkt->payloadSize == sizeof(struct BeaconOldStruct)) {
   1341                              //check for new structure
   1342                              // uint32_t frameId
   1343                              // uint8_t  0xA5 //magic for this packet version
   1344                              // uint8_t sec;  // consecutive sec, increments every sec
   1345                              // uint8_t frameClock; //100, 120, 180, 240 support
   1346                              // uint8_t crc8
   1347          
   1348                              struct BeaconOldStruct *beacon = (struct BeaconOldStruct*) pRxPkt->payload;
   1349                              if (beacon->magic != 'BT') {
   1350                                notValids++;
   1351                                TRACE("Beacon received: unknown magic 0x%04X\n\r", beacon->magic);
   1352                                continue;
   1353                              }
   1354                              uint8_t check = crc8(pRxPkt->payload, sizeof(struct BeaconOldStruct) - 1);
   1355                              if (check != beacon->crc8) {
   1356                                notValids++;
   1357                                TRACE("Beacon received: CRC8 failed \r\n");
   1358                                continue;
   1359                              }
   1360                              switch (beacon->frameClock) {
   1361                              case FRAME_CLOCK_100:
   1362                              case FRAME_CLOCK_120:
   1363                              case FRAME_CLOCK_180:
   1364                              case FRAME_CLOCK_240:
   1365                                break;
   1366                              default:
   1367                                TRACE("Beacon received: Unsupported frame clock %d\n\r", beacon->frameClock);
   1368                                notValids++;
   1369                                continue;
   1370                              }
   1371                              static uint32_t lastFrameId = 0;
   1372                              static uint8_t lastTick = 0;
   1373                              static uint8_t changeFrameClock = 0;
   1374                              uint8_t valid = 0;
   1375          
   1376                              if (lastFrameClock == beacon->frameClock ) {
   1377                                if (beacon->tick > lastTick) {
   1378                                  uint32_t diff = beacon->tick - lastTick;
   1379                                  diff *= lastFrameClock;
   1380                                  if ((beacon->frameId - lastFrameId) == diff) {
   1381                                    valid = 1;
   1382                                    if (changeFrameClock) {
   1383                                      // TODO
   1384                                      TRACE("Beacon: changing frameClock to %u\n\r", lastFrameClock);
   1385                                    }
   1386                                    changeFrameClock = 0;
   1387                                  }
   1388                                }
   1389                              } else {
   1390                                changeFrameClock = 1;
   1391                                if (lastFrameId != 0) {
   1392                                  changeClocks++;
   1393                                }
   1394                              }
   1395                              int32_t diffFrameId = beacon->frameId - lastFrameId;
   1396                              uint16_t diffTick = (((uint16_t) beacon->tick + 256) - lastTick)%256;
   1397                              /*Here seems is a problem:
   1398                                When signal weak, it may catch lost sync, then before ticks
   1399                                run off 256 (less then 256 sec later) it catches another sync,
   1400                                by that time frameId may be already off by 1, if it receives consecutive sync
   1401                                it may recover, but if not, it may stack with 1 frame offset.
   1402                              Solution: limit valid span for consecutive syncs to 10 sec,
   1403                               use diffSec*/
   1404                              uint32_t diffSec = diffFrameId/beacon->frameClock;
   1405                              if ((diffTick * beacon->frameClock) == diffFrameId && diffSec < 10) {
   1406                                valid = 1;
   1407                                Valids++;
   1408                              }
   1409                              if (!valid && lastFrameId != 0) {
   1410          
   1411                                  TRACE("New bcn id:%u>%u tick:%u>%u clk:%u>%u\r\n",
   1412                                      lastFrameId, beacon->frameId, lastTick, beacon->tick,
   1413                                      lastFrameClock, beacon->frameClock);
   1414                                newbcn++;
   1415                              }
   1416          
   1417                              if (lastFrameId != beacon->frameId ||
   1418                                  lastFrameClock != beacon->frameClock ||
   1419                                  lastTick != beacon->tick) {
   1420                                    lastFrameId = beacon->frameId;
   1421                                    lastFrameClock = beacon->frameClock;
   1422                                    lastTick = beacon->tick;
   1423                              }
   1424                              if (!valid) {
   1425          
   1426                                continue;
   1427                              }
   1428                            } else /*if (pRxPkt->payloadSize != 4)*/{
   1429                              continue;
   1430                            }
   1431          
   1432          #endif
   1433                        if (use_sync) {
   1434                          got_beacon = 0; //effectively disables frame correction in TIM3 interrupt
   1435                          tim2_phase = TIM2->CCR1;
   1436                          tim3_phase = TIM3->CCR1;
   1437                          trace_irq = 1;
   1438                          TIM2->CCR1 = 0;
   1439                          TIM3->CCR1 = 0;
   1440                          tim4_phase = TIM4->CCR1;
   1441                        }
   1442                          if (firstTime == 1) {
   1443                              TIM_SetAutoreload(TIM3, TIM3_AUTORELOAD);
   1444                              TIM_SetAutoreload(TIM2, TIM_AUTORELOAD);
   1445                              TIM_SetCompare2(TIM3, TIM3_AUTORELOAD - (config.ledOnOffs >> 1));
   1446                              TIM_SetCompare3(TIM3, TIM3_AUTORELOAD - (config.ledOffOffs >> 1));
   1447                              // Instead of modulus maybe boundry check!
   1448                              TIM_SetCompare3(TIM2, ( (uint16_t)(txTimeSlot) ) );
   1449                              // Second 50ms (or half of a TK Tx Beacon interval later) - 3000 (5ms)
   1450                              // 5ms is the combination of the first two time slots which don't get a
   1451                              // Edit -- Can't subtract 5ms off second because it takes 47.5ms before
   1452                              // the next set of 5 IMU packets are ready.  This is a waste of BW.
   1453                              // maybe could use it some other way.
   1454                              // second transmission per frame.
   1455                              TIM_SetCompare4(TIM2, ( (uint16_t)((((TIM_AUTORELOAD + 1) >> 1) + txTimeSlot) - 0) ) );
   1456                              firstTime = 0;
   1457                          }
   1458          
   1459                          // synchronize local to remote FrameIDs
   1460                          if (*(uint32_t*)pRxPkt->payload) { // ignore stale FrameIDs
   1461                            realFrameId = *(uint32_t*)pRxPkt->payload;
   1462                              frameIdCorrection = *(uint32_t*)pRxPkt->payload - frameIdAtSync + frameAdjust;/* - 4*/;//  + 2;
   1463          #ifdef CIRCULAR_LOG
   1464                              __disable_interrupt();
   1465                              W_LOG(CoGetOSTime(), LOG_TYPE_FRAMEADJUST, realFrameId);
   1466                              W_LOG(CoGetOSTime(), LOG_TYPE_CAPTURE, tim3_phase);
   1467                              W_LOG(CoGetOSTime(), LOG_TYPE_FRAMEDIFF, frameIdCorrection);
   1468                              __enable_interrupt();
   1469          #endif
   1470                              int corrected = 0;
   1471          
   1472                              if (/*(frameIdCorrection < 0) &&*/ (tim3_phase > (TIM3_AUTORELOAD >> 1))) {
   1473                                frameIdCorrection++;
   1474                                corrected = 1;
   1475                              }
   1476                              
   1477                              if (config.flags & FLAG_TRACE_SYNC) {
   1478                                TRACE(" Phase=%u inced=%u corr=%d\n\r", tim3_phase, frameIdInced, corrected);
   1479                              }
   1480                              
   1481                              if (config.flags & FLAG_DEBUG) {
   1482                                uint32_t tr = trace_irq;
   1483                                TRACE("trace_irq=%d frIdCor=%d at tim3_phase=%u\n\r", tr, frameIdCorrection, tim3_phase);
   1484                                TRACE("realFrameId=%u frameIdAtSync=%u\n\r", realFrameId, frameIdAtSync);
   1485                              }
   1486                              if (frameIdCorrection != lastFrameIdCorrection || corrected) {
   1487                                oldFrameTime = lastFrameTime;
   1488                                newFrameTime = frameTime;
   1489                                newFrameIdAtSync = frameIdAtSync;
   1490                                oldFrameIdAtSync = savedFrameIdAtSync;
   1491                                newTim3Phase = tim3_phase;
   1492                                oldTim3Phase = lastTim3Phase;
   1493                                
   1494                                if (config.flags & FLAG_TRACE_SYNC) {                      
   1495                                  TRACE("frIdCorr=%d lastFrIdCorr=%d @%d last @%d tim3_ph=%d\r\n", frameIdCorrection,
   1496                                        lastFrameIdCorrection, sec, lastTime, tim3_phase);
   1497                                  TRACE("realFrameId=%u frameIdAtSync=%u\n\r", realFrameId, frameIdAtSync);
   1498                                }
   1499                                
   1500                                if (frameIdCorrection != 0 && sec > 20) {
   1501                                  frameIdCorrectionCount++;
   1502                                }
   1503          
   1504                              } else {
   1505                                static uint8_t seek = 0;
   1506                                uint32_t rsec  = (frameIdAtSync-lastFrameIdAtSync)/lastFrameClock;
   1507                                int32_t cur_diff = (tim3_phase/rsec);
   1508                                lastFrameTime = frameTime;
   1509                                savedFrameIdAtSync = frameIdAtSync;
   1510                                lastTim3Phase = tim3_phase;
   1511          
   1512                              }
   1513                              if (config.flags & FLAG_TRACE_ADJUST) {
   1514                                TRACE("adjust=%d tim3_phase=%u tim4_phase=%u @%d.%d\r\n",
   1515                                      config.time_adjust,
   1516                                      tim3_phase, tim4_phase, sec, TIM1->CNT);
   1517                              }
   1518                              lastFrameIdCorrection = frameIdCorrection;
   1519                              lastFrameIdAtSync = frameIdAtSync;
   1520                              if ((sec - lastTime) > span) {
   1521                                span = sec - lastTime;
   1522                                TRACE("No TK sync for %d sec @ %d\r\n", span, sec);
   1523                              }
   1524                              lastTime = sec;
   1525                              frameOffset = TIM1->CNT;
   1526                              successBeacons++;
   1527                              frameIdFlag = 1;
   1528                              got_beacon = 1;
   1529                          }
   1530          
   1531                          // record RSSI of Sync Packet to relay back to TK
   1532                          beaconRSSI =  0x5A; // temp change to store signature. // pRxPkt->rssi;
   1533          
   1534                          // allow up to 3 tx pkts per sync pkt
   1535                          beaconInSync++;
   1536                          if(beaconInSync > 3)
   1537                          {
   1538                            beaconInSync = 3;
   1539                          }
   1540          
   1541                          //HwLEDToggle(LED4);
   1542                          //HwLEDOn(LED3);
   1543                        // Issue TODO - if Beacon out of syncronization,
   1544                        // it keeps trying to send (Task 6), may not receive
   1545                        // anything, as this task has lower priority
   1546                       //   CoAwakeTask(task1Id);
   1547                       //   CoAwakeTask(taskRadioTxId);
   1548                      }
   1549                } else {
   1550                  if (!radio_off) {
   1551                  TRACE("NULL packet, rxCount=%u @sec=%d\r\n", rxCount, sec);
   1552                  }
   1553                }
   1554              }
   1555          }
   1556          #if 0
   1557          /*******************************************************************************
   1558          * Description    : [Function] controls the targeted button's state machine
   1559          * Input          :
   1560          * Return         :
   1561          *******************************************************************************/
   1562          uint8_t chkbtnstate(tBtn_State *pbtn, uint8_t btnval){
   1563            uint8_t val =0;
   1564            switch(pbtn->state){
   1565              case BTNSTATE_OFF:
   1566                if(btnval == BTNPRESSED){
   1567                  pbtn->state = BTNSTATE_ON;
   1568                  pbtn->hcount=1;
   1569                  pbtn->prevstate=BTNSTATE_OFF;
   1570                }
   1571                break;
   1572              case BTNSTATE_ON:
   1573                if(btnval == BTNPRESSED){
   1574                  pbtn->hcount++;
   1575                  if(pbtn->hcount > 10){
   1576                    pbtn->state = BTNSTATE_HOLD;
   1577                    pbtn->hcount=0;
   1578                  }
   1579                }
   1580                else{
   1581                  pbtn->state = BTNSTATE_PRESSDETECT;
   1582                  pbtn->hcount = 0;
   1583                }
   1584                break;
   1585              case BTNSTATE_HOLD:
   1586                //configure sending message
   1587                //enable sending with holding state.
   1588                if(pbtn->prevstate == BTNSTATE_OFF){
   1589                  pbtn->prevstate = BTNSTATE_HOLD;
   1590                  //val=1;  //let task3 know to send msg. outside SOW;
   1591                  //pbtn->message = BTNMSG_HOLD;
   1592                }
   1593                if(btnval!=BTNPRESSED){
   1594                  pbtn->prevstate = BTNSTATE_OFF;
   1595                  pbtn->state = BTNSTATE_OFF;     //return to initialstate
   1596                  //pbtn->message = BTNMSG_RELEASE;
   1597                } 
   1598                break;
   1599              case BTNSTATE_PRESSDETECT:
   1600                if(btnval==BTNPRESSED){
   1601                //configure sending message to doublepress
   1602                //enable sending with this message
   1603                  //val=1;  //Let task3 know to send msg. ouside SOW;
   1604                  pbtn->prevstate = BTNSTATE_PRESSDETECT;
   1605                  pbtn->state = BTNSTATE_OFF;
   1606                  //pbtn->message = BTNMSG_DBLCLK;
   1607                }
   1608                else{
   1609                //configure sending message to singlepress
   1610                //enable sending with this message
   1611                  val=1;
   1612                  pbtn->prevstate = BTNSTATE_OFF;
   1613                  pbtn->state = BTNSTATE_OFF;
   1614                  pbtn->message = BTNMSG_PRESS;
   1615                  pbtn->mcount = BTN_BURST_SEND;
   1616                }
   1617                //return to initialstate
   1618                break;
   1619              case BTNSTATE_UICTRL:
   1620                break;
   1621            }
   1622            return val;
   1623          }
   1624          #endif
   1625          /*******************************************************************************
   1626          * Description    : [Task] RF Chan Scan, then Monitor GPO_PWRON Power Switch
   1627          * Input          :
   1628          * Return         :
   1629          *******************************************************************************/
   1630          void Task3(void* pdata){
   1631            static uint16_t pwr_holdCount = 0;
   1632            //static uint32_t btnval;
   1633            //static uint8_t btnmsg1;
   1634            //static uint8_t btnmsg2;
   1635            StatusType StatCheck;
   1636            uint8_t msgsend=0;
   1637          
   1638            rfChan = config.rfChan;
   1639            /* search for RF Chan on Power-Up */
   1640            static int wait_cnt = 0;
   1641          
   1642            while (1) {
   1643              RELOAD_WATCHDOG
   1644              SAVE_POINT
   1645              if ((HwGPIState(GPI_SW_PWR))||((BattUnion.BatteryLevel[1])<=0xBB)){
   1646          #ifdef DISABLE_PWR_SW
   1647                pwr_holdCount = 0;
   1648          #endif
   1649                if (pwr_holdCount++ > 2) {
   1650                  CoSchedLock();
   1651                  //HwLEDOff(LED1); HwLEDOff(LED2); HwLEDOff(LED3); HwLEDOff(LED4);HwLEDOff(LED5);
   1652          #ifndef BC_HW_REVB
   1653                  HwGPOLow(GPO_5V_IMU_EN);
   1654                  HwGPOLow(GPO_RF_EN);
   1655                  HwGPOLow(GPO_VBATT_ADC_EN);
   1656                  HwGPOInitOC(GPO_USB_VBUS); // init the Vbus pin as output
   1657                  HwGPOLow(GPO_USB_VBUS);  // and then pull it low to ensure turnoff
   1658          #endif
   1659                  SAVE_POINT
   1660                  HwGPOLow(GPO_PWRON) ; // turn board OFF
   1661                  while (1);
   1662                }
   1663              }
   1664              else{
   1665                pwr_holdCount = 0;
   1666              }
   1667              break;
   1668          		
   1669          		//note that the IMU is already initialized prior to multithread start. it has already been counting.
   1670          		for(wait_cnt =0;wait_cnt < 40; wait_cnt++){
   1671                CoTickDelay(10);
   1672                SAVE_POINT
   1673                if(test_imu_pkt_ctr >= 1) break;      // was > 10. Maybe the IMU interrupt is not enable ... TODO!!! check
   1674              }
   1675              //HwLEDToggle(LED2); HwLEDToggle(LED4);
   1676              assert(test_imu_pkt_ctr >= 1);          // was > 10
   1677              if(test_imu_pkt_ctr >= 1){              // was > 10
   1678                IMUPresent=1;
   1679                break;
   1680              }else{
   1681                IMUPresent=0;
   1682                 //EXTI->IMR &= ~GPI_IMU_DIO1_EXTI_LINE; // kill the interrupt
   1683                halted=1;  // no imu tx
   1684                break;
   1685              }
   1686          	}
   1687            routerAddr = config.routerDstAddr;  // NO RF Scan => send IMU data to TK address stored in FLASH Config
   1688            SetTimeSlot();
   1689            /* we're now in business */
   1690            TRACE("RF CHAN: %d\n\r", rfChan);
   1691          
   1692            CoAwakeTask(task1Id);  // start imu process
   1693            CoAwakeTask(taskRadioRxId);
   1694            CoAwakeTask(taskIMUGId);
   1695            
   1696            btnA.state = BTNSTATE_OFF;
   1697            btnB.state = BTNSTATE_OFF;
   1698          	while (1) {
   1699          		SAVE_POINT
   1700              StatCheck = CoWaitForSingleFlag(flagBTNNewData,100);
   1701          		SAVE_POINT
   1702          		RELOAD_WATCHDOG
   1703          #ifndef DISABLE_PWR_SW
   1704          		if ((HwGPIState(GPI_SW_PWR))||((BattUnion.BatteryLevel[1])<=0xBB)) {
   1705          			if (pwr_holdCount++ > 10) {
   1706          				CoSchedLock();
   1707                  //HwLEDOff(LED1); HwLEDOff(LED2); HwLEDOff(LED3); HwLEDOff(LED4);HwLEDOff(LED5);
   1708                  // This where we should sense if we are connected to the USB charger input
   1709                  // if so...we can't turn off so should go into some sort of low power mode
   1710                  // perhaps set the USB power in as an interrupt so if it goes away we can really shut down
   1711          				HwGPOLow(GPO_5V_IMU_EN);
   1712          				HwGPOLow(GPO_RF_EN);
   1713          				HwGPOLow(GPO_VBATT_ADC_EN);
   1714          				HwGPOInitOC(GPO_USB_VBUS);// init the Vbus pin as output
   1715          				HwGPOLow(GPO_USB_VBUS);// and then pull it low to ensure turnoff
   1716          				HwGPOLow(GPO_PWRON); // turn board OFF
   1717          				while (1);
   1718                }
   1719          		} else {
   1720          			pwr_holdCount = 0;
   1721          		}
   1722          #endif // disable power switch
   1723              SAVE_POINT
   1724              //btnmsg1=0;
   1725              //btnmsg2=0;
   1726          
   1727              if(StatCheck == E_OK){
   1728                //check and prep button msg for txqueue if in msg mode
   1729                //if in main msg mode
   1730                //if(buttonstate == MAIN_MODE){
   1731                if(btnA.message == btnA.update_msg){
   1732                  btnA.message = btnA.update_msg;
   1733                  btnA.mcount = BTN_BURST_SEND;
   1734                  msgsend = 1;
   1735                }
   1736                if(btnB.message == btnB.update_msg){
   1737                  btnB.message = btnB.update_msg;
   1738                  btnB.mcount = BTN_BURST_SEND;
   1739                  msgsend = 1;
   1740                }
   1741                CoClearFlag(flagBTNNewData);
   1742                //}
   1743                //if in ui mode
   1744              }
   1745              if((msgsend)&&config.radioPacketFlags & RADIOPACKET_BUTTONPRESS){ 
   1746                msgsend=0;
   1747                CoSetFlag(flagBtnDataReady);
   1748              }
   1749              SAVE_POINT
   1750              
   1751          #if 0
   1752                  if (IMUdbgPrt) {         // It is for USB output now
   1753                      __writeIMU((unsigned char*) pBeacon_Data_pkt, sizeof(struct Beacon_Data_pkt));
   1754                  }
   1755                  else {
   1756          
   1757                    // conditional send based on radio packets flags;
   1758                    if ((config.radioPacketFlags & RADIOPACKET_IMU)) {
   1759                        if(!(pushed = RadioTxPktQueue(routerAddr, sizeof(struct Beacon_Data_pkt) , txBuf))) {
   1760                          if (config.flags & FLAG_TRACE_IMU_QUEUE_FULL) {
   1761                              TRACE("ERROR! Tx Buffer full\n\r");
   1762                          }
   1763                          SAVE_LINE
   1764                        } else {
   1765                          pushed_times++;
   1766                          SAVE_LINE
   1767                        }
   1768                       SAVE_FUNC
   1769                    }
   1770                  }
   1771                    if (!pushed || radio_off) {
   1772                      semAllowPostTask = CoPostSem(semIMUAllow);
   1773                      semAllow = 2;
   1774                    }
   1775          
   1776                    last_button_state = pBeacon_Data_pkt->BK_Preamble.button_pr;
   1777                    battery_minutes =  secs/600;
   1778                    // reset tasksWDT
   1779                    tasksWDT |= 0x0001;
   1780              }
   1781          #endif
   1782          #if 0
   1783          	  //if(config.radioPacketFlags & RADIOPACKET_BUTTONPRESS && last_button_state != pBeacon_Data_pkt->BK_Preamble.button_pr) 
   1784              //((config.radioPacketFlags & RADIOPACKET_BUTTONPRESS) && (last_button_state != pBeacon_Data_pkt->BK_Preamble.button_pr)
   1785              if (button_state) {
   1786          		  static uint8_t tick;
   1787          		  struct ButtonClick btnClick;
   1788          		  btnClick.button_events = button_state;
   1789          		  btnClick.tick = tick++;
   1790          		  btnClick.type = 0xBC;
   1791          		  btnClick.version = PACKET_VERSION;
   1792          		  btnClick.crc8 = crc8(&btnClick.type, sizeof(btnClick) - 1);
   1793          	  	if (config.flags & FLAG_TRACE_ASYNC) {
   1794          	  		TRACE("BtnClick 0x%02X\r\n", btnClick.button_events);
   1795          	  	}
   1796          	  	RadioTxPktQueue(config.routerDstAddr, sizeof(btnClick), (uint8_t *) &btnClick);
   1797              }
   1798              //Trace to debug
   1799              if ((button_state & BUTTON_A)) {
   1800                if (config.flags & FLAG_TRACE_ASYNC) {
   1801                  switch (button_state & BUTTON_A) {
   1802                    case BUTTON_PRESS:
   1803                      TRACE("Btn A PRESS\r\n");
   1804                      break;
   1805                    case BUTTON_CLICK:
   1806                      TRACE("Btn A CLICK\r\n");
   1807          					  break;
   1808                    case BUTTON_DBLCLICK:
   1809                      TRACE("Btn A dblClick\r\n");
   1810                      break;
   1811                    case BUTTON_RELEASE:
   1812                      TRACE("Btn A Release\r\n");
   1813                      break;
   1814              		}
   1815          		  }
   1816                button_state &= BUTTON_B;
   1817              }
   1818              if ((button_state & BUTTON_B)) {
   1819                if (config.flags & FLAG_TRACE_ASYNC) {
   1820                  switch ((button_state & BUTTON_B) >>4) {
   1821                    case BUTTON_PRESS:
   1822                      TRACE("Btn B PRESS\r\n");
   1823                      break;
   1824                    case BUTTON_CLICK:
   1825                      TRACE("Btn B CLICK\r\n");
   1826                      break;
   1827                    case BUTTON_DBLCLICK:
   1828                      TRACE("Btn B dblClick\r\n");
   1829                      break;
   1830                    case BUTTON_RELEASE:
   1831                      TRACE("Btn B Release\r\n");
   1832                      break;
   1833                  }
   1834                }
   1835                button_state &= BUTTON_A;
   1836              } 
   1837          #endif   
   1838            }
   1839          }
   1840          
   1841          #endif
   1842          
   1843          /*******************************************************************************
   1844          * Description : Write Configuration to FLASH
   1845          * Input       : -
   1846          * Return      : -
   1847          *******************************************************************************/
   1848          #define FLASH_NO_ADDRESS_CHECK
   1849          
   1850          uint32_t WritePage(tPage *page) {
   1851          
   1852            uint8_t *pointer = (uint8_t*) page->address;
   1853            uint32_t result = 0;
   1854            uint16_t cycles = (page->count + 3)/4;
   1855          
   1856            FLASH_Unlock();
   1857          
   1858            do {
   1859          #ifndef FLASH_NO_ADDRESS_CHECK
   1860              if (page->address < APP_UPLOAD_ADDRESS || page->address > 0x803FFFF) {
   1861                page->count = 0;
   1862                result = ERROR_FLASH_ADDRESS;
   1863                break;
   1864              }
   1865          #endif
   1866              if ((result = FLASH_ErasePage(page->address)) != FLASH_COMPLETE) {
   1867                page->count = 0;
   1868                break;
   1869              }
   1870          
   1871              result = 0;
   1872              for (uint16_t i = 0; i < cycles; i++) {
   1873                uint32_t offset = i << 2;
   1874                uint32_t word = page->data[offset + 3] << 24;
   1875                word |= page->data[offset + 2] << 16;
   1876                word |= page->data[offset + 1] << 8;
   1877                word |= page->data[offset];
   1878          
   1879                  if ((result = FLASH_ProgramWord(page->address + offset, word)) != FLASH_COMPLETE) {
   1880                      page->count = offset;
   1881                      break;
   1882                  }
   1883              }
   1884              result = 0;
   1885              // verification
   1886              for (uint16_t i = 0; i < page->count; i++) {
   1887                if (*(pointer) != page->data[i]) {
   1888                  result = ERROR_FLASH_VERIFICATION;
   1889                  page->count = i;
   1890                  break;
   1891                }
   1892                pointer++;
   1893              }
   1894          
   1895            } while (0);
   1896          
   1897            FLASH_Lock();
   1898          
   1899            return result;
   1900          }
   1901          
   1902          #if 1
   1903          
   1904          uint32_t ReadPage(tPage *page) {
   1905          
   1906            uint8_t *pointer = (uint8_t *) page->address;
   1907            uint32_t result = 0;
   1908          
   1909          
   1910            do {
   1911          #ifndef FLASH_NO_ADDRESS_CHECK
   1912              if (page->address < 0x8000000 || page->address > 0x803FFFF) {
   1913                page->count = 0;
   1914                result = ERROR_FLASH_ADDRESS;
   1915                break;
   1916              }
   1917          #endif
   1918              // verification
   1919              for (uint16_t i = 0; i < page->count; i++) {
   1920                page->data[i] = *pointer;
   1921                pointer++;
   1922              }
   1923          
   1924            } while (0);
   1925          
   1926            return result;
   1927          
   1928          }
   1929          #endif
   1930          
   1931          /**
   1932            * @brief  Download a file via serial port
   1933            * @param  None
   1934            * @retval None
   1935            */
   1936          uint8_t tab_1024[1024];
   1937          
   1938          static tPage page = {FLASH_PROD_AREA};
   1939          //static uint32_t CurrentUploadAddress = APP_UPLOAD_ADDRESS;
   1940          static uint16_t CurrentDataPointer = 0x00;
   1941          //static uint8_t mem_data[PAGE_SIZE];
   1942          static uint16_t packet = 0;
   1943          
   1944          static struct PacketHeader *header;
   1945          uint32_t SerialDownload(const char* decoded, uint16_t len, uint8_t type)
   1946          {
   1947            struct FirmwarePacketHeader *frmHeader;
   1948          
   1949            uint8_t copy_len = 0;
   1950          
   1951            uint32_t ret = 0;
   1952            // Data comes in format:
   1953            //U 0 0 DATA\r\n
   1954            // so, DATA starts from 6th index
   1955            do {
   1956              if (len < (sizeof(struct FirmwarePacketHeader))) {
   1957                ret = ERROR_WRONG_PACKET;
   1958                break;
   1959              }
   1960              frmHeader = (struct FirmwarePacketHeader *) (decoded);
   1961              copy_len = header->size - /*7*/ (sizeof(struct PacketHeader) + sizeof(struct FirmwarePacketHeader));
   1962              if (
   1963                  ((type == DEV_CMD_SET_PROD_AREA) &&
   1964                  (copy_len > 128 || (copy_len + CurrentDataPointer) > (FLASH_PROD_AREA + FLASH_PROD_AREA_SIZE)))
   1965                  ||
   1966                  frmHeader->index != packet) {
   1967                ret = ERROR_WRONG_PACKET;
   1968                break;
   1969              }
   1970              if (copy_len) {
   1971                memcpy(&page.data[CurrentDataPointer], (decoded + /*4*/ sizeof(struct FirmwarePacketHeader)), copy_len);
   1972                CurrentDataPointer += copy_len;
   1973                page.count += copy_len;
   1974                if ((frmHeader->index + 1) == frmHeader->count || CurrentDataPointer == sizeof(page.data)) {
   1975                  //time to write
   1976                  WritePage(&page);
   1977                  page.address = FLASH_PROD_AREA;
   1978                  CurrentDataPointer = 0;
   1979                  page.count = 0;
   1980                  if ((frmHeader->index + 1) == frmHeader->count) {
   1981                    // finished
   1982                    page.address = FLASH_PROD_AREA;
   1983                  }
   1984                }
   1985              }
   1986              ret = frmHeader->index << 16;
   1987            } while (0);
   1988            // reset for error
   1989            if (ret & 0xFFFF) {
   1990              CurrentDataPointer = 0;
   1991              page.address = FLASH_PROD_AREA;
   1992              page.count = 0;
   1993              packet = 0;
   1994            } else {
   1995              packet++;
   1996            }
   1997            return ret;
   1998          }
   1999          
   2000          tPage page;
   2001          extern uint16_t tim3_at_radio;
   2002          uint16_t use_tim3_phase = 0;
   2003          
   2004          /*******************************************************************************
   2005          * Description    : [Task] Implements Simple Text Command Console
   2006          * Input          :
   2007          * Return         :
   2008          *******************************************************************************/
   2009          void TaskConfig(void* pdata) {
   2010              static char buff[512] = "";
   2011              char *s = buff;
   2012          //    static int i;
   2013              static char cmd;
   2014              static int addr;
   2015              static int32_t value;
   2016          
   2017              while (1) {
   2018                  SAVE_POINT
   2019                  // get a line of values from stdin
   2020                  s = buff;
   2021                  mygets(s); 	
   2022                  if (ValidateCommandLine(s, strlen(s)) == 0) {
   2023                    TRACE("Incorrect packet\r\n");
   2024                    continue;
   2025                  }
   2026                      
   2027                  SAVE_POINT
   2028                  RELOAD_WATCHDOG
   2029                  // parse the line of hexadecimal values
   2030                  //i = sscanf(s, "%c %d %d", &cmd, &addr, &value);
   2031                  //if (i < 1) continue;
   2032                  cmd = *s;
   2033                  switch (cmd) {
   2034                      case '2':
   2035                        RadioPrint2520Registers(addr);
   2036                        SAVE_POINT
   2037                          break;
   2038                      case 'd': // Display configuration
   2039                          //if (i != 1) continue;
   2040                          PrintConfig();
   2041                          SAVE_POINT
   2042                          break;
   2043                      case '1':
   2044                          // Test Reading IMU DMA frame   // TODO!!! IMU accessing must be critical section
   2045                          CoClearFlag(flagIMUNewData);
   2046                          
   2047          				RadioIMU_WaitGrabSPI();
   2048          				IMUProcess();
   2049                          TRACE("%X, %X, %X\n\r",*(uint16_t*)&IMU_RawData[0], *(uint16_t*)&IMU_RawData[2], *(uint16_t*)&IMU_RawData[4]);
   2050                          TRACE("%X, %X, %X\n\r",*(uint16_t*)&IMU_RawData[6], *(uint16_t*)&IMU_RawData[8], *(uint16_t*)&IMU_RawData[10]);
   2051                          SAVE_POINT
   2052          				RadioIMU_ReleaseSPI();
   2053                          SAVE_POINT
   2054                          break;
   2055                      case 's': // Set configuration
   2056                        {
   2057                            uint32_t      pattern = 0;
   2058                            uint8_t       ledBits = 0;
   2059                            uint8_t       ledId  = 0;
   2060                         // if (addr >= 19 && addr <= 21) {
   2061                            //need to do additional scanf - it has form of
   2062                            //s 19 8bit 32bit 8bit
   2063                            // all values are decimal
   2064                            //uint8_t       ledId = value;
   2065                            char *p = s;
   2066                            //skip s addr value
   2067                            while (*p != 0 &&!isspace(*p)) { p++;} p++;
   2068                            addr = strtoul(p, NULL, 10);
   2069                            while (*p != 0 &&!isspace(*p)) { p++;} p++;
   2070                            value = strtoul(p, NULL, 10);
   2071                            while (*p != 0 &&!isspace(*p)) { p++;} p++;
   2072                            pattern = strtoul(p, NULL, 10);
   2073                            while (*p != 0 &&!isspace(*p)) { p++;} p++;
   2074                            ledBits = strtoul(p, NULL, 10);
   2075                            while (*p != 0 &&!isspace(*p)) { p++;} p++;
   2076                            ledId = strtoul(p, NULL, 10);
   2077                         // }
   2078                          SetConfig(addr, value,  pattern, ledBits, ledId);
   2079                        }
   2080                          SAVE_POINT
   2081                          break;
   2082                      case 'v': // saVe configuration
   2083                          //if (i != 1) continue;
   2084                          SaveConfig(&config);
   2085                          break;
   2086                      case 'h': // Halt IMU Tx
   2087                          //if (i != 1) continue;
   2088                          //EXTI->IMR &= ~GPI_IMU_DIO1_EXTI_LINE;
   2089          				EXTI->IMR &= ~GPI_IMU_INT_EXTI_LINE;
   2090                          halted = 1;
   2091                          break;
   2092                      case 'c': // Continue IMU Tx
   2093                          //if (i != 1) continue;
   2094                          //EXTI->IMR |= GPI_IMU_DIO1_EXTI_LINE;
   2095                          //EXTI->IMR |= GPI_IMU_DIO2_EXTI_LINE;
   2096                          EXTI->IMR |= GPI_IMU_INT_EXTI_LINE;
   2097          				halted = 0;
   2098                          break;
   2099          #if 0
   2100                      case 'w': // Write IMU_A-Reg
   2101                          //if (i != 3) continue;
   2102                          //CoTickDelay(2);
   2103                          IMURegWr(addr, SPI_A_IMU, value);
   2104                          break;
   2105                      case 'r': // Read IMU_A-Reg
   2106                          //if (i != 2) continue;
   2107                          //CoTickDelay(2);
   2108                          TRACE("Accel Reg%02X = %04X\n\r", addr, (int)IMURegRd(addr, SPI_A_IMU));
   2109                          break;
   2110                      case 'W': // Write IMU_G-Reg
   2111                          //if (i != 3) continue;
   2112                          //CoTickDelay(2);
   2113                          IMURegWr(addr, SPI_G_IMU, value);
   2114                          break;
   2115                      case 'R': // Read IMU_G-Reg
   2116                          //if (i != 2) continue;
   2117                          //CoTickDelay(2);
   2118                          TRACE("Gyro Reg%02X = %04X\n\r", addr, (int)IMURegRd(addr, SPI_G_IMU));
   2119                          break;
   2120          #endif
   2121                      case '-':  // dec Tx power
   2122                         if(config.TxLevel ==0 ||config.TxLevel > 8 ){
   2123                          config.TxLevel =8; // sizeof(uint8_t TxAmpValues);
   2124                          }else{
   2125                            config.TxLevel--;
   2126                          }
   2127                          RadioSetRFLevel(config.TxLevel);
   2128                         SAVE_POINT
   2129                          TRACE("RF Tx Level: %X\n\r", TxAmpValues[config.TxLevel]);
   2130                          break;
   2131                      case '+':  // increment Tx power
   2132                          if(config.TxLevel >= 8){
   2133                          config.TxLevel = 0; // sizeof(uint8_t TxAmpValues);
   2134                          }else{
   2135                            config.TxLevel++;
   2136                          }
   2137                          RadioSetRFLevel(config.TxLevel);
   2138                          SAVE_POINT
   2139                          TRACE("RF Tx Level: %X\n\r", TxAmpValues[config.TxLevel]);
   2140                          break;
   2141                  case '.': // IMU debug print
   2142                           //if (i != 1) continue;
   2143                           TRACE("IMU Debug print:\n\r");
   2144                           IMUdbgPrt = !IMUdbgPrt;
   2145                            break;
   2146          
   2147                  case 'y': // Serial Number printout
   2148                           //if (i != 1) continue;
   2149                           TRACE("CPU Serial #%04x:%04x:%04x \n\r",ARM_proc_SN.a,ARM_proc_SN.b,ARM_proc_SN.c );
   2150                            break;
   2151                  case 'F':
   2152                    TRACE("Framebits: %d\r\n", config.frameBits);
   2153                    break;
   2154          #if 0
   2155                  case '~':  // reset default settings
   2156                      TRACE("Restoring Default Settings \n\r");
   2157                      memcpy((void *)&config, (void *)&backup_config, sizeof(config));
   2158                      break;
   2159          #endif
   2160                  case 't':   // trace / debug
   2161                      {
   2162                        char *p = NULL;
   2163                          while (*s && isspace(*(++s)));
   2164                                 if (!*s) {
   2165                                   break;
   2166                                 }
   2167                              addr = strtoul(s, &p, 10);
   2168                          while (*p && isspace(*(++p)));
   2169                                 if (*p) {
   2170                                  value = strtoul(p, NULL, 10);
   2171                                 } else {
   2172                                  value = 0;
   2173                                 }
   2174                          switch (addr) {
   2175                                          case 0:
   2176                            {
   2177                              config.flags ^= FLAG_TRACE_ENABLE;
   2178                            }
   2179                            break;
   2180                          case 1:
   2181                            {
   2182                              config.flags ^= FLAG_TRACE_TIMESLOT;
   2183                            }
   2184                          break;
   2185                          case 2:
   2186                            {
   2187                              config.flags ^= FLAG_TRACE_SYNC;
   2188                            }
   2189                            break;
   2190                          case 3:
   2191                            {
   2192                              config.flags ^= FLAG_TRACE_IMU_QUEUE_FULL;
   2193                            }
   2194                            break;
   2195                          case 4:
   2196                            {
   2197                              config.flags ^= FLAG_TRACE_USE_TIMESLOT;
   2198                            }
   2199                            break;
   2200                          case 5:
   2201                            {
   2202                              config.flags ^= FLAG_TRACE_USE_PROTO_CMD_LINE_RESP;
   2203                            }
   2204                            break;
   2205                          case 6:
   2206                            {
   2207                              // radio off
   2208                              radio_off = 1;
   2209                            }
   2210                            break;
   2211                          case 7:
   2212                            {
   2213                              // radio on
   2214                              radio_off = 0;
   2215                            }
   2216                            break;
   2217                          case 8:
   2218                            {
   2219                              struct WhoAmI me;
   2220                              memcpy(me.id, (uint8_t *)(0x1FFFF7E8), 12);
   2221                              me.type = 3; // beacon
   2222                              me.module = 2;
   2223                              __writeCmdLineRespPacket((void *)&me,  sizeof(me), DEV_RESP_WHOAMI);
   2224                            }
   2225                            break;
   2226                          case 9:
   2227                            {
   2228                              config.flags ^= FLAG_TRACE_BEACON;
   2229                            }
   2230                            break;
   2231                          case 10:
   2232                            {
   2233                              config.flags ^= FLAG_TRACE_ASYNC;
   2234                            }
   2235                            break;
   2236                          case 11:
   2237                            {
   2238                              config.flags ^= FLAG_TRACE_CRC;
   2239                            }
   2240                            break;
   2241                          case 12:
   2242                            {
   2243                              //send_battery_info = 0;
   2244                              config.flags &= ~FLAG_SEND_BATTERY_INFO;
   2245                            }
   2246                            break;
   2247                          case 13:
   2248                            {
   2249                              //send_battery_info = 1;
   2250                              config.flags |= FLAG_SEND_BATTERY_INFO;
   2251                            }
   2252                            break;
   2253                          case 17: {
   2254                              config.time_adjust = (int16_t) value;
   2255                              //I2C_EE_BufferWrite((uint8_t*) &time_adjust, 126, 2);
   2256                              SaveConfig(&config);
   2257                              whole_time_adjust = config.time_adjust/10;
   2258                              part_time_adjust = config.time_adjust%10;
   2259                            }
   2260                          case 18:
   2261                            {
   2262                              use_sync = 0;
   2263                            }
   2264                            break;
   2265                          case 19:
   2266                            {
   2267                              use_sync = 1;
   2268                            }
   2269                            break;
   2270                          case 20:
   2271                            {
   2272                              config.frameCountNoSync = value;
   2273                              SaveConfig(&config);
   2274                            }
   2275                            break;
   2276                          case 41:
   2277                          {
   2278                            use_tim3_phase = value;
   2279                            break;
   2280                          }
   2281                          case 42:
   2282                            {
   2283                              config.flags ^= FLAG_DEBUG;
   2284                            }
   2285                            break;
   2286                          case 43:
   2287                            {
   2288                              TRACE("oldFrameTime @%d.%d frame=%u, tim3_at_radio=%u\n\r", oldFrameTime.sec, oldFrameTime.uSec, oldFrameIdAtSync, tim3_at_radio);
   2289                              TRACE("newFrameTime @%d.%d frame=%u MsTimerAtSync=%u\n\r", newFrameTime.sec, newFrameTime.uSec, newFrameIdAtSync, MsTimerAtSync);
   2290                              TRACE("oldTim3Phase=%u newTim3Phase=%u tim_at_sec=%u\n\r", oldTim3Phase, newTim3Phase, tim_at_sec);
   2291                            }
   2292                            break;
   2293                          case 44:
   2294                            {
   2295                              config.flags |= FLAG_TRACE_ADJUST;
   2296                            }
   2297                          break;
   2298                          case 45:
   2299                            {
   2300                              config.flags &= ~FLAG_TRACE_ADJUST;
   2301                            }
   2302                          break;
   2303                          case 46:
   2304                            {
   2305                              TRACE("rxPkts=%u rxTotal=%u rxNotEmpty=%u sec=%u\r\n", rxPackets, rxTotalRcvd, rxNotEmpty, sec);
   2306                            }
   2307                            break;
   2308                          case 47:
   2309                            {
   2310                              frameAdjust = (int8_t) value;
   2311                            }
   2312                            break;
   2313                          case 48:
   2314                            {
   2315                              config.flags ^= FLAG_FRAMEID_24BITS;
   2316                              SaveConfig(&config);
   2317                            }
   2318                            break;
   2319                          case 49:
   2320                            {
   2321                              TRACE(": rxWait @ %d.%d rxStart @ %d.%d\n\r", radioRxWait.sec, radioRxWait.uSec, radioRxStart.sec, radioRxStart.uSec);
   2322                              TRACE(": txStart @ %d.%d txEnd @ %d.%d queue_full=%d queue_size=%d\n\r", startRadioTx.sec, startRadioTx.uSec, endRadioTx.sec, endRadioTx.uSec, queue_full, inIdx);
   2323                              TRACE(": rxCount=%d rxFIFOError=%d rxErrors=%d\n\r", rxCount, rxFIFOError, rxErrors);
   2324                              CoTickDelay(10);
   2325                              TRACE(": rxFIFOTime %d.%d semTime2 %d.%d\n\r", rxFIFOTime.sec, rxFIFOTime.uSec, semTime2.sec, semTime2.uSec);
   2326                              TRACE(": excFlag0=0x%02X excFlag1=0x%02X excFlag2=0x%02X\n\r",cc2520_flags0, cc2520_flags1, cc2520_flags2);
   2327                              TRACE(": successBeacons=%d frameOffset=%d frameAdjust=%d\n\r", successBeacons, frameOffset, frameAdjust);
   2328                              TRACE(": remainOutOfSyncTime=%d frameIdCorrection=%d\n\r", remainOutOfSyncTime, lastFrameIdCorrection);
   2329                              CoTickDelay(10);
   2330                              TRACE(": realFrameId=%d lastFrIdAtSync=%d asserted=%d\r\n", realFrameId, lastFrameIdAtSync, asserted);
   2331                              TRACE("errorFrameId=%u valids=%d notValids=%d lostSync=%d\r\n", errorFrameId, Valids, notValids, lostSync);
   2332                              TRACE("changeClocks=%d newbcn=%d corCount=%d drifts=%u last_drift=%d\r\n", changeClocks, newbcn, frameIdCorrectionCount, drift, last_drift);
   2333                             extern uint8_t led_blinking;
   2334                              TRACE("led blinking=%d\r\n", led_blinking);
   2335                            }
   2336                            break;
   2337                          case 50:
   2338                            {
   2339                              switch (value) {
   2340                              case 2:
   2341                                //HwLEDToggle(LED2);
   2342                                break;
   2343                              case 3:
   2344                                //HwLEDToggle(LED3);
   2345                                break;
   2346                              case 4:
   2347                                //HwLEDToggle(LED4);
   2348                                break;
   2349                              default:
   2350                                //HwLEDToggle(LED1);
   2351                              }
   2352                            }
   2353                            break;
   2354                          case 52:
   2355                            {
   2356                              uint32_t ram = (uint32_t) value & 0xFFFFFFFE;
   2357                              if (ram >= 0x20000000 && ram <= 0x2000ffff) {
   2358                                uint32_t atRam = *((uint32_t*) (ram));
   2359                                TRACE("Mem at 0x%08X=0x%08X\n\r", ram, atRam);
   2360                              } else {
   2361                                TRACE("Mem addr error\n\r");
   2362                              }
   2363                            }
   2364                            break;
   2365                          case 54:
   2366                            {
   2367                              RadioPrint2520Registers(addr);
   2368                            }
   2369                            break;
   2370                          case 55:
   2371                            {
   2372                              if (value > 0 && value < 30000) {
   2373                                txTimeSlot = value;
   2374                                firstTime = 1;
   2375                                TRACE("New timeslot offset = %u\r\n", txTimeSlot);
   2376                              }
   2377                            }
   2378                            break;
   2379          #ifdef CIRCULAR_LOG
   2380                          case 56:
   2381                            {
   2382                              uint16_t indx = 0;
   2383                              uint16_t size = (LOG_SIZE/sizeof(tLogStruct));
   2384                              TRACE("Current SysTickCount: %d, size=%d\n\r", (uint32_t) CoGetOSTime(), LOG_SIZE/sizeof(tLogStruct));
   2385                              for (; (indx < size) && (log[indx].type); indx++) {
   2386                                if ((indx & 0x07 == 0)) {
   2387                                  CoTickDelay(20);
   2388                                }
   2389                                TRACE(":%u @%u t:%d d:%u\n\r", indx, log[indx].timestamp, log[indx].type, log[indx].frameId);
   2390                                CoTickDelay(2);
   2391                              }
   2392                            }
   2393                            break;
   2394                          case 57:
   2395                            {
   2396                              if (value ==1313) {
   2397                                __disable_interrupt();
   2398                                memset((void*) log, 0, LOG_SIZE);
   2399                                log_index_in = 0;
   2400                                __enable_interrupt();
   2401                                TRACE("Erased\n\r");
   2402                              } else {
   2403                                TRACE("ooopss.. wrong value\n\r");
   2404                              }
   2405                            }
   2406                            break;
   2407          #endif
   2408          
   2409                          case 94:
   2410                            {
   2411                              if (value == 16385) {
   2412                                TRACE("Generating hard fault\r\n");
   2413                                CoTickDelay(100);
   2414                                uint32_t *p = (uint32_t*) 0xDE002319;
   2415                                uint32_t j = *p;
   2416                              }
   2417                            }
   2418                            break;
   2419                          case 95:
   2420                            {
   2421                              watchdog_active = value;
   2422                              TRACE("Watchdog is %s\r\n", value?"active":"not active");
   2423                            }
   2424                            break;
   2425                          case 96:
   2426                            {
   2427                              extern uint32_t stacked_lr, stacked_pc, stacked_psr;
   2428                              uint32_t saved_lr, saved_pc, saved_psr;
   2429                              uint32_t fault_counter;
   2430                              I2C_EE_BufferRead((uint8_t*) &saved_lr, EEPROM_DEBUG_STACKED_LR, EEPROM_DEBUG_STACKED_LR_SIZE);
   2431                              I2C_EE_BufferRead((uint8_t*) &saved_pc, EEPROM_DEBUG_STACKED_PC, EEPROM_DEBUG_STACKED_PC_SIZE);
   2432                              I2C_EE_BufferRead((uint8_t*) &saved_psr, EEPROM_DEBUG_STACKED_PSR, EEPROM_DEBUG_STACKED_PSR_SIZE);
   2433                              I2C_EE_BufferRead((uint8_t*) &fault_counter, EEPROM_DEBUG_COUNTER, EEPROM_DEBUG_COUNTER_SIZE);
   2434          
   2435                              TRACE("stacked_lr=0x%08X stacked_pc=0x%08X\r\n",
   2436                                    stacked_lr, stacked_pc);
   2437                              TRACE("stacked_psr=0x%08X saved_lr=0x%08X\r\n",
   2438                                    stacked_psr, saved_lr);
   2439                              TRACE("saved_pc=0x%08X saved_psr=0x%08X\r\n", saved_pc, saved_psr);
   2440                              TRACE("fault_counter = %u\r\n", fault_counter);
   2441                            }
   2442                            break;
   2443                          case 97:
   2444                            {
   2445                              stacked_lr = stacked_pc = stacked_psr = 0;
   2446                            }
   2447                          break;
   2448          #ifdef TASKS_PROFILE
   2449                          case 98:
   2450                            {
   2451                                __disable_interrupt();
   2452                                uint32_t stack1              = CoGetStackDepth(task1Id);
   2453                                uint32_t perfTask1           = CoGetTaskScheduledCount(task1Id);
   2454                                uint16_t lineTask1           = CoGetTaskLine(task1Id);
   2455                                const char *funcTask1        = CoGetTaskFunc(task1Id);
   2456                                uint32_t stackRadioRx        = CoGetStackDepth(taskRadioRxId);
   2457                                uint32_t perfRadioRx         = CoGetTaskScheduledCount(taskRadioRxId);
   2458                                uint16_t lineRadioRx         = CoGetTaskLine(taskRadioRxId);
   2459                                const char *funcRadioRx      = CoGetTaskFunc(taskRadioRxId);
   2460                                uint32_t stack3              = CoGetStackDepth(task3Id);
   2461                                uint32_t perfTask3           = CoGetTaskScheduledCount(task3Id);
   2462                                uint16_t lineTask3           = CoGetTaskLine(task3Id);
   2463                                const char *funcTask3        = CoGetTaskFunc(task3Id);
   2464          
   2465                                uint32_t stackConfig         = CoGetStackDepth(taskConfigId);
   2466                                uint32_t perfTaskConfig      = CoGetTaskScheduledCount(taskConfigId);
   2467                                uint16_t lineTaskConfig      = CoGetTaskLine(taskConfigId);
   2468                                const char *funcTaskConfig   = CoGetTaskFunc(taskConfigId);
   2469                                uint32_t stackRadioTx        = CoGetStackDepth(taskRadioTxId);
   2470                                uint32_t perfRadioTx         = CoGetTaskScheduledCount(taskRadioTxId);
   2471                                uint16_t lineRadioTx         = CoGetTaskLine(taskRadioTxId);
   2472                                const char *funcRadioTx      = CoGetTaskFunc(taskRadioTxId);
   2473          
   2474                                uint32_t stack8              = CoGetStackDepth(task8Id);
   2475                                uint32_t perfTask8           = CoGetTaskScheduledCount(task8Id);
   2476                                uint16_t lineTask8           = CoGetTaskLine(task8Id);
   2477                                const char *funcTask8        = CoGetTaskFunc(task8Id);
   2478                                uint32_t stackIMU            = CoGetStackDepth(taskIMUGId);
   2479                                uint32_t perfTaskIMU         = CoGetTaskScheduledCount(taskIMUGId);
   2480                                uint16_t lineTaskIMU         = CoGetTaskLine(taskIMUGId);
   2481                                const char *funcTaskIMU      = CoGetTaskFunc(taskIMUGId);
   2482          
   2483                                __enable_interrupt();
   2484          
   2485          
   2486                                TRACE("Task1 [avail stack:%d]:%d @ %s():%d\n\r", stack1, perfTask1, funcTask1, lineTask1);
   2487                                TRACE("RadioRxTask [avail stack:%d]:%d @ %s():%d\n\r", stackRadioRx, perfRadioRx, funcRadioRx, lineRadioRx);
   2488                                TRACE("Task3 [avail stack:%d]:%d @ %s():%d\n\r", stack3, perfTask3, funcTask3, lineTask3);
   2489                                TRACE("TaskConfig [avail stack:%d]:%d @ %s():%d\n\r", stackConfig, perfTaskConfig, funcTaskConfig, lineTaskConfig);
   2490                                TRACE("RadioTxTask [avail stack:%d]:%d @ %s():%d\n\r", stackRadioTx, perfRadioTx, funcRadioTx, lineRadioTx);
   2491                                TRACE("Task8 [avail stack:%d]:%d @ %s():%d\n\r", stack8, perfTask8, funcTask8, lineTask8);
   2492                                TRACE("TaskIMU [avail stack:%d]:%d @ %s():%d\n\r", stackIMU, perfTaskIMU, funcTaskIMU, lineTaskIMU);
   2493          
   2494                          }
   2495                          break;
   2496                          case 99:
   2497                            {
   2498                            uint32_t scheduled_idle = CoGetTaskScheduledCount(0);
   2499                            uint32_t scheduled_task1 = CoGetTaskScheduledCount(task1Id);
   2500                            uint32_t scheduled_taskRadioRx = CoGetTaskScheduledCount(taskRadioRxId);
   2501                            uint32_t scheduled_task3 = CoGetTaskScheduledCount(task3Id);
   2502                            uint32_t scheduled_taskConfig = CoGetTaskScheduledCount(taskConfigId);
   2503                            uint32_t scheduled_taskRadioTx = CoGetTaskScheduledCount(taskRadioTxId);
   2504                            uint32_t scheduled_task8 = CoGetTaskScheduledCount(task8Id);
   2505                            uint32_t scheduled_taskIMU_G = CoGetTaskScheduledCount(taskIMUGId);
   2506                            TRACE("PERF: IdleTask: %u Task1: %u RxTask: %u Task3: %u\n\r",
   2507                                  scheduled_idle, scheduled_task1, scheduled_taskRadioRx, scheduled_task3);
   2508                            TRACE("PERF: TaskConfig: %u TxTask: %u\n\r",
   2509                                  scheduled_taskConfig, scheduled_taskRadioTx);
   2510                            TRACE("PERF: Task8: %u TaskIMU: %u\n\r", scheduled_task8, scheduled_taskIMU_G);
   2511                          }
   2512                          break;
   2513          #endif
   2514                          }
   2515                      }
   2516                      break;
   2517                  case 'U':
   2518                      {       // Extended command line that use base64 encoded parameters
   2519                          static uint8_t encoded[512];
   2520                          static uint8_t decoded[512];
   2521                          //uint8_t *_decoded = &decoded[0];
   2522                          uint16_t update_flags = 0;
   2523                          char *p = NULL;
   2524                          while (*s && isspace(*(++s)));
   2525                          if (!*s) {
   2526                            break;
   2527                          }
   2528          
   2529                          addr = strtoul(s, &p, 10);
   2530                          s = p;
   2531                          while (*s && isspace(*(++s)));
   2532                          if (!*s) {
   2533                            break;
   2534                          }
   2535                          uint16_t value = strtoul(s, &p, 10);
   2536                          s = p;
   2537                          while (*s && isspace(*(++s)));
   2538                          if (!*s) {
   2539                            break;
   2540                          }
   2541                          strcpy((char*) encoded, s);
   2542                          int ret = b64_pton(encoded, decoded, sizeof(decoded));
   2543          
   2544                          if (ret < sizeof(struct PacketHeader)) {
   2545                              TRACE("Incorrect packet\r\n");
   2546                              continue;
   2547                          }
   2548                          struct PacketHeader *packetHeader = (struct PacketHeader *)decoded;
   2549                          if (packetHeader->size > ret) {
   2550                              TRACE("Incorrect packet size\r\n");
   2551                              continue;
   2552                          }
   2553          				if (ValidateCommandLine((char*)decoded, ret) == 0) {
   2554                              TRACE("Incorrect packet\r\n");
   2555                              continue;
   2556          				}                
   2557          
   2558                          if (packetHeader->type == DEV_CMD_BAT_STATUS) {
   2559          
   2560                            __writeCmdLineRespPacket((void*) &lastBatStatus, sizeof(lastBatStatus), DEV_RESP_BAT_STATUS);
   2561                          } else if (packetHeader->type == DEV_CMD_CONFIG_REQ) {
   2562                              ex_config_t my_config;
   2563                              CopyConfigToExConfig(&config, &my_config);
   2564                              my_config.checksum = CalcConfigChecksum(&my_config.productID, my_config.size);
   2565                              __writeCmdLineRespPacket((void *)&my_config,  sizeof(my_config), DEV_RESP_CONFIG);
   2566                          } else if(packetHeader->type == DEV_CMD_GET_VERSION) {
   2567                             struct RespFirmwareVersion respFirm;
   2568                             respFirm.major = THIS_MAJOR;
   2569                             respFirm.minor = THIS_MINOR;
   2570                             respFirm.patch = THIS_PATCH;
   2571                             respFirm.reserved = 0;                       // For compatible reason
   2572                             respFirm.revision = THIS_REVISION;
   2573                             strcpy((char*) respFirm.dateString, __DATE__);
   2574                             strcpy((char*) respFirm.timeString, __TIME__);
   2575                            __writeCmdLineRespPacket((void *)&respFirm,  sizeof(respFirm), DEV_RESP_VERSION);
   2576                          }else if (packetHeader->type == DEV_CMD_RUNNING_STATUS_REQ) {
   2577                            struct BeaconRunningStatus bat;
   2578                            bat.errorCode = 0;
   2579                            bat.index = BattUnion.BatteryLevel[1];
   2580                            bat.radioOnOff = (radio_off == 0);
   2581                            __writeCmdLineRespPacket((void *)&bat,  sizeof(bat), DEV_RESP_RUNNING_STATUS);
   2582                          } else if (packetHeader->type == DEV_CMD_SET_CONFIG) {
   2583                              ex_config_t* newConfig;
   2584                              newConfig = (ex_config_t*)(decoded + sizeof(struct PacketHeader));
   2585                              if (newConfig->panId != config.panId ||
   2586                                  newConfig->mySrcAddr != config.mySrcAddr) {
   2587                                    update_flags |= UPDATE_FLAG_PANID;
   2588                              }
   2589                              if (newConfig->routerDstAddr != config.routerDstAddr) {
   2590                                update_flags |= UPDATE_FLAG_DSTADDR;
   2591                              }
   2592                              if (newConfig->ledDAC != config.ledDAC) {
   2593                                update_flags |= UPDATE_FLAG_DAC;
   2594                              }
   2595                              if (newConfig->rfChan != config.rfChan) {
   2596                                update_flags |= UPDATE_FLAG_RFCHAN;
   2597                              }
   2598                              if (newConfig->TxLevel != config.TxLevel) {
   2599                                update_flags |= UPDATE_FLAG_TXLEVEL;
   2600                              }
   2601                                                 CopyExConfigToConfig(newConfig, &config);
   2602                             // memcpy((void *)&config, (void *)newConfig, sizeof(beacon_config_t));
   2603                              SaveConfig(&config);
   2604                              if (update_flags & UPDATE_FLAG_PANID) {
   2605                                RadioSetPanIdShortAddr(config.panId, config.mySrcAddr);
   2606                              }
   2607                              if (update_flags & UPDATE_FLAG_DSTADDR) {
   2608                                routerAddr = config.routerDstAddr;
   2609                              }
   2610                              if (update_flags & UPDATE_FLAG_RFCHAN) {
   2611                                RadioSetRFChan(rfChan);
   2612                              }
   2613                              if (update_flags & UPDATE_FLAG_TXLEVEL) {
   2614                                RadioSetRFLevel(config.TxLevel);
   2615                              }
   2616          
   2617                          } else if (packetHeader->type == DEV_CMD_SET_EEPROM_DATA) {
   2618          					struct RespUpdate up;
   2619          					up.index = 0;
   2620          					if (packetHeader->size < sizeof(struct PacketHeader) + 32) { // if data body greater than 32, only 32 bytes are written 
   2621          						up.errorCode = ERROR_WRONG_PACKET;
   2622          					} else {
   2623          						uint8_t *data = (uint8_t *) decoded + sizeof(struct PacketHeader);
   2624          						I2C_EE_BufferWrite(data, 128, 32);
   2625          						up.errorCode = 0;
   2626          					}
   2627          					uint8_t type = DEV_RESP_SET_EEPROM_DATA;
   2628          					__writeCmdLineRespPacket((unsigned char*) &up, 4, type);
   2629                          } else if (packetHeader->type == DEV_CMD_GET_EEPROM_DATA) {
   2630          					struct RespEepromData resp;
   2631          					I2C_EE_BufferRead(&resp.data[0], 128, 32);
   2632          					resp.errorCode = 0;
   2633          					__writeCmdLineRespPacket((unsigned char*) &resp, sizeof(resp), DEV_RESP_GET_EEPROM_DATA);
   2634                          } else if (packetHeader->type == DEV_CMD_SET_PROD_AREA) {
   2635          					struct RespUpdate up;
   2636          					uint8_t type = DEV_RESP_SET_PROD_AREA;
   2637          					ret = SerialDownload((char*) decoded, ret, packetHeader->type);
   2638          					up.index = (ret & 0xFFFF0000) >> 16;
   2639          					up.errorCode = ret & 0xFFFF;
   2640          					__writeCmdLineRespPacket((unsigned char*) &up, 4, type);
   2641                          } else if (packetHeader->type == DEV_CMD_GET_PROD_AREA) {
   2642          					struct GetProdAreaPacketHeader *prodHeader = (struct GetProdAreaPacketHeader*) decoded;
   2643          					struct RespProdArea resp;
   2644          					page.address = FLASH_PROD_AREA;
   2645          					page.count = 2048;
   2646          					ret = ReadPage(&page);
   2647          					resp.errorCode = ret;
   2648          					resp.index = prodHeader->index;
   2649          					if (!ret) {
   2650          						memcpy(resp.data, &page.data[prodHeader->index*sizeof(resp.data)], sizeof(resp.data));
   2651          					}
   2652          					__writeCmdLineRespPacket((unsigned char*) &resp, sizeof(resp), DEV_RESP_GET_PROD_AREA);
   2653                          }
   2654                      }
   2655                      break;
   2656                  case '!':
   2657                    {
   2658                      uint8_t jumpToMain = 0xFF;
   2659                      I2C_EE_BufferRead((uint8_t*) &jumpToMain, EEPROM_BEACON_FLAG_ADDRESS, 1);
   2660                      if (jumpToMain != 0xFF) {
   2661                        jumpToMain = 0xFF;
   2662                        I2C_EE_BufferWrite((uint8_t*) &jumpToMain, EEPROM_BEACON_FLAG_ADDRESS, 1);
   2663                      }
   2664                      NVIC_GenerateSystemReset();
   2665                    }
   2666                     break;
   2667          #if (defined USE_MY_ASSERT) || (defined USE_FULL_ASSERT)
   2668                      case 'a':
   2669                          {
   2670                              assert_loop = 0;
   2671                          }
   2672                          break;
   2673          #endif
   2674                  default:
   2675                          TRACE("**ERROR** Unrecognized Command '%c'\n\r", cmd);
   2676                          break;
   2677                  }
   2678          
   2679                  if (cmd != 'U') {
   2680                      TRACE("> ");
   2681                  }
   2682              }
   2683          }
   2684          
   2685          uint32_t mycalls;
   2686          uint32_t radioTxEntries;
   2687          StatusType lastRadioTx;
   2688          StatusType setTxDone;
   2689          
   2690          /*******************************************************************************
   2691          * Description    : [Task] Manage Outgoing (TX) Packet Queue
   2692          * Input          :
   2693          * Return         :
   2694          *******************************************************************************/
   2695          void TaskRadioTx(void* pdata){
   2696              SAVE_LINE
   2697              while (1) {
   2698                  // avoid busy waiting. sleep a tick or until wake up by other task
   2699                  SAVE_FUNC
   2700                  radioTxEntries++;
   2701                  lastRadioTx = CoWaitForSingleFlag(flagRadioTxReq, 1);
   2702                  SAVE_POINT
   2703                  while (1) {
   2704                      SAVE_FUNC
   2705                      RELOAD_WATCHDOG
   2706                      __disable_interrupt();
   2707          #ifndef NO_TK
   2708                      if (remainOutOfSyncTime <= 0) {         // out of synchronization. Need to stop sending so that T.K. can occupy timeslot to sync again
   2709                      //    CoSuspendTask(task1Id);
   2710                      //    CoSuspendTask(taskRadioTxId);
   2711          
   2712                        __enable_interrupt();
   2713                        SAVE_LINE
   2714                          break;
   2715                      }
   2716          #endif
   2717                      if (inIdx == outIdx) { // queue is NOT empty.       // TODO!!! Double check if producer can be run and modifies inIdx. If so it is a critical section.
   2718                          queue_full = 1;
   2719                          SAVE_LINE
   2720                          __enable_interrupt();
   2721                          break;
   2722                      } else {
   2723                        queue_full = 0;
   2724                      }
   2725                      __enable_interrupt();
   2726          
   2727          
   2728                      SAVE_POINT
   2729                      RadioIMU_WaitGrabSPI();
   2730                      SAVE_POINT
   2731                      startRadioTx.sec = sec;
   2732                      startRadioTx.uSec = TIM1->CNT;
   2733                      // outIdx is modified by Tx task only. So no lock required
   2734                      RadioTxPkt(txPktQueue[outIdx].dstAddr,
   2735                                 0,   // not a beacon frame
   2736                                 txPktQueue[outIdx].payloadSize,
   2737                                 txPktQueue[outIdx].payload,
   2738                                 1);  // transmit immediately
   2739                      SAVE_POINT
   2740                      mycalls++;
   2741                      endRadioTx.sec = sec;
   2742                      endRadioTx.uSec = TIM1->CNT;
   2743          #ifndef CCA_EN
   2744                      RadioIMU_ReleaseSPI();      // TODO!!! verify if SPIIODone is correctly waiting
   2745          #endif
   2746          
   2747                      // ring buffer operation is in critical section
   2748                      __disable_interrupt();
   2749                      outIdx = (outIdx + 1) % TX_PKT_QUEUE_SIZE;
   2750                      __enable_interrupt();
   2751          
   2752                      numTxRetries = 0; // reset counter as we initiate tx
   2753                      txRetryState = 1; // indicate STXONCCA has been issued. TODO!!! verify the meaning
   2754          
   2755                      /* fire up TIM5 to ring check CCA after 1ms */
   2756          #ifdef CCA_EN
   2757                      uint8_t txRetryState = 1;
   2758                      uint8_t numTxRetries = NUM_TX_RETRIES;
   2759          
   2760                      do {
   2761                        TIM5->EGR |= TIM_EGR_UG;
   2762                        TIM5->CR1 |= TIM_CR1_CEN;
   2763                        CoWaitForSingleFlag(flagRadioCCA, 1, 0);
   2764                        SAVE_POINT
   2765          
   2766                        assert(txRetryState != 0); // [[DEBUG]]
   2767          
   2768                        if (txRetryState == 1) {            // read FMSTAT1
   2769                          /* check if CCA was asserted */
   2770                          if (!spiTxRxByteCount) {        // SPI not in use
   2771                            /* read FSMSTAT1 register */
   2772                            scratchBuf[0] = (CC2520_INS_REGRD | CC2520_FSMSTAT1);
   2773                            scratchBuf[1] = 0;          // pad byte to push out reg val
   2774                            spiTxRxByteCount = 0x02;  // indicate FMSTAT1 read
   2775                            spiTxRxByteState = RF_SPI_CCA_CMD_STATE;
   2776                            pSpiTxBuf = scratchBuf;
   2777                            pSpiRxBuf = scratchBuf;     // self-clobbering ... that's ok
   2778                            HwSPISSAssert(SPI_RADIO);
   2779                            SPI_I2S_ITConfig(SPI_RADIO_SPI, SPI_I2S_IT_RXNE, ENABLE);
   2780                            SPI_I2S_SendData(SPI_RADIO_SPI, *pSpiTxBuf++);
   2781                            txRetryState++;             // go to next state
   2782                          } else {
   2783                            break;
   2784                          }
   2785                      } else if (txRetryState == 2) {     // check SAMPLED_CCA bit, retry TX if necessary
   2786                        if (sampledCCA & CC2520_FSMSTAT1_SAMPLED_CCA_BM) {
   2787                          /* CCA asserted, packet is going (has gone) out */
   2788                          txRetryState = 0;
   2789                          break;
   2790                        }
   2791          
   2792                        /* CCA NOT asserted, packet isn't going out ... try STXONCCA again now */
   2793          
   2794                        if (numTxRetries < NUM_TX_RETRIES) {
   2795                          if (!spiTxRxByteCount) {        // SPI not in use
   2796                              spiTxRxByteCount = 0x01;  // indicate STXONCCA retry
   2797                              spiTxRxByteState = RF_SPI_STXONCCA_CMD_STATE;
   2798                              pSpiRxBuf = scratchBuf;     // don't care
   2799                              HwSPISSAssert(SPI_RADIO);
   2800                              SPI_I2S_ITConfig(SPI_RADIO_SPI, SPI_I2S_IT_RXNE, ENABLE);
   2801                              SPI_I2S_SendData(SPI_RADIO_SPI, CC2520_INS_STXONCCA);
   2802                              numTxRetries++;
   2803                              txRetryState = 1;
   2804                          }                               // else, remain in this state, retry later
   2805                      } else { // done retrying, no more
   2806                          txRetryState = 0;
   2807                          // fake TX_FRM_DONE
   2808                          setTxDone = CoSetFlag(flagRadioTxDone);
   2809                          break;
   2810                      }
   2811                      SAVE_POINT
   2812                  } else assert(0);
   2813          
   2814          
   2815                      } while (1);
   2816                      RadioIMU_ReleaseSPI();
   2817          #endif
   2818                  }
   2819              }
   2820          }
   2821          
   2822          float fVolt = 0.0f;
   2823          
   2824          /*******************************************************************************
   2825          * Description    : [Task]A to D conversion for battery voltage
   2826          * Input          :
   2827          * Return         :
   2828          * Calculation: resistive divider
   2829          *  4.99k + 4.3k
   2830          *  After divider have: 4.3/(4.3+4.99) = 0.462365 of original Vbat value
   2831          *  With 4.2V nominal value will have 4.2V*0.462365=1.941935V at ADC
   2832          *  With ADC Vref= V+ = 2.2V will have 1.941935V/2.2V = 0.8826979 of full scale
   2833          *  With full scale of 65536 will have 0.8826979*65536=57848
   2834          *  In hexadecimal 4.2V at battery will be reported as 0xE17F
   2835          *  Other values calculated using linear scale
   2836          *
   2837          * There is no chip to calculate battery level, so following is data measured
   2838          * with radio ON and no LED
   2839          * DISCHARGE - starting at 4.2V:
   2840          * after 1hr=4.12V 2hr = 4.07V 3hr = 4.03V 4hr = 3.99V, up to 9hr rate is 0.03V per hour
   2841          * after 9hr rate up to 16 hr rate 0.02V, then 0.03V 2 hours up to 3.65V, then
   2842          * during 1hr goes to 3.5V and turns off
   2843          * CHARGE - 15 minutes to get to 3.92V, then steady rate 0.06V/hour
   2844          * after reaching 4.21V 45 minutes to full charge
   2845          *Data for V#3 hardware.. 4.2v= E1, 4.0v=D7, 3.9v=D0, 3.8v=CA, 3.7v=C6, 3.6v=C1
   2846          *                         3.5v=BB, 3.4v=B6, 3.3v=B0,3.2v=AB, 3.1v= A5, 3.0v= A0
   2847          *                         2.9v= 9A, 2.8v= 96, 2.7v= 90, 2.6v= 8B
   2848          *******************************************************************************/
   2849          
   2850          float fLast[10];
   2851          
   2852          void Task8(void* pdata){
   2853            while (1) {
   2854                SAVE_POINT
   2855              RELOAD_WATCHDOG
   2856                  // enable a to d battery input
   2857              HwGPOHigh(GPO_VBATT_ADC_EN);
   2858                  // wait 1 for input to stabilise
   2859              CoTickDelay(1);
   2860              SAVE_POINT
   2861                  // trigger a to d
   2862              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   2863                  // wait 1 for data sample
   2864              CoTickDelay(2);
   2865              SAVE_POINT
   2866                  // get sample data, disable input
   2867              BattUnion.Battery_AtoD = (ADC_GetConversionValue(ADC1));
   2868              HwGPOHigh(GPO_VBATT_ADC_EN);
   2869                  // wait 100
   2870              CoTickDelay(100);
   2871              SAVE_POINT
   2872              //CoTickDelay(1000);
   2873              static uint32_t iter = 0;
   2874              float fCurr = 4.2f * (float)BattUnion.Battery_AtoD;
   2875              fCurr /= (float) 0xE1F8;
   2876              fLast[iter%10] = fCurr;
   2877              iter++;
   2878              uint8_t cnt = (iter>10)?10:iter;
   2879              fVolt = 0.0;
   2880              for (uint8_t k = 0; k < cnt; k++) {
   2881                fVolt += fLast[k];
   2882              }
   2883              fVolt /= (float) cnt;
   2884             /* if (iter == 10)*/ {
   2885                SAVE_LINE
   2886            //    iter = 0;
   2887                lastBatStatus.type = 0xBA;
   2888                lastBatStatus.version = 0x01;
   2889                lastBatStatus.flags = HwGPIState(GPI_CHG_STAT)?0x00:0x01;
   2890                if (HwGPIState(GPI_USB_VBUS)) {
   2891                  lastBatStatus.flags |= 0x02;
   2892           //       if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)) {
   2893                  rt_flags |= RT_FLAG_USB_CONNECTED;
   2894           //     }
   2895                } else {
   2896                  rt_flags &= ~RT_FLAG_USB_CONNECTED;
   2897                }
   2898                lastBatStatus.minToRun = 0xFFFF;
   2899                //fVolt /= (float) 10.0;
   2900                float percents = 0;
   2901                if (lastBatStatus.flags == 0x03) { //charging
   2902                  if (fVolt > 4.20) {
   2903                    percents = 95.0;
   2904                  } else if (fVolt > 3.92) {
   2905                    percents = 4.0 + 91.0*(fVolt - 3.92)/0.28;
   2906                  } else {
   2907                    percents = 4.0;
   2908                  }
   2909                } else {
   2910                  if (fVolt > 4.1 && (lastBatStatus.flags & 0x01) == 0) {
   2911                    percents = 100.0;
   2912                  } else if (fVolt > 4.07) {
   2913                    percents = 90.0 + 10.0 *(fVolt - 4.07)/0.14;
   2914                    if (percents >= 100.0) {
   2915                      percents = 99.0;
   2916                    }
   2917                  } else if (fVolt > 4.03) {
   2918                    percents = 85.0 + 5.0*(fVolt - 4.03)/0.04;
   2919                  } else if (fVolt > 3.84) {
   2920                    percents = 55.0 + 30.0*(fVolt - 3.84)/0.19;
   2921                  } else if (fVolt > 3.71) {
   2922                    percents = 20.0 + 35.0*(fVolt -3.71)/0.13;
   2923                  } else if (fVolt > 3.65) {
   2924                    percents = 10.0 + (fVolt - 3.65)/0.006;
   2925                  } else {
   2926                    percents = (fVolt - 3.5)/10.0;
   2927                    if (percents < 0) {
   2928                      percents = 0.0;
   2929                    }
   2930                  }
   2931                }
   2932                lastBatStatus.voltiCents = (uint16_t) ((fVolt + 0.005)*100.0);
   2933                last_percents = lastBatStatus.percents = (uint8_t) percents;
   2934          
   2935          //((config.radioPacketFlags & RADIOPACKET_BATTERY) && (battery_minutes != (secs/600))
   2936                if ((config.flags & FLAG_SEND_BATTERY_INFO) && sec > last_bat_sent) {
   2937                  last_bat_sent = 10 + (random%40);
   2938                  if (config.flags & FLAG_TRACE_ASYNC) {
   2939                    uint8_t hours = sec/3600;
   2940                    uint8_t min = (sec/60)%60;
   2941                    uint8_t mysec = (sec%60);
   2942          
   2943                    TRACE("Battery: %d.%04dV charge=%u%% %02d:%02d:%02d  %s charging; next in %d sec\n\r",
   2944                        (uint8_t)fVolt, ((uint16_t) (fVolt*10000.0))%10000, last_percents,
   2945                        hours, min, mysec,
   2946                        lastBatStatus.flags == 3?"":"not", last_bat_sent);
   2947          
   2948                  }
   2949                  last_bat_sent += sec;
   2950                  static uint8_t ticks = 0;
   2951                  lastBatStatus.tick = ticks++;
   2952                  lastBatStatus.crc8 = crc8(&lastBatStatus.type, sizeof(lastBatStatus) - 1);
   2953                  SAVE_POINT
   2954                  RadioTxPktQueue(routerAddr, sizeof(lastBatStatus), (uint8_t*) &lastBatStatus);
   2955                  SAVE_POINT
   2956                }
   2957              //  fVolt = 0.0;
   2958          
   2959              }
   2960              //iter++;
   2961          
   2962          
   2963           }
   2964          
   2965          }
   2966          
   2967          StatusType setIMUReady;
   2968          uint32_t counterIMU;
   2969          
   2970          extern uint16_t over1;
   2971          /*******************************************************************************
   2972          * Description    : [Task]9 Used for reading the IMU reg data and packing
   2973          * Input          :
   2974          * Return         :
   2975          *
   2976          *******************************************************************************/
   2977          void TaskIMU_G(void* pdata){
   2978            //static count;
   2979            while(1)
   2980            {
   2981              SAVE_POINT
   2982          
   2983              if (adjusted_changed) {
   2984                adjusted_changed = 0;
   2985                if (config.flags & FLAG_TRACE_ADJUST) {
   2986                  TRACE("adjusted=%u over=%d @%d.%d\r\n", adjusted, over1, sec, tim_at_sec);
   2987                }
   2988              }
   2989              RELOAD_WATCHDOG
   2990              CoWaitForSingleFlag(flagIMU_G_DRDY, 0);
   2991              counterIMU++;
   2992              SAVE_POINT
   2993              CoClearFlag(flagIMUNewData);        // DO NOT USE auto reset Flag as the DMA interrupt may take place before CoWaitForSingleFlag(flagIMUNewData, 0);  
   2994            	//REV J 
   2995            	RadioIMU_WaitGrabSPI();
   2996            	IMUProcess();
   2997            	RadioIMU_ReleaseSPI();
   2998            	SAVE_POINT
   2999            	InputDataIntoBuffer(&IMU_RawData[0]);
   3000          
   3001            	setIMUReady = CoSetFlag(flagIMUDataReady);
   3002            	SAVE_POINT;
   3003          #if 0	  //move to task3
   3004          //((config.radioPacketFlags & RADIOPACKET_BUTTONPRESS) && (last_button_state != pBeacon_Data_pkt->BK_Preamble.button_pr)
   3005          	if (button_state) {
   3006          		static uint8_t tick;
   3007          		struct ButtonClick btnClick;
   3008          		btnClick.button_events = button_state;
   3009          		btnClick.tick = tick++;
   3010          		btnClick.type = 0xBC;
   3011          		btnClick.version = PACKET_VERSION;
   3012          		btnClick.crc8 = crc8(&btnClick.type, sizeof(btnClick) - 1);
   3013          		if (config.flags & FLAG_TRACE_ASYNC) {
   3014          			TRACE("BtnClick 0x%02X\r\n", btnClick.button_events);
   3015          		}
   3016          		RadioTxPktQueue(config.routerDstAddr, sizeof(btnClick), (uint8_t *) &btnClick);
   3017              }
   3018              if ((button_state & BUTTON_A)) {
   3019          		if (config.flags & FLAG_TRACE_ASYNC) {
   3020          			switch (button_state & BUTTON_A) {
   3021          				case BUTTON_PRESS:
   3022          					TRACE("Btn A PRESS\r\n");
   3023          					break;
   3024          				case BUTTON_CLICK:
   3025          					TRACE("Btn A CLICK\r\n");
   3026          					break;
   3027          				case BUTTON_DBLCLICK:
   3028          					TRACE("Btn A dblClick\r\n");
   3029          					break;
   3030          				case BUTTON_RELEASE:
   3031          					TRACE("Btn A Release\r\n");
   3032          				break;
   3033          			}
   3034          		}
   3035          		button_state &= BUTTON_B;
   3036              }
   3037              if ((button_state & BUTTON_B)) {
   3038          		if (config.flags & FLAG_TRACE_ASYNC) {
   3039          			switch ((button_state & BUTTON_B) >>4) {
   3040          				case BUTTON_PRESS:
   3041          					TRACE("Btn B PRESS\r\n");
   3042          					break;
   3043          				case BUTTON_CLICK:
   3044          					TRACE("Btn B CLICK\r\n");
   3045          					break;
   3046          				case BUTTON_DBLCLICK:
   3047          					TRACE("Btn B dblClick\r\n");
   3048          					break;
   3049          				case BUTTON_RELEASE:
   3050          					TRACE("Btn B Release\r\n");
   3051          					break;
   3052          			}
   3053          		}
   3054          		button_state &= BUTTON_A;
   3055              }
   3056          #endif
   3057            }
   3058          }
   3059          /******************* (C) COPYRIGHT 2011 NaturalPoint, Inc. *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  GetAverageImuData
       16  IMURegRd
              16 -> HwSPISSAssert
              16 -> HwSPISSDeAssert
              16 -> SPI_I2S_GetFlagStatus
              16 -> SPI_I2S_ReceiveData
              16 -> SPI_I2S_SendData
       16  IMURegWr
              16 -> HwSPISSAssert
              16 -> HwSPISSDeAssert
              16 -> SPI_I2S_GetFlagStatus
              16 -> SPI_I2S_ReceiveData
              16 -> SPI_I2S_SendData
        0  InputDataIntoBuffer
        0  NVIC_GenerateSystemReset
        8  PrintConfig
               8 -> TRACE
       24  RadioTxPktQueue
              24 -> CoSetFlag
              24 -> memcpy
        8  ReadPage
       32  SerialDownload
              32 -> WritePage
              32 -> memcpy
       24  SetConfig
              24 -> DAC_SetChannel2Data
              24 -> RadioSetPanIdShortAddr
              24 -> RadioSetRFChan
              24 -> RadioSetRFLevel
              24 -> SetTimeSlot
              24 -> TRACE
        8  SetTimeSlot
               8 -> SetTimeSlot
        8  Task1
               8 -> CoAcceptSingleFlag
               8 -> CoPendSem
               8 -> CoPostSem
               8 -> CoWaitForMultipleFlags
               8 -> IWDG_ReloadCounter
               8 -> RadioTxPktQueue
               8 -> TRACE
               8 -> __writeIMU
               8 -> filltxbuf
        0  Task3
               0 -> CoAwakeTask
               0 -> CoClearFlag
               0 -> CoSchedLock
               0 -> CoSetFlag
               0 -> CoWaitForSingleFlag
               0 -> HwGPIState
               0 -> HwGPOInitOC
               0 -> HwGPOLow
               0 -> IWDG_ReloadCounter
               0 -> SetTimeSlot
               0 -> TRACE
       24  Task8
              24 -> ADC_GetConversionValue
              24 -> ADC_SoftwareStartConvCmd
              24 -> CoTickDelay
              24 -> HwGPIState
              24 -> HwGPOHigh
              24 -> IWDG_ReloadCounter
              24 -> RadioTxPktQueue
              24 -> TRACE
              24 -> __aeabi_cfcmple
              24 -> __aeabi_cfrcmple
              24 -> __aeabi_d2f
              24 -> __aeabi_d2iz
              24 -> __aeabi_dadd
              24 -> __aeabi_ddiv
              24 -> __aeabi_dmul
              24 -> __aeabi_f2d
              24 -> __aeabi_f2iz
              24 -> __aeabi_fadd
              24 -> __aeabi_fdiv
              24 -> __aeabi_fmul
              24 -> __aeabi_ui2f
              24 -> crc8
      440  TaskConfig
             440 -> CalcConfigChecksum
             440 -> CoClearFlag
             440 -> CoGetOSTime
             440 -> CoGetStackDepth
             440 -> CoGetTaskFunc
             440 -> CoGetTaskLine
             440 -> CoGetTaskScheduledCount
             440 -> CoTickDelay
             440 -> CopyConfigToExConfig
             440 -> CopyExConfigToConfig
             440 -> I2C_EE_BufferRead
             440 -> I2C_EE_BufferWrite
             440 -> IMUProcess
             440 -> IWDG_ReloadCounter
             440 -> NVIC_GenerateSystemReset
             440 -> PrintConfig
             440 -> RadioIMU_ReleaseSPI
             440 -> RadioIMU_WaitGrabSPI
             440 -> RadioPrint2520Registers
             440 -> RadioSetPanIdShortAddr
             440 -> RadioSetRFChan
             440 -> RadioSetRFLevel
             440 -> ReadPage
             440 -> SaveConfig
             440 -> SerialDownload
             440 -> SetConfig
             440 -> TRACE
             440 -> ValidateCommandLine
             440 -> __writeCmdLineRespPacket
             440 -> b64_pton
             440 -> isspace
             440 -> memcpy
             440 -> memset
             440 -> mygets
             440 -> strcpy
             440 -> strlen
             440 -> strtoul
        8  TaskIMU_G
               8 -> CoClearFlag
               8 -> CoSetFlag
               8 -> CoWaitForSingleFlag
               8 -> IMUProcess
               8 -> IWDG_ReloadCounter
               8 -> InputDataIntoBuffer
               8 -> RadioIMU_ReleaseSPI
               8 -> RadioIMU_WaitGrabSPI
               8 -> TRACE
       16  TaskRadioRx
              16 -> CoGetOSTime
              16 -> CoPendSem
              16 -> IWDG_ReloadCounter
              16 -> ProcessRXError
              16 -> RadioIMU_ReleaseSPI
              16 -> RadioIMU_WaitGrabSPI
              16 -> RadioRxPkt
              16 -> TIM_SetAutoreload
              16 -> TIM_SetCompare2
              16 -> TIM_SetCompare3
              16 -> TIM_SetCompare4
              16 -> TRACE
              16 -> assert_failed
              16 -> crc8
        8  TaskRadioTx
               8 -> CoWaitForSingleFlag
               8 -> IWDG_ReloadCounter
               8 -> RadioIMU_ReleaseSPI
               8 -> RadioIMU_WaitGrabSPI
               8 -> RadioTxPkt
       32  WritePage
              32 -> FLASH_ErasePage
              32 -> FLASH_Lock
              32 -> FLASH_ProgramWord
              32 -> FLASH_Unlock
        0  _LocaleC_isspace
       16  __task1_bat_pack
              16 -> fillmsgBAT
              16 -> fillmsgPreamble
       16  __task1_batbtn_pack
              16 -> fillmsgBAT
              16 -> fillmsgBTN
              16 -> fillmsgPreamble
       24  __task1_batbtnimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgBAT
              24 -> fillmsgBTN
              24 -> fillmsgPreamble
       24  __task1_batimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgBAT
              24 -> fillmsgPreamble
       16  __task1_btn_pack
              16 -> fillmsgBTN
              16 -> fillmsgPreamble
       24  __task1_btnimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgBTN
              24 -> fillmsgPreamble
       24  __task1_imu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgPreamble
       16  __task1_led_pack
              16 -> fillmsgLED
              16 -> fillmsgPreamble
       16  __task1_ledbat_pack
              16 -> fillmsgBAT
              16 -> fillmsgLED
              16 -> fillmsgPreamble
       16  __task1_ledbatbtn_pack
              16 -> fillmsgBAT
              16 -> fillmsgBTN
              16 -> fillmsgLED
              16 -> fillmsgPreamble
       24  __task1_ledbatbtnimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgBAT
              24 -> fillmsgBTN
              24 -> fillmsgLED
              24 -> fillmsgPreamble
       24  __task1_ledbatimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgBAT
              24 -> fillmsgLED
              24 -> fillmsgPreamble
       16  __task1_ledbtn_pack
              16 -> fillmsgBTN
              16 -> fillmsgLED
              16 -> fillmsgPreamble
       24  __task1_ledbtnimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgBTN
              24 -> fillmsgLED
              24 -> fillmsgPreamble
       24  __task1_ledimu_pack
              24 -> CoWaitForSingleFlag
              24 -> GetAverageImuData
              24 -> fillmsgLED
              24 -> fillmsgPreamble
        0  fastdivide250
        8  fillmsgBAT
               8 -> CoClearFlag
        8  fillmsgBTN
               8 -> CoClearFlag
        8  fillmsgLED
               8 -> CoClearFlag
        0  fillmsgPreamble
       16  filltxbuf
              16 -> __task1_bat_pack
              16 -> __task1_batbtn_pack
              16 -> __task1_batbtnimu_pack
              16 -> __task1_batimu_pack
              16 -> __task1_btn_pack
              16 -> __task1_btnimu_pack
              16 -> __task1_imu_pack
              16 -> __task1_led_pack
              16 -> __task1_ledbat_pack
              16 -> __task1_ledbatbtn_pack
              16 -> __task1_ledbatbtnimu_pack
              16 -> __task1_ledbatimu_pack
              16 -> __task1_ledbtn_pack
              16 -> __task1_ledbtnimu_pack
              16 -> __task1_ledimu_pack
        8  isspace
               8 -> _LocaleC_isspace
       16  memcpy
              16 -> __aeabi_memcpy
       16  memset
              16 -> __aeabi_memset
       16  mygets
              16 -> CoTickDelay
              16 -> getchar
              16 -> putchar


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant " Apr 17 2019 : 16:26:...">
      24  ?<Constant " No IMU Installed\n\n\r">
      32  ?<Constant " Phase=%u inced=%u co...">
       1  ?<Constant "">
      16  ?<Constant "%X, %X, %X\n\r">
      48  ?<Constant "**ERROR** Unrecognize...">
      40  ?<Constant "**ERROR** Unrecognize...">_1
      12  ?<Constant "16:26:53">
      52  ?<Constant ": excFlag0=0x%02X exc...">
      52  ?<Constant ": realFrameId=%d last...">
      48  ?<Constant ": remainOutOfSyncTime...">
      44  ?<Constant ": rxCount=%d rxFIFOEr...">
      36  ?<Constant ": rxFIFOTime %d.%d se...">
      36  ?<Constant ": rxWait @ %d.%d rxSt...">
      52  ?<Constant ": successBeacons=%d f...">
      64  ?<Constant ": txStart @ %d.%d txE...">
      20  ?<Constant ":%u @%u t:%d d:%u\n\r">
       4  ?<Constant "> ">
      40  ?<Constant "ARM Serial Number 0x%...">
      12  ?<Constant "Apr 17 2019">
      76  ?<Constant "Battery: %d.%04dV cha...">
      32  ?<Constant "Beacon received: CRC8...">
      48  ?<Constant "Beacon received: Unsu...">
      40  ?<Constant "Beacon received: unkn...">
      36  ?<Constant "Beacon: changing fram...">
      32  ?<Constant "Built on Apr 17 2019 ...">
     116  ?<Constant "C:\\Users\\User\\Documen...">
      32  ?<Constant "CPU Serial #%04x:%04x...">
      36  ?<Constant "Current SysTickCount:...">
      24  ?<Constant "ERROR! Tx Buffer full\n\r">
      12  ?<Constant "Erased\n\r">
      20  ?<Constant "Flags = 0x%08X \r\n">
      16  ?<Constant "Framebits: %d\r\n">
      24  ?<Constant "Generating hard fault\r\n">
      20  ?<Constant "IMU Debug print:\n\r">
      16  ?<Constant "IMU Present\n\n\r">
      24  ?<Constant "Incorrect packet size\r\n">
      20  ?<Constant "Incorrect packet\r\n">
      20  ?<Constant "Mem addr error\n\r">
      24  ?<Constant "Mem at 0x%08X=0x%08X\n\r">
      36  ?<Constant "NULL packet, rxCount=...">
      40  ?<Constant "New bcn id:%u>%u tick...">
      28  ?<Constant "New timeslot offset =...">
      32  ?<Constant "No TK sync for %d sec...">
      28  ?<Constant "No sync timeout sec: ...">
      52  ?<Constant "PERF: IdleTask: %u Ta...">
      32  ?<Constant "PERF: Task8: %u TaskI...">
      36  ?<Constant "PERF: TaskConfig: %u ...">
      16  ?<Constant "RF CHAN: %d\n\r">
      20  ?<Constant "RF Tx Level: %X\n\r">
      44  ?<Constant "RadioRxTask [avail st...">
      44  ?<Constant "RadioTxTask [avail st...">
      40  ?<Constant "Task1 [avail stack:%d...">
      40  ?<Constant "Task3 [avail stack:%d...">
      40  ?<Constant "Task8 [avail stack:%d...">
      44  ?<Constant "TaskConfig [avail sta...">
      40  ?<Constant "TaskIMU [avail stack:...">
      24  ?<Constant "Timekeeper sync: %s\n\r">
      20  ?<Constant "Timer adjust: %d\n\r">
      20  ?<Constant "Watchdog is %s\r\n">
      24  ?<Constant "[0] productID   : %X\n\r">
      24  ?<Constant "[1] serialNum   : %X\n\r">
      28  ?<Constant "[2] panId       : %04X\n\r">
      28  ?<Constant "[3] mySrcAddr   : %04X\n\r">
      32  ?<Constant "[4] routerDstAddr   :...">
      24  ?<Constant "[5] ledOnOffs   : %X\n\r">
      24  ?<Constant "[6] ledOffOffs  : %X\n\r">
      24  ?<Constant "[7] ledDAC      : %X\n\r">
      28  ?<Constant "[8] rfChan      : %02X\n\r">
      28  ?<Constant "[9] led0Id      : %02X\n\r">
      28  ?<Constant "[?] rfTimeSlot  : %02X\n\r">
      28  ?<Constant "[A] led1Id      : %02X\n\r">
      28  ?<Constant "[B] led2Id      : %02X\n\r">
      24  ?<Constant "[C] TestMode    : %d\n\r">
      28  ?<Constant "[J] led0IdPattern : %...">
      28  ?<Constant "[K] led1IdPattern : %...">
      28  ?<Constant "[L] led2IdPattern : %...">
      24  ?<Constant "[M] led0Index : %08X\n\r">
      24  ?<Constant "[N] led1Index : %08X\n\r">
      24  ?<Constant "[O] led2Index : %08X\n\r">
      16  ?<Constant "[X] Radio: %s\n\r">
      24  ?<Constant "[Y] frameBits   : %d\n\r">
      24  ?<Constant "[Z] Tx RF Level : %X\n\r">
      44  ?<Constant "\n\r FIRMWARE VERSION: ...">
       8  ?<Constant "active">
      48  ?<Constant "adjust=%d tim3_phase=...">
      32  ?<Constant "adjusted=%u over=%d @...">
      64  ?<Constant "changeClocks=%d newbc...">
      56  ?<Constant "errorFrameId=%u valid...">
      24  ?<Constant "fault_counter = %u\r\n">
      56  ?<Constant "frIdCorr=%d lastFrIdC...">
      20  ?<Constant "led blinking=%d\r\n">
      48  ?<Constant "newFrameTime @%d.%d f...">
       4  ?<Constant "no">
      12  ?<Constant "not active">
       4  ?<Constant "not">
       4  ?<Constant "off">
      52  ?<Constant "oldFrameTime @%d.%d f...">
      48  ?<Constant "oldTim3Phase=%u newTi...">
       4  ?<Constant "on">
      24  ?<Constant "ooopss.. wrong value\n\r">
      36  ?<Constant "realFrameId=%u frameI...">
      44  ?<Constant "rxPkts=%u rxTotal=%u ...">
      36  ?<Constant "saved_pc=0x%08X saved...">
      40  ?<Constant "stacked_lr=0x%08X sta...">
      40  ?<Constant "stacked_psr=0x%08X sa...">
      44  ?<Constant "trace_irq=%d frIdCor=...">
       4  ?<Constant "yes">
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_26
       4  ??DataTable22_27
       4  ??DataTable22_28
       4  ??DataTable22_29
       4  ??DataTable22_3
       4  ??DataTable22_30
       4  ??DataTable22_31
       4  ??DataTable22_32
       4  ??DataTable22_33
       4  ??DataTable22_34
       4  ??DataTable22_35
       4  ??DataTable22_36
       4  ??DataTable22_37
       4  ??DataTable22_38
       4  ??DataTable22_39
       4  ??DataTable22_4
       4  ??DataTable22_40
       4  ??DataTable22_41
       4  ??DataTable22_42
       4  ??DataTable22_43
       4  ??DataTable22_44
       4  ??DataTable22_45
       4  ??DataTable22_46
       4  ??DataTable22_47
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_17
       4  ??DataTable25_18
       4  ??DataTable25_19
       4  ??DataTable25_2
       4  ??DataTable25_20
       4  ??DataTable25_21
       4  ??DataTable25_22
       4  ??DataTable25_23
       4  ??DataTable25_24
       4  ??DataTable25_25
       4  ??DataTable25_26
       4  ??DataTable25_27
       4  ??DataTable25_28
       4  ??DataTable25_29
       4  ??DataTable25_3
       4  ??DataTable25_30
       4  ??DataTable25_31
       4  ??DataTable25_32
       4  ??DataTable25_33
       4  ??DataTable25_34
       4  ??DataTable25_35
       4  ??DataTable25_36
       4  ??DataTable25_37
       4  ??DataTable25_38
       4  ??DataTable25_39
       4  ??DataTable25_4
       4  ??DataTable25_40
       4  ??DataTable25_41
       4  ??DataTable25_42
       4  ??DataTable25_43
       4  ??DataTable25_44
       4  ??DataTable25_45
       4  ??DataTable25_46
       4  ??DataTable25_47
       4  ??DataTable25_48
       4  ??DataTable25_49
       4  ??DataTable25_5
       4  ??DataTable25_50
       4  ??DataTable25_51
       4  ??DataTable25_52
       4  ??DataTable25_53
       4  ??DataTable25_54
       4  ??DataTable25_55
       4  ??DataTable25_56
       4  ??DataTable25_57
       4  ??DataTable25_58
       4  ??DataTable25_59
       4  ??DataTable25_6
       4  ??DataTable25_60
       4  ??DataTable25_61
       4  ??DataTable25_62
       4  ??DataTable25_63
       4  ??DataTable25_64
       4  ??DataTable25_65
       4  ??DataTable25_66
       4  ??DataTable25_67
       4  ??DataTable25_68
       4  ??DataTable25_69
       4  ??DataTable25_7
       4  ??DataTable25_70
       4  ??DataTable25_71
       4  ??DataTable25_72
       4  ??DataTable25_73
       4  ??DataTable25_74
       4  ??DataTable25_75
       4  ??DataTable25_76
       4  ??DataTable25_77
       4  ??DataTable25_78
       4  ??DataTable25_8
       4  ??DataTable25_9
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_13
       4  ??DataTable26_14
       4  ??DataTable26_15
       4  ??DataTable26_16
       4  ??DataTable26_17
       4  ??DataTable26_18
       4  ??DataTable26_19
       4  ??DataTable26_2
       4  ??DataTable26_20
       4  ??DataTable26_21
       4  ??DataTable26_22
       4  ??DataTable26_23
       4  ??DataTable26_24
       4  ??DataTable26_25
       4  ??DataTable26_26
       4  ??DataTable26_27
       4  ??DataTable26_28
       4  ??DataTable26_29
       4  ??DataTable26_3
       4  ??DataTable26_30
       4  ??DataTable26_31
       4  ??DataTable26_32
       4  ??DataTable26_33
       4  ??DataTable26_34
       4  ??DataTable26_35
       4  ??DataTable26_36
       4  ??DataTable26_37
       4  ??DataTable26_38
       4  ??DataTable26_39
       4  ??DataTable26_4
       4  ??DataTable26_40
       4  ??DataTable26_41
       4  ??DataTable26_42
       4  ??DataTable26_43
       4  ??DataTable26_44
       4  ??DataTable26_45
       4  ??DataTable26_46
       4  ??DataTable26_47
       4  ??DataTable26_48
       4  ??DataTable26_49
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_13
       4  ??DataTable27_14
       4  ??DataTable27_15
       4  ??DataTable27_16
       4  ??DataTable27_17
       4  ??DataTable27_18
       4  ??DataTable27_19
       4  ??DataTable27_2
       4  ??DataTable27_20
       4  ??DataTable27_21
       4  ??DataTable27_22
       4  ??DataTable27_23
       4  ??DataTable27_24
       4  ??DataTable27_25
       4  ??DataTable27_26
       4  ??DataTable27_27
       4  ??DataTable27_28
       4  ??DataTable27_29
       4  ??DataTable27_3
       4  ??DataTable27_30
       4  ??DataTable27_31
       4  ??DataTable27_32
       4  ??DataTable27_33
       4  ??DataTable27_34
       4  ??DataTable27_35
       4  ??DataTable27_36
       4  ??DataTable27_37
       4  ??DataTable27_38
       4  ??DataTable27_39
       4  ??DataTable27_4
       4  ??DataTable27_40
       4  ??DataTable27_41
       4  ??DataTable27_42
       4  ??DataTable27_43
       4  ??DataTable27_44
       4  ??DataTable27_45
       4  ??DataTable27_46
       4  ??DataTable27_47
       4  ??DataTable27_48
       4  ??DataTable27_49
       4  ??DataTable27_5
       4  ??DataTable27_50
       4  ??DataTable27_51
       4  ??DataTable27_52
       4  ??DataTable27_53
       4  ??DataTable27_54
       4  ??DataTable27_55
       4  ??DataTable27_56
       4  ??DataTable27_57
       4  ??DataTable27_58
       4  ??DataTable27_59
       4  ??DataTable27_6
       4  ??DataTable27_60
       4  ??DataTable27_61
       4  ??DataTable27_62
       4  ??DataTable27_63
       4  ??DataTable27_64
       4  ??DataTable27_65
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_22
       4  ??DataTable29_23
       4  ??DataTable29_24
       4  ??DataTable29_25
       4  ??DataTable29_26
       4  ??DataTable29_27
       4  ??DataTable29_28
       4  ??DataTable29_29
       4  ??DataTable29_3
       4  ??DataTable29_30
       4  ??DataTable29_31
       4  ??DataTable29_32
       4  ??DataTable29_33
       4  ??DataTable29_34
       4  ??DataTable29_35
       4  ??DataTable29_36
       4  ??DataTable29_37
       4  ??DataTable29_38
       4  ??DataTable29_39
       4  ??DataTable29_4
       4  ??DataTable29_40
       4  ??DataTable29_41
       4  ??DataTable29_42
       4  ??DataTable29_43
       4  ??DataTable29_44
       4  ??DataTable29_45
       4  ??DataTable29_46
       4  ??DataTable29_47
       4  ??DataTable29_48
       4  ??DataTable29_49
       4  ??DataTable29_5
       4  ??DataTable29_50
       4  ??DataTable29_51
       4  ??DataTable29_52
       4  ??DataTable29_53
       4  ??DataTable29_54
       4  ??DataTable29_55
       4  ??DataTable29_56
       4  ??DataTable29_57
       4  ??DataTable29_58
       4  ??DataTable29_59
       4  ??DataTable29_6
       4  ??DataTable29_60
       4  ??DataTable29_61
       4  ??DataTable29_62
       4  ??DataTable29_63
       4  ??DataTable29_64
       4  ??DataTable29_65
       4  ??DataTable29_66
       4  ??DataTable29_67
       4  ??DataTable29_68
       4  ??DataTable29_69
       4  ??DataTable29_7
       4  ??DataTable29_70
       4  ??DataTable29_71
       4  ??DataTable29_72
       4  ??DataTable29_73
       4  ??DataTable29_74
       4  ??DataTable29_75
       4  ??DataTable29_76
       4  ??DataTable29_77
       4  ??DataTable29_78
       4  ??DataTable29_79
       4  ??DataTable29_8
       4  ??DataTable29_80
       4  ??DataTable29_81
       4  ??DataTable29_82
       4  ??DataTable29_83
       4  ??DataTable29_84
       4  ??DataTable29_85
       4  ??DataTable29_86
       4  ??DataTable29_87
       4  ??DataTable29_88
       4  ??DataTable29_89
       4  ??DataTable29_9
       4  ??DataTable29_90
       4  ??DataTable29_91
       4  ??DataTable29_92
       4  ??DataTable29_93
       4  ??DataTable29_94
       4  ??DataTable29_95
       4  ??DataTable29_96
       4  ??DataTable29_97
       4  ??DataTable9
       2  CurrentDataPointer
      50  GetAverageImuData
       1  IMUPresent
      78  IMURegRd
      74  IMURegWr
       4  IMUdbgPrt
      74  InputDataIntoBuffer
      12  NVIC_GenerateSystemReset
     532  PrintConfig
     224  RadioTxPktQueue
      36  ReadPage
       2  RfTxLevel
     276  SerialDownload
     562  SetConfig
      72  SetTimeSlot
     448  Task1
     532  Task3
    1380  Task8
    4548  TaskConfig
     180  TaskIMU_G
    2158  TaskRadioRx
     414  TaskRadioTx
      32  TimeSlotVals
       4  Valids
     190  WritePage
      22  _LocaleC_isspace
      24  __task1_bat_pack
      32  __task1_batbtn_pack
     144  __task1_batbtnimu_pack
     132  __task1_batimu_pack
      24  __task1_btn_pack
     132  __task1_btnimu_pack
     128  __task1_imu_pack
      24  __task1_led_pack
      32  __task1_ledbat_pack
      40  __task1_ledbatbtn_pack
     138  __task1_ledbatbtnimu_pack
     148  __task1_ledbatimu_pack
      32  __task1_ledbtn_pack
     144  __task1_ledbtnimu_pack
     136  __task1_ledimu_pack
       1  acc_adjust_count
       1  acc_done
       4  acc_time_adjust
      64  accs
       4  addr
       1  bat_slot_numbers
       1  beaconInSync
       1  beaconRSSI
     512  buff
       1  bufsize
       8  buttonA
       8  buttonB
       1  button_state
       4  calls
       4  changeClocks
       1  changeFrameClock
       1  cmd
      72  config
       4  counterIMU
     512  decoded
     512  encoded
       8  endRadioTx
       4  errorFrameId
      40  fLast
       4  fVolt
      18  fastdivide250
      42  fillmsgBAT
     170  fillmsgBTN
      76  fillmsgLED
      94  fillmsgPreamble
     220  filltxbuf
       1  firstTime
       1  frameAdjust
       4  frameIdCorrectionCount
       1  frameIdFlag
       2  frameOffset
       1  got_beacon
       2  halted
       4  header
       2  inIdx
      12  isspace
       4  iter
      12  lastBatStatus
       1  lastFrameClock
       4  lastFrameId
       4  lastFrameIdAtSync
       4  lastFrameIdCorrection
       8  lastFrameTime
       1  lastRadioTx
       1  lastTick
       2  lastTim3Phase
       4  lastTime
       4  last_bat_sent
       1  last_percents
   16380  log
       2  log_index_in
       4  lostSync
      22  memcpy
      22  memset
       4  mycalls
     150  mygets
       4  newFrameIdAtSync
       8  newFrameTime
       2  newTim3Phase
       4  newbcn
       4  notValids
       4  now_sec
       4  oldFrameIdAtSync
       8  oldFrameTime
       2  oldTim3Phase
       4  old_sec
       4  old_tim
       2  outIdx
       4  pRxPkt
       2  packet
    2056  page
       4  pushed_times
       2  pwr_holdCount
       1  queue_full
       8  radioRxEnd
       8  radioRxStart
       8  radioRxWait
       4  radioTxEntries
       4  random
       2  random_slot1
       2  random_slot2
       4  realFrameId
       4  remainOutOfSyncTime
       1  rfChan
       2  routerAddr
       4  rt_flags
       4  rxNotEmpty
       4  rxReloaded
       4  rxTotalRcvd
       1  rx_reload
       4  savedFrameIdAtSync
       1  semAllow
       1  semAllowPostTask
       1  seqNum
       1  setIMUReady
       1  setRadioTx
       1  setTxDone
       4  span
       8  startRadioTx
       4  successBeacons
    1024  tab_1024
       4  target
       1  task2StatusType
       4  task2_errors
       4  task2enter
       1  test_imu_pkt_ctr
       1  ticks
       4  tim
       2  tim4_phase
       2  tim_at_sec
     116  txBuf
       4  txCalls
       4  txCalls2
     960  txPktQueue
       2  txTimeSlot
       1  use_sync
       2  use_tim3_phase
       4  value
     352  -- Other

 
 20 523 bytes in section .bss
  2 098 bytes in section .data
      4 bytes in section .noinit
  3 745 bytes in section .rodata
 15 694 bytes in section .text
 
 15 616 bytes of CODE  memory (+ 78 bytes shared)
  3 745 bytes of CONST memory
 22 625 bytes of DATA  memory

Errors: none
Warnings: 25
